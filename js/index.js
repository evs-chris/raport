(function () {
    'use strict';

    const Fail = [];
    let detailedFail = 0;
    const _cause = [0, ''];
    const _latestCause = [0, ''];
    function getCause() { return _cause; }
    function getCauseCopy(name) {
        suggestCauseName(name ? name.name || name : undefined);
        return _cause.slice();
    }
    function resetLatestCause() {
        _latestCause[0] = 0;
        _latestCause[1] = '';
        _latestCause[2] = undefined;
        _latestCause[3] = undefined;
        _latestCause[4] = undefined;
    }
    function suggestCauseName(name) {
        if (!_cause[2] && name) {
            if (_cause[0] === _latestCause[0] && _cause[2] === _latestCause[2])
                _latestCause[2] = name;
            _cause[2] = name;
        }
    }
    function overrideCauseName(name) {
        if (name) {
            if (_cause[0] === _latestCause[0] && _cause[2] === _latestCause[2])
                _latestCause[2] = name;
            _cause[2] = name;
        }
    }
    function fail(pos, message, name, cause, causes) {
        _cause[0] = pos;
        _cause[1] = message || '';
        _cause[2] = name;
        _cause[3] = cause;
        _cause[4] = causes;
        if (detailedFail & 1 && _cause[0] >= _latestCause[0]) {
            _latestCause[0] = _cause[0];
            _latestCause[1] = _cause[1];
            _latestCause[2] = _cause[2];
            _latestCause[3] = _cause[3];
            _latestCause[4] = _cause[4];
        }
        return Fail;
    }
    function addCause(cause) {
        (_cause[4] || (_cause[4] = [])).push(cause);
    }
    function isNodeName(v) {
        return typeof v === 'string' || (v && 'name' in v && typeof v.name === 'string');
    }
    function openNode(start, name) {
        return { start, end: start, children: [], name };
    }
    function closeNode(node, parent, res) {
        node.end = res[1];
        if (_compact && node.end === node.start)
            return;
        node.result = res[0];
        if (!parent) {
            node.children.reduce((last, c, i) => {
                if (last < c.start)
                    (node.extra || (node.extra = {}))[i] = [last, c.start];
                return c.end;
            }, node.start);
            const l = node.children[node.children.length - 1];
            if (l && node.end > l.end)
                (node.extra || (node.extra = {}))[node.children.length] = [l.end, node.end];
        }
        else if (_compact) {
            if (node.name && node.name.primary) {
                const c = node.children[0];
                if (node.children.length === 1 && c.start === node.start && c.end === node.end)
                    parent.children.push(c);
                else {
                    node.name = node.name.name;
                    node.children.reduce((last, c, i) => {
                        if (last < c.start)
                            (node.extra || (node.extra = {}))[i] = [last, c.start];
                        return c.end;
                    }, node.start);
                    const l = node.children[node.children.length - 1];
                    if (l && node.end > l.end)
                        (node.extra || (node.extra = {}))[node.children.length] = [l.end, node.end];
                    parent.children.push(node);
                }
            }
            else if (node.children.length) {
                parent.children.push.apply(parent.children, node.children);
            }
        }
        else
            parent.children.push(node);
    }
    function nodeForPosition(node, pos, onlyNamed) {
        const res = [];
        let n = node;
        let c;
        while (n) {
            if (n.start <= pos && n.end >= pos && (!onlyNamed || n.name))
                res.unshift(n);
            c = null;
            for (let i = 0; i < n.children.length; i++) {
                c = n.children[i];
                if (c.start > pos || c.end < pos)
                    c = null;
                else
                    break;
            }
            n = c;
        }
        return res;
    }
    function getLineNum(input, pos) {
        let n = 1;
        while (~(pos = input.lastIndexOf('\n', pos))) {
            if (!pos)
                break;
            n++;
            pos--;
        }
        return n;
    }
    function getParseError(cause, input, context) {
        const lines = [];
        const pos = cause[0];
        let n = pos;
        let first = n = input.lastIndexOf('\n', n);
        let t = input.lastIndexOf('\n', n - 1);
        for (let i = 0; i < context && ~n; i++) {
            lines.unshift(input.substring(t + 1, n));
            n = t;
            t = input.lastIndexOf('\n', n - 1);
        }
        const markerOffset = lines.length + 1;
        t = first;
        n = input.indexOf('\n', t + 1);
        if (n === -1 && t < input.length)
            n = input.length;
        for (let i = 0; i <= context && ~n; i++) {
            lines.push(input.substring(t + 1, n));
            t = n;
            n = input.indexOf('\n', t + 1);
            if (n === -1 && t < input.length)
                n = input.length;
        }
        const source = lines[markerOffset - 1];
        let marker = '';
        const len = pos - (!~first ? -1 : first) - 1;
        for (let i = 0; i < len; i++)
            marker += source[i] === '\t' ? '\t' : ' ';
        marker += '^--';
        return {
            context: lines,
            column: pos - first,
            line: getLineNum(input, pos),
            position: pos,
            source,
            message: cause[1],
            marked: `${lines.slice(0, markerOffset).join('\n')}\n${marker}\n${lines.slice(markerOffset).join('\n')}`,
            cause: cause[3] && getParseError(cause[3], input, context),
            causes: cause[4] && cause[4].map(c => getParseError(c, input, context)),
            parser: cause[2] ? cause[2].name || cause[2] : undefined,
        };
    }
    function findLatestCause(cause) {
        let res = cause;
        if (cause[3]) {
            const c = findLatestCause(cause[3]);
            if (c[0] > res[0])
                res = c;
        }
        if (cause[4]) {
            const len = cause[4].length;
            for (let i = 0; i < len; i++) {
                const c = findLatestCause(cause[4][i]);
                if (c[0] > res[0])
                    res = c;
            }
        }
        if (_latestCause[0] >= _cause[0] && _latestCause[1] !== cause[1])
            return _latestCause;
        return res;
    }
    const startSpace = /^\s*/;
    const shared$2 = {};
    let _compact = false;
    function parser$2(parser, error) {
        let mps;
        const oerror = error;
        const det = (error ? (error.detailed ? 1 : 0) + (error.causes ? 2 : 0) : 0);
        const consume = error && error.consumeAll;
        const res = function parse(input, error) {
            const trim = error && 'trim' in error ? error.trim : oerror && oerror.trim;
            const start = trim ? startSpace.exec(input)[0].length : 0;
            if (trim)
                parser = shared$2.map(shared$2.seq(parser, shared$2.skip(' \t\r\n')), ([a]) => a);
            const d = (error ? (error.detailed ? 1 : 0) + (error.causes ? 2 : 0) : det);
            let res = [null, 0];
            if (d & 1)
                resetLatestCause();
            const node = (error && 'tree' in error && error.tree) && openNode(0);
            _compact = node && (error && 'compact' in error ? error.compact : oerror && 'compact' in oerror ? oerror.compact : false) === true;
            if (d !== detailedFail) {
                const c = detailedFail;
                detailedFail = d;
                res = (mps || (mps = unwrap(parser))).parse(input, start, res, node);
                detailedFail = c;
            }
            else {
                res = (mps || (mps = unwrap(parser))).parse(input, start, res, node);
            }
            if (res.length && (error && 'consumeAll' in error ? error.consumeAll : consume) && res[1] < input.length) {
                res = fail(res[1], d & 1 && `expected to consume all input, but only ${res[1]} chars consumed`);
            }
            if (!res.length) {
                if (error && 'undefinedOnError' in error ? error.undefinedOnError : oerror && oerror.undefinedOnError)
                    return;
                const cause = getCause();
                const ctx = (error && 'contextLines' in error ? error.contextLines : oerror && oerror.contextLines) || 0;
                const err = getParseError(getLatestCause(cause[4] || [], cause), input, ctx);
                const latest = findLatestCause(cause);
                if (cause !== latest)
                    err.latest = getParseError(latest, input, ctx);
                if (error && 'throw' in error ? error.throw : oerror && oerror.throw) {
                    const ex = new Error(err.message);
                    throw Object.assign(ex, err);
                }
                else
                    return err;
            }
            else {
                if (node) {
                    closeNode(node, null, res);
                    if (!_compact && trim) {
                        const n = node.children[0].children[0];
                        n.result = res[0];
                        return n;
                    }
                    return node;
                }
                return res[0];
            }
        };
        res.parser = parser;
        return res;
    }
    const uninit = { parse: (_s, p) => fail(p, detailedFail & 1 && 'uninitialized lazy parser') };
    function unwrap(parser) {
        return (parser.parser || parser) || uninit;
    }
    function lazy(init, parse) {
        let res;
        res = {
            parse(s, p, r, tree) {
                init();
                res.parse = parse;
                return parse(s, p, r, tree);
            }
        };
        return res;
    }
    function concat$1(strings) {
        let res = '';
        const len = strings.length;
        for (let i = 0; i < len; i++) {
            if (strings[i])
                res = res.concat(strings[i]);
        }
        return res;
    }
    function getLatestCause(causes, outer) {
        if (!causes || !outer)
            return _latestCause;
        let max = outer[0];
        outer[4] = causes;
        let f;
        const cs = causes || [];
        for (let i = 0; i < cs.length; i++) {
            if (cs[i][0] > max) {
                f = cs[i];
                max = f[0];
            }
        }
        if (f)
            return [f[0], f[1], f[2], outer];
        else
            return outer;
    }

    function contains0() {
        return false;
    }
    function contains1(str, x) {
        return str === x;
    }
    function contains2(str, x) {
        return str[0] === x || str[1] === x;
    }
    function contains3(str, x) {
        return str[0] === x || str[1] === x || str[2] === x;
    }
    function contains4(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x;
    }
    function contains5(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x || str[4] === x;
    }
    function contains6(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x || str[4] === x || str[5] === x;
    }
    function contains7(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x || str[4] === x || str[5] === x || str[6] === x;
    }
    function contains8(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x || str[4] === x || str[5] === x || str[6] === x || str[7] === x;
    }
    function contains9(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x || str[4] === x || str[5] === x || str[6] === x || str[7] === x || str[8] === x;
    }
    function contains10(str, x) {
        return str[0] === x || str[1] === x || str[2] === x || str[3] === x || str[4] === x || str[5] === x || str[6] === x || str[7] === x || str[8] === x || str[9] === x;
    }
    function containsFor(str, x) {
        const len = str.length;
        for (let i = 0; i < len; i++)
            if (str[i] === x)
                return true;
        return false;
    }
    function containsBinary(str, x) {
        let end = str.length - 1;
        let start = 0;
        if (x < str[0] || x > str[end])
            return false;
        let mid;
        let c;
        while (start <= end) {
            mid = (start + end) >> 1;
            c = str[mid];
            if (c === x)
                return true;
            else if (c < x)
                start = mid + 1;
            else
                end = mid - 1;
        }
    }
    function getSearch(str, sorted = true) {
        const len = str.length;
        if (len === 0)
            return contains0;
        if (len === 1)
            return contains1;
        if (len === 2)
            return contains2;
        if (len === 3)
            return contains3;
        if (len === 4)
            return contains4;
        if (len === 5)
            return contains5;
        if (len === 6)
            return contains6;
        if (len === 7)
            return contains7;
        if (len === 8)
            return contains8;
        if (len === 9)
            return contains9;
        if (len === 10)
            return contains10;
        if (sorted)
            return containsBinary;
        else
            return containsFor;
    }

    function charList(chars) {
        let res = '';
        const sorted = chars.split('').sort().join('');
        for (let i = 0; i < sorted.length; i++) {
            if (!~res.indexOf(sorted[i]))
                res += sorted[i];
        }
        return res;
    }
    function seekUntilChar(s, p, chars, contains) {
        const len = s.length;
        for (let i = p; i < len; i++) {
            if (contains(chars, s[i]))
                return i;
        }
        return len;
    }
    function seekWhileChar(s, p, chars, contains) {
        const len = s.length;
        for (let i = p; i < len; i++) {
            if (!contains(chars, s[i]))
                return i;
        }
        return len;
    }
    function skip(chars) {
        const sorted = charList(chars);
        const contains = getSearch(sorted);
        return {
            parse(s, p, res) {
                res[1] = seekWhileChar(s, p, sorted, contains);
                return res;
            }
        };
    }
    shared$2.skip = skip;
    function skip1(chars, name) {
        const sorted = charList(chars);
        const contains = getSearch(sorted);
        return {
            parse(s, p, res) {
                res[1] = seekWhileChar(s, p, sorted, contains);
                if (res[1] === p)
                    return fail(p, detailedFail & 1 && `expected at least one of ${JSON.stringify(chars)}`, name);
                return res;
            }
        };
    }
    function read(chars) {
        const sorted = charList(chars);
        const contains = getSearch(sorted);
        return {
            parse(s, p, res) {
                const r = seekWhileChar(s, p, sorted, contains);
                res[0] = s.substring(p, r);
                res[1] = r;
                return res;
            }
        };
    }
    function read1(chars, name) {
        const sorted = charList(chars);
        const contains = getSearch(sorted);
        return {
            parse(s, p, res) {
                const r = seekWhileChar(s, p, sorted, contains);
                if (r === p)
                    return fail(p, detailedFail & 1 && `expected one of ${JSON.stringify(chars)}`, name);
                res[0] = s.substring(p, r);
                res[1] = r;
                return res;
            }
        };
    }
    function chars(count, allowed, name) {
        const sorted = allowed && charList(allowed);
        const search = getSearch(sorted || '');
        return {
            parse(s, p, res) {
                if (s.length - p >= count) {
                    const str = s.substr(p, count);
                    if (sorted) {
                        for (let i = 0; i < count; i++)
                            if (!search(sorted, str[i]))
                                return fail(p + i, detailedFail & 1 && 'unexpected char', name);
                    }
                    res[0] = str;
                    res[1] = p + count;
                    return res;
                }
                else
                    return fail(p, detailedFail & 1 && 'unexpected end of input', name);
            }
        };
    }
    function notchars(count, disallowed, name) {
        const sorted = charList(disallowed);
        const search = getSearch(sorted);
        return {
            parse(s, p, res) {
                if (s.length - p >= count) {
                    const str = s.substr(p, count);
                    for (let i = 0; i < count; i++)
                        if (search(sorted, str[i]))
                            return fail(p + i, detailedFail & 1 && 'unexpected char', name);
                    res[0] = str;
                    res[1] = p + count;
                    return res;
                }
                else
                    return fail(p, detailedFail & 1 && 'unexpected end of input', name);
            }
        };
    }
    function readTo(stop, end, name) {
        const sorted = charList(stop);
        const contains = getSearch(sorted);
        return {
            parse(s, p, res) {
                const skipped = seekUntilChar(s, p, sorted, contains);
                if (!end && skipped >= s.length)
                    return fail(skipped - 1, detailedFail & 1 && `expected one of ${JSON.stringify(stop)} before end of input`, name);
                res[0] = skipped ? s.substring(p, skipped) : '';
                res[1] = skipped;
                return res;
            }
        };
    }
    function read1To(stop, end, name) {
        const op = readTo(stop, end);
        return {
            parse(s, p, resin) {
                const res = op.parse(s, p, resin);
                if (!res.length)
                    return res;
                else if (res[1] > p)
                    return res;
                else
                    return fail(p, detailedFail & 1 && `expected at least one character`, name);
            }
        };
    }

    function str(...strings) {
        const len = strings.length;
        if (len === 1) {
            const str = strings[0];
            const len = str.length;
            if (len === 1) {
                return {
                    parse(s, p, res) {
                        if (s[p] === str) {
                            res[0] = str;
                            res[1] = p + 1;
                            return res;
                        }
                        else
                            return fail(p, detailedFail & 1 && `expected ${str}`);
                    }
                };
            }
            else if (len === 2) {
                return {
                    parse(s, p, res) {
                        if (s[p] === str[0] && s[p + 1] === str[1]) {
                            res[0] = str;
                            res[1] = p + 2;
                            return res;
                        }
                        else
                            return fail(p, detailedFail & 1 && `expected ${str}`);
                    }
                };
            }
            else {
                let i, j;
                return {
                    parse(s, p, res) {
                        for (i = 0, j = p + i; i < len; i++, j++) {
                            if (str[i] !== s[j])
                                return fail(p, detailedFail & 1 && `expected ${str}`);
                        }
                        res[0] = str;
                        res[1] = p + len;
                        return res;
                    }
                };
            }
        }
        else {
            return {
                parse(s, p, res) {
                    outer: for (let i = 0; i < len; i++) {
                        const n = strings[i];
                        const nlen = n.length;
                        if (nlen === 1) {
                            if (s[p] === n)
                                return [n, p + nlen];
                            else
                                continue outer;
                        }
                        for (let j = 0; j < nlen; j++) {
                            if (n[j] !== s[p + j])
                                continue outer;
                        }
                        res[0] = n;
                        res[1] = p + nlen;
                        return res;
                    }
                    return fail(p, detailedFail & 1 && `expected ${strings.length > 1 ? 'one of ' : ''}${strings.map(s => `${s}`).join(', ')}`);
                }
            };
        }
    }
    function istr(...strings) {
        const copy = strings.slice();
        const chars = read1(copy.map(s => s.toLowerCase() + s.toUpperCase()).join(''));
        const idx = copy.map(s => s.toLowerCase());
        return {
            parse(s, p, res) {
                const r = chars.parse(s, p, res);
                if (!r.length)
                    return r;
                const i = idx.indexOf(r[0].toLowerCase());
                if (!~i)
                    return fail(p, detailedFail & 1 && `expected ${copy.length > 1 ? 'one of ' : ''}${copy.map(s => `${s}`).join(', ')}`);
                r[0] = copy[i];
                return r;
            }
        };
    }

    function opt(parser, name) {
        let ps;
        return lazy(() => ps = unwrap(parser), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, name);
            const res = ps.parse(s, p, resin, node);
            if (res.length) {
                if (node)
                    closeNode(node, tree, res);
                return res;
            }
            else {
                resin[0] = null;
                resin[1] = p;
                return resin;
            }
        });
    }
    function not(parser, message) {
        let ps;
        return lazy(() => ps = unwrap(parser), function parse(s, p, resin) {
            const res = ps.parse(s, p, resin);
            if (res.length)
                return fail(p, detailedFail & 1 && (message || `unexpected ${s.slice(p, res[1])}`));
            else {
                resin[0] = '';
                resin[1] = p;
                return resin;
            }
        });
    }
    function alt(name, ...parsers) {
        const nm = isNodeName(name) ? name : undefined;
        const lps = isNodeName(name) ? parsers : (name ? [name] : []).concat(parsers);
        let ps;
        const len = lps.length;
        return lazy(() => ps = lps.map(unwrap), function parse(s, p, resin, tree) {
            let fails;
            const node = tree && openNode(p, nm);
            for (let i = 0; i < len; i++) {
                const res = ps[i].parse(s, p, resin, node);
                if (res.length) {
                    if (node)
                        closeNode(node, tree, res);
                    return res;
                }
                else if (detailedFail & 2)
                    (fails || (fails = [])).push(getCauseCopy(nm));
            }
            if (detailedFail & 2) {
                const cause = getLatestCause(fails, [p, `expected ${nm || 'alternate'}`, nm]);
                if (fails.length && fails.map(f => f[0]).reduce((a, c) => a + c, 0) === fails[0][0] * fails.length)
                    cause[2] = nm;
                return fail(cause[0], cause[1], cause[2] || nm, cause[3], cause[4]);
            }
            else {
                if (detailedFail & 1 && getLatestCause()[0] === p && nm)
                    overrideCauseName(nm && (nm.name || nm));
                return fail(p, detailedFail & 1 && `expected ${nm || 'alternate'}`, nm);
            }
        });
    }
    function verify(parser, verify, name) {
        let ps;
        return lazy(() => ps = unwrap(parser), function parse(s, p, res, tree) {
            const node = tree && openNode(p, name);
            const r = ps.parse(s, p, res, node);
            if (!r.length)
                return r;
            const v = verify(r[0]);
            if (v === true) {
                if (node)
                    closeNode(node, tree, r);
                return r;
            }
            else
                return fail(r[1], v, name);
        });
    }
    function map(parser, fn, name) {
        let ps;
        let err;
        const none = '';
        const error = (e) => err = e;
        return lazy(() => ps = unwrap(parser), function parse(s, p, res, tree) {
            const node = tree && openNode(p, name);
            const r = ps.parse(s, p, res, node);
            if (r.length) {
                const last = err;
                err = none;
                r[0] = fn(r[0], error, p, r[1]);
                const cur = err;
                err = last;
                if (cur)
                    return fail(r[1], cur, name);
                if (node)
                    closeNode(node, tree, r);
                return r;
            }
            else {
                suggestCauseName(name && (name.name || name));
                return r;
            }
        });
    }
    shared$2.map = map;
    function name$2(parser, name) {
        let ps;
        return lazy(() => ps = unwrap(parser), function parse(s, p, res, tree) {
            if (tree) {
                const node = openNode(p, name);
                const r = ps.parse(s, p, res, node);
                if (r.length) {
                    if (node.children.length) {
                        node.children[0].name = name;
                        tree.children.push(node.children[0]);
                    }
                    else {
                        closeNode(node, tree, r);
                    }
                }
                if (detailedFail & 1)
                    suggestCauseName(typeof name === 'string' ? name : name.name);
                return r;
            }
            else {
                const r = ps.parse(s, p, res);
                if (!r.length && detailedFail & 1)
                    suggestCauseName(typeof name === 'string' ? name : name.name);
                return r;
            }
        });
    }

    function rep(parser, name) {
        let ps;
        const empty = [];
        return lazy(() => ps = unwrap(parser), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, name);
            let seq;
            let c = p;
            let res;
            res = ps.parse(s, c, resin, node);
            if (!res.length || res[1] === c) {
                resin[0] = empty;
                resin[1] = c;
                if (detailedFail & 2)
                    resin[2] = getCauseCopy(name);
                return resin;
            }
            else {
                c = res[1];
                seq = [res[0]];
            }
            while (1) {
                res = ps.parse(s, c, resin, node);
                if (res.length && res[1] !== c) {
                    seq.push(res[0]);
                    c = res[1];
                }
                else {
                    resin[0] = seq || [];
                    resin[1] = c;
                    detailedFail & 2 && (resin[2] = getCauseCopy(name));
                    if (node)
                        closeNode(node, tree, resin);
                    return resin;
                }
            }
        });
    }
    function rep1(parser, name) {
        let ps;
        return lazy(() => ps = unwrap(parser), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, name);
            let seq;
            let c = p;
            let res;
            res = ps.parse(s, c, resin, node);
            if (res.length) {
                (seq = []).push(res[0]);
                c = res[1];
                while (1) {
                    res = ps.parse(s, c, resin, node);
                    if (res.length) {
                        seq.push(res[0]);
                        c = res[1];
                    }
                    else {
                        resin[0] = seq;
                        resin[1] = c;
                        if (detailedFail & 2)
                            resin[2] = getCauseCopy(name);
                        if (node)
                            closeNode(node, tree, resin);
                        return resin;
                    }
                }
            }
            else {
                return fail(c, detailedFail & 1 && `expected at least one ${name || 'item'}`, name, detailedFail & 2 && getCauseCopy(name));
            }
        });
    }
    function repsep(parser, sep, trail = 'disallow', name) {
        let ps1;
        let ps2;
        const empty = [];
        return lazy(() => (ps1 = unwrap(parser), ps2 = unwrap(sep)), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, name);
            let seq;
            let c = p;
            let m = p;
            let rr;
            let res;
            let r;
            res = ps1.parse(s, c, resin, node);
            if (res.length && res[1] !== c) {
                rr = res[0];
                m = c;
                c = res[1];
                r = ps2.parse(s, c, resin);
                if (!r.length) {
                    if (trail === 'require')
                        return fail(m, detailedFail & 1 && `expected separator`, name);
                    resin[0] = [rr];
                    resin[1] = c;
                    if (node)
                        closeNode(node, tree, resin);
                    return resin;
                }
                else {
                    c = r[1];
                }
                seq = [rr];
            }
            else {
                resin[0] = empty;
                resin[1] = p;
                if (detailedFail & 2)
                    resin[2] = getCauseCopy(name);
                return resin;
            }
            while (1) {
                res = ps1.parse(s, c, resin, node);
                if (res.length && res[1] !== c) {
                    m = c;
                    c = res[1];
                    rr = res[0];
                    r = ps2.parse(s, c, resin);
                    if (!r.length) {
                        if (trail === 'require')
                            return fail(m, detailedFail & 1 && `expected separator`, name);
                        seq.push(rr);
                        break;
                    }
                    else
                        c = r[1];
                    seq.push(rr);
                }
                else if (trail === 'disallow' && seq && seq.length) {
                    if (detailedFail & 2) {
                        const cause = getCause();
                        return fail(cause[0], cause[1], name, [c, `unexpected separator`]);
                    }
                    else
                        return fail(c, detailedFail & 1 && `unexpected separator`, name);
                }
                else
                    break;
            }
            resin[0] = seq;
            resin[1] = c;
            detailedFail & 2 && (resin[2] = getCauseCopy(name));
            if (node)
                closeNode(node, tree, resin);
            return resin;
        });
    }
    function rep1sep(parser, sep, trail = 'disallow', name) {
        let ps1;
        let ps2;
        return lazy(() => (ps1 = unwrap(parser), ps2 = unwrap(sep)), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, name);
            let seq;
            let c = p;
            let l = c;
            let res;
            res = ps1.parse(s, c, resin, node);
            if (res.length) {
                (seq = []).push(res[0]);
                l = c = res[1];
                const r = ps2.parse(s, c, resin);
                if (!r.length) {
                    if (trail === 'require')
                        return fail(c, detailedFail & 1 && `expected separator`, name);
                }
                else {
                    c = r[1];
                    while (1) {
                        res = ps1.parse(s, c, resin, node);
                        if (res.length) {
                            seq.push(res[0]);
                            l = c = res[1];
                            const r = ps2.parse(s, c, resin);
                            if (!r.length) {
                                if (trail === 'require')
                                    return fail(c, detailedFail & 1 && `expected separator`, name);
                                break;
                            }
                            else
                                c = r[1];
                        }
                        else if (trail === 'disallow' && seq && seq.length) {
                            resin[0] = seq;
                            resin[1] = l;
                            if (node)
                                closeNode(node, tree, resin);
                            return resin;
                        }
                        else
                            break;
                    }
                }
            }
            else
                return fail(c, detailedFail & 1 && `expected at least one ${name || 'item'}`);
            resin[0] = seq;
            resin[1] = c;
            if (detailedFail & 2)
                resin[2] = getCauseCopy(name);
            if (node)
                closeNode(node, tree, resin);
            return resin;
        });
    }

    function bracket(first, content, right, name) {
        const nm = isNodeName(right) ? right : isNodeName(name) ? name : undefined;
        if (Array.isArray(first)) {
            let ends;
            let ps;
            const len = first.length;
            return lazy(() => (ps = unwrap(content), ends = first.map(unwrap)), function parse(s, p, resin, tree) {
                const node = tree && openNode(p, nm);
                let cause;
                let end;
                for (let i = 0; i < len; i++) {
                    const res = ends[i].parse(s, p, resin);
                    if (res.length) {
                        end = ends[i];
                        break;
                    }
                }
                if (!end)
                    return fail(p, detailedFail & 1 && `expected opening bracket`, name);
                const res = ps.parse(s, resin[1], resin, node);
                if (!res.length)
                    return res;
                if (detailedFail & 2)
                    cause = res[2];
                const v = res[0];
                const c = res[1];
                const fin = end.parse(s, c, resin);
                if (!fin.length)
                    return fail(c, detailedFail & 1 && `expected matching end bracket`, name, detailedFail & 2 && cause);
                resin[0] = v;
                if (node)
                    closeNode(node, tree, resin);
                return resin;
            });
        }
        else if (!isNodeName(right)) {
            let ps1;
            let ps2;
            let ps3;
            return lazy(() => (ps1 = unwrap(first), ps2 = unwrap(content), ps3 = unwrap(right)), function parse(s, p, resin, tree) {
                let cause;
                const node = tree && openNode(p, nm);
                const r1 = ps1.parse(s, p, resin);
                if (!r1.length)
                    return r1;
                const r2 = ps2.parse(s, r1[1], resin, node);
                if (!r2.length)
                    return r2;
                if (detailedFail & 2 && r2[2])
                    cause = r2[2];
                const r = r2[0];
                const r3 = ps3.parse(s, r2[1], resin);
                if (!r3.length) {
                    if (detailedFail & 2 && cause)
                        addCause(cause);
                    return r3;
                }
                resin[0] = r;
                if (node)
                    closeNode(node, tree, resin);
                return resin;
            });
        }
    }
    function seq(name, ...parsers) {
        let nm;
        if (typeof name !== 'string')
            parsers.unshift(name);
        else
            nm = name;
        let ps;
        const len = parsers.length;
        return lazy(() => ps = parsers.map(unwrap), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, nm);
            let res;
            let c = p;
            let causes;
            let r;
            r = ps[0].parse(s, c, resin, node);
            if (!r.length) {
                if (detailedFail & 2) {
                    const cause = getLatestCause(causes, getCauseCopy(nm));
                    return fail(cause[0], cause[1], cause[2], cause[3], cause[4]);
                }
                else
                    return r;
            }
            else {
                if (detailedFail & 2 && r[2])
                    (causes || (causes = [])).push(r[2]);
                (res = []).push(r[0]);
                c = r[1];
                for (let i = 1; i < len; i++) {
                    r = ps[i].parse(s, c, resin, node);
                    if (!r.length) {
                        if (detailedFail & 2) {
                            const cause = getLatestCause(causes, getCauseCopy(nm));
                            return fail(cause[0], cause[1], cause[2], cause[3], cause[4]);
                        }
                        else
                            return r;
                    }
                    else {
                        if (detailedFail & 2 && r[2])
                            (causes || (causes = [])).push(r[2]);
                        res.push(r[0]);
                        c = r[1];
                    }
                }
            }
            resin[0] = res;
            resin[1] = c;
            if (detailedFail & 2)
                resin[2] = [p, 'error in seq', null, null, causes];
            if (node)
                closeNode(node, tree, resin);
            return resin;
        });
    }
    shared$2.seq = seq;
    function check$1(name, ...parsers) {
        let ps;
        let nm;
        if (typeof name !== 'string')
            parsers.unshift(name);
        else
            nm = name;
        const len = parsers.length;
        return lazy(() => ps = parsers.map(unwrap), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, nm);
            let c = p;
            let causes;
            let r;
            r = ps[0].parse(s, c, resin);
            if (!r.length) {
                if (detailedFail & 2) {
                    const cause = getLatestCause(causes, getCauseCopy(nm));
                    return fail(cause[0], cause[1], cause[2], cause[3], cause[4]);
                }
                else
                    return r;
            }
            else {
                if (detailedFail & 2 && r[2])
                    (causes || (causes = [])).push(r[2]);
                c = r[1];
                for (let i = 1; i < len; i++) {
                    r = ps[i].parse(s, c, resin);
                    if (!r.length) {
                        if (detailedFail & 2) {
                            const cause = getLatestCause(causes, getCauseCopy(nm));
                            return fail(cause[0], cause[1], cause[2], cause[3], cause[4]);
                        }
                        else
                            return r;
                    }
                    else {
                        if (detailedFail & 2 && r[2])
                            (causes || (causes = [])).push(r[2]);
                        c = r[1];
                    }
                }
            }
            resin[0] = null;
            resin[1] = c;
            if (node)
                closeNode(node, tree, resin);
            return resin;
        });
    }
    function andNot(parser, not, name) {
        let ps;
        let np;
        return lazy(() => (ps = unwrap(parser), np = unwrap(not)), function parse(s, p, resin, tree) {
            const node = tree && openNode(p, name);
            const res = ps.parse(s, p, resin, node);
            if (!res.length)
                return res;
            const c = res[1];
            const not = np.parse(s, c, resin);
            if (not.length)
                return fail(c, detailedFail & 1 && `unexpected ${s.slice(c, res[1])}`, name);
            else {
                if (node)
                    closeNode(node, tree, res);
                return res;
            }
        });
    }

    const _hex = 'abcdefABCDEF';
    const digits = '0123456789';
    const alpha = _hex + 'ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ';
    const identStart = _hex + alpha + '$_';
    const hex$1 = _hex + digits;
    const space$4 = ' \t\n\r';
    const escmap$1 = { b: '\b', r: '\r', n: '\n', "'": "'", '"': '"', t: '\t', '\\': '\\' };
    const underscores = /_/g;
    const JNum = map(seq(opt(str('-', '+')), read1(digits), read(digits + '_'), opt(str(".")), read(digits + '_'), map(opt(seq(str('e', 'E'), opt(str('+', '-')), read1(digits + '_'))), r => r && concat$1(r))), r => +(concat$1(r).replace(underscores, '')));
    const JStringEscape = map(seq(str("\\"), notchars(1, 'xu')), r => escmap$1[r[1]] || r[1]);
    const JStringUnicode = map(seq(str("\\u"), chars(4, hex$1)), r => String.fromCharCode(parseInt(r[1], 16)));
    const JStringHex = map(seq(str('\\x'), chars(2, hex$1)), r => String.fromCharCode(parseInt(r[1], 16)));
    const JString = alt(bracket(str('"'), map(rep(alt('string part', read1To('"\\'), JStringUnicode, JStringHex, JStringEscape)), r => concat$1(r)), str('"')), bracket(str('\''), map(rep(alt('string part', read1To('\'\\'), JStringUnicode, JStringHex, JStringEscape)), r => concat$1(r)), str('\'')));
    const JBool = map(str('true', 'false'), v => v === 'true');
    const JNull = map(str('null'), () => null);
    const JIdentifier = map(seq(read1(identStart), opt(read(identStart + digits))), ([s, t]) => t !== null ? s + t : s);
    const ws$2 = skip(space$4);
    const JArray = {};
    const JObject = {};
    const JValue = alt('value', JString, JArray, JObject, JNum, JBool, JNull);
    const JKeyPair = map(seq(ws$2, alt('key', JString, JIdentifier), check$1(ws$2, str(':'), ws$2), JValue), r => [r[1], r[3]]);
    JArray.parser = bracket(check$1(str('['), ws$2), repsep(JValue, check$1(ws$2, str(','), ws$2), 'allow'), check$1(ws$2, str(']')));
    JObject.parser = map(bracket(check$1(str('{'), ws$2), repsep(JKeyPair, check$1(ws$2, str(','), ws$2), 'allow'), check$1(ws$2, str('}'))), pairs => {
        const len = pairs.length;
        const res = {};
        for (let i = 0; i < len; i++) {
            const pair = pairs[i];
            res[pair[0]] = pair[1];
        }
        return res;
    });
    parser$2(map(seq(ws$2, JValue, ws$2), r => r[1]));

    const timespans = {
        y: 0,
        m: 0,
        w: 0,
        d: 86400000,
        h: 3600000,
        mm: 60000,
        s: 1000,
    };
    timespans.w = timespans.d * 7;
    timespans.y = Math.floor(timespans.d * 365.25);
    timespans.m = Math.floor(timespans.d * 30.45);
    function isTimespanMS(v) {
        return typeof v === 'object' && v && typeof v.ms === 'number';
    }
    function timeSpanToNumber(v) {
        if (typeof v === 'number')
            return v;
        else if (isTimespanMS(v))
            return v.ms;
        else
            return ((((((((((((v.d[0] || 0) * 12) + (v.d[1] || 0)) * 30.45) + (v.d[2] || 0)) * 24) + (v.d[3] || 0)) * 60) + (v.d[4] || 0)) * 60) + (v.d[5] || 0)) * 1000) + (v.d[6] || 0);
    }
    const space$3 = ' \r\n\t';
    const endSym = space$3 + '():{}[]<>,"\'`\\;&#';
    const endRef = endSym + '.+/*|^%=!?';
    const _comment = map(seq(ws$2, str('//'), opt(str(' ')), readTo('\n'), str('\n')), ([, , , c]) => ({ c }), { name: 'comment', primary: true });
    function comment(prop, p) {
        return map(seq(rep(_comment), ws$2, p), ([c, , v]) => {
            if (c && c.length)
                v[prop] = c.map(c => c.c);
            return v;
        });
    }
    const rws = skip1(space$3, 'required-space');
    const keywords$1 = map(str('null', 'true', 'false', 'undefined'), v => {
        switch (v) {
            case 'null': return null;
            case 'true': return true;
            case 'false': return false;
            case 'undefined': return undefined;
        }
    }, { primary: true, name: 'primitive' });
    const ident = read1To(endRef, true);
    const sexprop = read1To(' \r\n\t():{}[],"\'\\;&#@', true);
    const args = {};
    const array = {};
    const block = {};
    const object = {};
    const value$1 = {};
    const values$1 = {};
    const application = {};
    const escmap = { n: '\n', r: '\r', t: '\t', b: '\b' };
    const pathesc = map(seq(str('\\'), chars(1)), ([, char]) => escmap[char] || char);
    const pathident = map(rep1(alt('ref-part', read1To(endRef, true), pathesc)), parts => parts.join(''), 'keypath-part');
    const dotpath = map(seq(str('.'), pathident), ([, part]) => part);
    const bracketpath = bracket(seq(str('['), ws$2), value$1, seq(ws$2, str(']')));
    const keypath = map(seq(alt('ref-sigil', str('!', '~', '*'), seq(read('^'), opt(str('@', '.')))), alt('keypath', pathident, bracketpath), rep(alt('keypath', dotpath, bracketpath))), ([prefix, init, parts]) => {
        const res = { k: [init].concat(parts).map(p => typeof p === 'object' && 'v' in p && (typeof p.v === 'string' || typeof p.v === 'number') ? p.v : p) };
        if (Array.isArray(prefix)) {
            if (prefix[0])
                res.u = prefix[0].length;
            if (prefix[1] === '@')
                res.p = '@';
        }
        else if (prefix) {
            res.p = prefix;
        }
        return res;
    }, 'keypath');
    const localpath = map(seq(read('^'), pathident, rep(alt('keypath', dotpath, bracketpath))), ([prefix, init, parts]) => {
        const res = { k: [init].concat(parts).map(p => typeof p === 'object' && 'v' in p && (typeof p.v === 'string' || typeof p.v === 'number') ? p.v : p) };
        if (prefix)
            res.u = prefix.length;
        return res;
    }, 'localpath');
    const parsePath = parser$2(keypath);
    const parseLetPath = parser$2(localpath);
    const illegalRefs = ['if', 'else', 'elif', 'elseif', 'elsif', 'fi', 'esac', 'unless', 'then', 'case', 'when', 'not', 'gte', 'gt', 'lte', 'lt', 'in', 'like', 'ilike', 'not-in', 'not-like', 'not-ilike', 'contains', 'does-not-contain', 'is-not', 'is', 'strict-is-not', 'strict-is', 'deep-is-not', 'deep-is', 'and', 'or', 'end', 'with', 'each'];
    const ref = map(keypath, (r, err) => {
        if (r.k.length === 1 && !r.p && !r.u && illegalRefs.includes(r.k[0]))
            err(`invalid reference name '${r.k[0]}'`);
        return { r };
    }, { primary: true, name: 'reference' });
    function stringInterp(parts) {
        const res = parts.reduce((a, c) => {
            if (a.length) {
                if ('v' in c && 'v' in a[a.length - 1] && typeof c.v === 'string' && typeof a[a.length - 1].v === 'string')
                    a[a.length - 1].v += c.v;
                else
                    a.push(c);
            }
            else {
                a.push(c);
            }
            return a;
        }, []);
        if (res.length > 0 && (!('v' in res[0]) || typeof res[0].v !== 'string'))
            res.unshift({ v: '' });
        if (res.length === 0)
            return { v: '' };
        else if (res.length === 1)
            return res[0];
        return { op: '+', args: res };
    }
    const timespan = map(rep1sep(seq(JNum, ws$2, istr('years', 'year', 'y', 'months', 'month', 'minutes', 'minute', 'milliseconds', 'millisecond', 'mm', 'ms', 'm', 'weeks', 'week', 'w', 'days', 'day', 'd', 'hours', 'hour', 'h', 'seconds', 'second', 's')), ws$2), parts => {
        const span = { y: 0, m: 0, d: 0, h: 0, mm: 0, s: 0, ms: 0 };
        for (let i = 0; i < parts.length; i++) {
            if (parts[i][2][0] === 'y')
                span.y += parts[i][0];
            else if (parts[i][2] === 'm' || parts[i][2] === 'months' || parts[i][2] === 'month')
                span.m += parts[i][0];
            else if (parts[i][2][0] === 'd')
                span.d += parts[i][0];
            else if (parts[i][2][0] === 'w')
                span.d += parts[i][0] * 7;
            else if (parts[i][2][0] === 'h')
                span.h += parts[i][0];
            else if (parts[i][2][0] === 's')
                span.s += parts[i][0];
            else if (parts[i][2] === 'mm' || parts[i][2] === 'minutes' || parts[i][2] === 'minute')
                span.mm += parts[i][0];
            else if (parts[i][2] === 'ms' || parts[i][2] === 'milliseconds' || parts[i][2] === 'millisecond')
                span.ms += parts[i][0];
        }
        if (!span.y && !span.m && !span.d) {
            delete span.y;
            delete span.m;
            delete span.d;
            let n = 0;
            for (const k in span)
                n += span[k] * (timespans[k] || 1);
            return { ms: n };
        }
        else {
            const s = [];
            if (span.y)
                s[0] = span.y;
            if (span.m)
                s[1] = span.m;
            if (span.d)
                s[2] = span.d;
            if (span.h)
                s[3] = span.h;
            if (span.mm)
                s[4] = span.mm;
            if (span.s)
                s[5] = span.s;
            if (span.ms)
                s[6] = span.ms;
            return { d: s };
        }
    }, { primary: true, name: 'timespan' });
    const timezone = map(seq(ws$2, alt('timezone', istr('z'), seq(opt(chars(1, '+-')), alt(chars(4, digits), chars(2, digits), chars(1, digits)), opt(seq(str(':'), chars(2, digits)))))), v => {
        if (v[1][0] === 'z')
            return 0;
        else {
            let res;
            if (v[1][1].length === 4) {
                res = +v[1][1].substr(0, 2) * 60 + +v[1][1].substr(2, 2);
            }
            else {
                res = +v[1][1] * 60;
                if (v[1][2])
                    res += +v[1][2][1];
            }
            if (v[1][0] === '-')
                res *= -1;
            return res;
        }
    });
    const timeexact = alt(map(seq(read1(digits), opt(seq(str(':'), chars(2, digits), opt(seq(str(':'), chars(2, digits), opt(seq(str('.'), chars(3, digits)))))))), v => {
        const h = v[0];
        const m = v[1] && v[1][1];
        const s = m && v[1][2] && v[1][2][1];
        const ms = s && v[1][2][2] && v[1][2][2][1];
        const res = [+h];
        if (m)
            res[1] = +m;
        if (s)
            res[2] = +s;
        if (ms)
            res[3] = +ms;
        return res;
    }), map(istr('start', 'midnight'), () => [0, 0, 0, 0]), map(istr('noon', 'mid'), () => [12, 0, 0, 0]), map(istr('end'), () => [23, 59, 59, 999]));
    const parseTime = parser$2(alt(map(seq(timeexact, opt(seq(ws$2, timezone))), ([tm, z]) => {
        if (z)
            tm.push(z[1]);
        return tm;
    }), timezone), { trim: true, consumeAll: true, undefinedOnError: true });
    const dateend = opt(seq(ws$2, str('>')));
    const daterel = alt('date', map(seq(opt(istr('last', 'this', 'next')), rws, istr('week', 'month', 'year'), opt(timezone), dateend), ([o, , f, tz, e]) => {
        const val = { f: f[0] === 'w' ? 'w' : f[0] === 'm' ? 'm' : 'y', o: o === 'last' ? -1 : o === 'next' ? 1 : 0, e: e ? 1 : undefined };
        if (tz != null)
            val.z = tz;
        return val;
    }), map(seq(istr('week', 'month', 'year'), seq(rws, istr('to'), rws, istr('date')), opt(timezone), dateend), ([f, , tz, e]) => {
        const val = { f: f[0] === 'w' ? 'w' : f[0] === 'm' ? 'm' : 'y', o: 0, d: 1, e: e ? 1 : undefined };
        if (tz != null)
            val.z = tz;
        return val;
    }), map(seq(istr('yesterday', 'today', 'tomorrow'), alt(bracket(ws$2, istr('at'), ws$2), rws), timeexact, ws$2, opt(timezone)), v => {
        const res = { f: 'd', o: v[0] === 'yesterday' ? -1 : v[0] === 'today' ? 0 : 1, t: v[2] };
        if (v[4] != null)
            res.t[4] = v[4];
        return res;
    }), map(seq(istr('yesterday', 'today', 'tomorrow', 'now'), opt(timezone), dateend), ([v, tz, e]) => {
        const val = (v === 'now' ? { f: 'n', o: 0 } : { f: 'd', o: v === 'yesterday' ? -1 : v === 'today' ? 0 : 1, e: e ? 1 : undefined });
        if (tz != null)
            val.z = tz;
        return val;
    }), map(seq(istr('in'), rws, timespan), v => (typeof v[2] === 'number' || isTimespanMS(v[2]) ? { f: 'n', o: timeSpanToNumber(v[2]) } : { f: 'n', o: v[2].d })), map(seq(timespan, rws, alt('relative time anchor', istr('ago'), seq(istr('from'), rws, istr('now'))), opt(timezone)), ([span, , ref, tz]) => {
        let val;
        if (typeof span === 'number' || isTimespanMS(span)) {
            val = { f: 'n', o: timeSpanToNumber(span) * (ref === 'ago' ? -1 : 1) };
        }
        else {
            val = { f: 'n', o: span.d, d: ref === 'ago' ? -1 : undefined };
        }
        if (tz != null)
            val.z = tz;
        return val;
    }));
    function setIndex(array, index, value) {
        if (value == null)
            return array;
        array[index] = value;
        return array;
    }
    const dateexact = map(seq(chars(4, digits), opt(seq(chars(1, '-/'), read1(digits), opt(seq(chars(1, '-/'), read1(digits))))), opt(seq(alt(bracket(rws, istr('at'), rws), istr('t'), rws), timeexact)), opt(timezone), dateend), v => {
        const y = v[0];
        const m = v[1] && v[1][1];
        const d = m && v[1][2] && v[1][2][1];
        const time = v[2] && v[2][1];
        const tz = v[3];
        const e = v[4] ? 1 : undefined;
        if (!m)
            return { f: setIndex([+y], 7, tz), e };
        else if (!d)
            return { f: setIndex([+y, +m - 1], 7, tz), e };
        else if (!time)
            return { f: setIndex([+y, +m - 1, +d], 7, tz), e };
        else {
            const res = { f: [+y, +m - 1, +d], e };
            for (let i = 0; i < time.length; i++) {
                if (time[i] != null)
                    res.f[i + 3] = time[i];
            }
            if (tz != null)
                res.f[7] = tz;
            return res;
        }
    });
    const date$2 = bracket(str('#'), alt('date', dateexact, daterel, timespan), str('#'), { primary: true, name: 'date' });
    const typelit = map(seq(str('@['), ws$2, schema(), ws$2, str(']')), ([, , v]) => ({ v, s: 1 }), { name: 'typelit', primary: true });
    const parseDate = parser$2(map(seq(opt(str('#')), alt('date', dateexact, daterel, timespan), opt(str('#'))), ([, d,]) => d), { trim: true, consumeAll: true, undefinedOnError: true });
    const string = alt({ primary: true, name: 'string' }, map(seq(str(':'), read1To(endSym, true)), v => ({ v: v[1] })), map(bracket(str('"'), rep(alt('string-part', read1To('\\"'), JStringEscape, JStringUnicode, JStringHex)), str('"')), a => ({ v: ''.concat(...a) })), map(bracket(str(`'`), rep(alt('string-part', map(read1To(`'\\$\{`, true), v => ({ v })), map(str('\\$', '$$'), () => ({ v: '$' })), bracket(str('${', '{'), value$1, str('}'), { primary: true, name: 'string-interpolation' }), map(str('$', '{'), v => ({ v })), map(JStringUnicode, v => ({ v })), map(JStringHex, v => ({ v })), map(JStringEscape, v => ({ v })))), str(`'`)), stringInterp), map(bracket(str('`'), rep(alt('string-part', map(read1To('`\\${', true), v => ({ v })), map(str('\\$', '$$'), () => ({ v: '$' })), bracket(str('${'), value$1, str('}'), { primary: true, name: 'string-interpolation' }), map(str('$', '{'), v => ({ v })), map(JStringUnicode, v => ({ v })), map(JStringHex, v => ({ v })), map(JStringEscape, v => ({ v })))), str('`')), stringInterp));
    const literal = map(alt('literal', map(JNum, v => v, { primary: true, name: 'number' }), keywords$1, date$2), v => {
        if (v instanceof Date || v == null || typeof v !== 'object')
            return { v };
        else
            return v;
    });
    const sexp = map(bracket(check$1(str('('), ws$2), seq(sexprop, ws$2, args), check$1(ws$2, str(')'))), ([op, , args]) => {
        const res = { op };
        if (args[0] && args[0].length)
            res.args = args[0];
        if (args[1])
            res.opts = args[1];
        return res;
    }, { primary: true, name: 's-expression' });
    function fmt_op(parser) {
        return map(seq(parser, rep(seq(str('#'), ident, opt(alt(map(seq(str(','), rep1sep(value$1, str(','), 'allow')), ([, value]) => [value, undefined]), bracket_op(args)))), { primary: true, name: 'format-op' })), ([value, fmt]) => {
            if (!fmt || !fmt.length)
                return value;
            return fmt.reduce((a, c) => c[2] ?
                { op: 'fmt', args: [a, { v: c[1] }, ...(c[2][0] || [])], opts: c[2][1] } :
                { op: 'fmt', args: [a, { v: c[1] }] }, value);
        }, 'fmt-op');
    }
    function bracket_op(parser) {
        return bracket(seq(str('('), ws$2), parser, seq(ws$2, str(')')));
    }
    const binop = {};
    const if_op$1 = {};
    const case_op$1 = {};
    const opName = read1('abcdefghifghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_$0123456789');
    const call_op$1 = map(seq(name$2(opName, 'op'), bracket_op(args)), ([op, args]) => {
        const res = { op };
        if (args[0] && args[0].length)
            res.args = args[0];
        if (args[1])
            res.opts = args[1];
        return res;
    }, { primary: true, name: 'call' });
    const operand = fmt_op(postfix_path(alt('operand', bracket_op(application), bracket_op(if_op$1), bracket_op(case_op$1), verify(bracket_op(binop), v => 'op' in v || `expected bracketed op`), sexp, values$1)));
    const unop = map(seq(str('not ', '+', '-'), operand), ([op, arg]) => ({ op: op === 'not ' ? 'not' : op, args: [arg] }), 'unary op');
    function leftassoc(left, [, op, , right]) {
        return { op, args: [left, right] };
    }
    function rightassoc(left, more) {
        if (more.length === 1)
            return { op: more[0][1], args: [left, more[0][3]] };
        const end = more.pop();
        let op = more[more.length - 1][1];
        const first = { op: end[1], args: [more.pop()[3], end[3]] };
        const right = more.reverse().reduce((a, c) => {
            const res = { op, args: [c[3], a] };
            op = c[1];
            return res;
        }, first);
        return { op, args: [left, right] };
    }
    const binop_e = map(seq(operand, rep(seq(rws, name$2(str('**'), 'exp op'), rws, operand))), ([arg1, more]) => more.length ? rightassoc(arg1, more) : arg1, 'exp-op');
    const binop_md = map(seq(binop_e, rep(seq(rws, name$2(str('*', '/%', '/', '%'), 'muldiv-op'), rws, binop_e))), ([arg1, more]) => more.length ? more.reduce(leftassoc, arg1) : arg1, 'muldiv-op');
    const binop_as = map(seq(binop_md, rep(seq(rws, name$2(str('+', '-'), 'addsub-op'), rws, binop_md))), ([arg1, more]) => more.length ? more.reduce(leftassoc, arg1) : arg1, 'addsub-op');
    const binop_cmp = map(seq(binop_as, rep(seq(rws, name$2(str('>=', '>', '<=', '<', 'gte', 'gt', 'lte', 'lt', 'in', 'like', 'ilike', 'not-in', 'not-like', 'not-ilike', 'contains', 'does-not-contain'), 'cmp-op'), rws, binop_as))), ([arg1, more]) => more.length ? more.reduce(leftassoc, arg1) : arg1, 'cmp-op');
    const binop_eq = map(seq(binop_cmp, rep(seq(rws, name$2(str('is-not', 'is', 'strict-is-not', 'strict-is', 'deep-is-not', 'deep-is', '===', '==', '!==', '!='), 'eq-op'), rws, binop_cmp))), ([arg1, more]) => more.length ? more.reduce(leftassoc, arg1) : arg1, 'eq-op');
    const binop_and = map(seq(binop_eq, rep(seq(rws, name$2(str('and', '&&'), 'and-op'), rws, binop_eq))), ([arg1, more]) => more.length ? more.reduce(leftassoc, arg1) : arg1, 'and-op');
    const binop_or = map(seq(binop_and, rep(seq(rws, name$2(str('or', '||', '??'), 'or-op'), rws, binop_and))), ([arg1, more]) => more.length ? more.reduce(leftassoc, arg1) : arg1, 'or-op');
    binop.parser = map(binop_or, v => v, { primary: true, name: 'binary-op' });
    if_op$1.parser = alt({ primary: true, name: 'conditional' }, map(seq(str('if'), rws, value$1, rws, block, rep(seq(ws$2, str('else if', 'elseif', 'elsif', 'elif'), rws, value$1, rws, block)), opt(seq(ws$2, str('else'), rws, block))), ([, , cond1, , block1, elifs, el]) => {
        const op = { op: 'if', args: [cond1, block1] };
        for (const [, , , cond, , block] of elifs)
            op.args.push(cond, block);
        if (el)
            op.args.push(el[3]);
        return op;
    }, 'if-block'), map(seq(str('if'), rws, value$1, rws, str('then'), rws, value$1, rep(seq(rws, not(str('end', 'fi')), str('else if', 'elseif', 'elsif', 'elif'), rws, value$1, rws, str('then'), rws, value$1)), opt(seq(rws, str('else'), rws, value$1)), opt(seq(rws, str('end', 'fi')))), ([, , cond1, , , , val1, elifs, el]) => {
        const op = { op: 'if', args: [cond1, val1] };
        for (const [, , , , cond, , , , val] of elifs)
            op.args.push(cond, val);
        if (el)
            op.args.push(el[3]);
        return op;
    }, 'if'), map(seq(str('unless'), rws, value$1, rws, str('then'), rws, value$1, opt(seq(rws, str('else'), rws, value$1)), opt(seq(rws, str('end')))), ([, , cond, , , , hit, miss]) => {
        const op = { op: 'unless', args: [cond, hit] };
        if (miss)
            op.args.push(miss[3]);
        return op;
    }));
    function replaceCase(op) {
        if (!op.args || !op.args.length)
            return false;
        let found = false;
        for (let i = 0; i < op.args.length; i++) {
            const arg = op.args[i];
            if ('r' in arg && (arg.r === '_' || (typeof arg.r === 'object' && arg.r.k[0] === '_'))) {
                arg.r = { k: ['case'].concat((arg.r.k || []).slice(1)), p: '@' };
                found = true;
            }
            else if ('r' in arg && typeof arg.r === 'object' && arg.r.p === '@' && arg.r.k[0] === 'case') {
                found = true;
            }
            else if ('op' in arg)
                found = found || replaceCase(arg);
        }
        return found;
    }
    const case_branch = alt(map(seq(rws, not(str('end', 'esac')), str('when'), rws, value$1, rws, str('then'), rws, value$1), ([, , , , cond, , , , hit]) => [cond, hit], 'when-branch'), map(seq(rws, not(str('end', 'esac')), str('else'), rws, value$1), ([, , , , hit]) => [undefined, hit], 'else-branch'), map(seq(rws, not(str('end', 'esac')), str('when'), rws, value$1, rws, block), ([, , , , cond, , hit]) => [cond, hit], 'when-block'));
    case_op$1.parser = alt(map(seq(str('case'), rws, value$1, rep(case_branch), opt(seq(rws, str('end', 'esac')))), ([, , val, branches]) => {
        const op = { op: 'case', args: [val] };
        for (let i = 0; i < branches.length; i++) {
            if (branches[i][0] === undefined)
                op.args.push(branches[i][1]);
            else {
                let arg = branches[i][0];
                if ('op' in arg)
                    replaceCase(arg);
                op.args.push(arg);
                op.args.push(branches[i][1]);
            }
        }
        return op;
    }, 'case'));
    function postfix_path(parser) {
        return map(seq(parser, rep(alt('keypath', dotpath, bracketpath))), ([v, k]) => {
            if (k.length)
                return { op: 'get', args: [v, { v: { k } }] };
            else
                return v;
        }, 'postfix-path-op');
    }
    const operation = alt('expression', if_op$1, case_op$1, binop);
    const pair = map(seq(alt('key', string, map(ident, v => ({ v }))), ws$2, str(':'), ws$2, value$1), t => [t[0], t[4]], 'pair');
    array.parser = map(bracket(check$1(ws$2, str('['), ws$2), repsep(value$1, read1(space$3 + ','), 'allow'), check$1(ws$2, str(']'))), args => args.filter(a => !('v' in a)).length ? { op: 'array', args } : { v: args.map(a => a.v) }, { primary: true, name: 'array' });
    function objectOp(pairs) {
        return pairs.filter(p => !('v' in p[0] && 'v' in p[1])).length ?
            { op: 'object', args: pairs.reduce((a, c) => (a.push(c[0], c[1]), a), []) } :
            { v: pairs.reduce((a, c) => (a[c[0].v] = c[1].v, a), {}) };
    }
    object.parser = map(bracket(check$1(ws$2, str('{'), ws$2), repsep(pair, read1(space$3 + ','), 'allow'), check$1(ws$2, str('}'))), objectOp, { primary: true, name: 'object' });
    block.parser = map(bracket(check$1(ws$2, str('{'), ws$2), rep1sep(value$1, read1(space$3 + ';'), 'allow'), check$1(ws$2, str('}'))), args => ({ op: 'block', args }), { primary: true, name: 'block' });
    value$1.parser = unwrap(comment('c', operation));
    const namedArg = map(seq(ident, str(':'), ws$2, value$1), ([k, , , v]) => [{ v: k }, v], 'named-arg');
    application.parser = map(seq(opt(bracket(check$1(str('|'), ws$2), rep1sep(opName, read1(space$3 + ','), 'allow'), str('|'))), ws$2, str('=>', '=\\'), ws$2, value$1), ([names, , , , value]) => (names ? { a: value, n: names } : { a: value }), { primary: true, name: 'application' });
    args.parser = map(repsep(alt('argument', namedArg, value$1), read1(space$3 + ','), 'allow'), (args) => {
        const [plain, obj] = args.reduce((a, c) => ((Array.isArray(c) ? a[1].push(c) : a[0].push(c)), a), [[], []]);
        if (obj.length)
            return [plain, objectOp(obj)];
        return [plain, undefined];
    });
    const letter = map(seq(str('let'), rws, name$2(localpath, { name: 'reference', primary: true }), ws$2, str('='), ws$2, value$1), ([, , k, , , , v]) => ({ op: 'let', args: [{ v: k }, v] }), { primary: true, name: 'let' });
    const setter = map(seq(str('set'), rws, name$2(keypath, { name: 'reference', primary: true }), ws$2, str('='), ws$2, value$1), ([, , k, , , , v]) => ({ op: 'set', args: [{ v: k }, v] }), { primary: true, name: 'set' });
    values$1.parser = alt('expression', array, object, literal, typelit, string, application, unop, call_op$1, letter, setter, ref, block);
    const parseBlock = parser$2(map(rep1sep(value$1, read1(space$3 + ';'), 'allow'), args => args.length === 1 ? args[0] : { op: 'block', args, opts: { v: { implicit: 1 } } }, 'expression-sequence'), { trim: true });
    const parseExpr = parser$2(value$1, { trim: true });
    parseBlock.namespace = 'default';
    const parse$4 = parseBlock;
    function schema() {
        const type = {};
        const conditions = opt(seq(ws$2, rep1sep(map(seq(name$2(str('?'), { name: 'condition', primary: true }), ws$2, application), ([, , a]) => a), rws, 'disallow')));
        const value = map(seq(str('string[]', 'number[]', 'boolean[]', 'date[]', 'any', 'string', 'number', 'boolean', 'date'), not(read1To(endRef))), ([s]) => ({ type: s }), { name: 'type', primary: true });
        const typedef = comment('c', map(seq(str('type'), ws$2, name$2(ident, { name: 'type', primary: true }), ws$2, str('='), ws$2, type), ([, , name, , , , type]) => ({ name, type })));
        const typedefs = map(rep1sep(typedef, read1(' \t\n;'), 'allow'), defs => defs.reduce((a, c) => (c.type.desc = c.c, a[c.name] = c.type, a), {}));
        const ref = map(seq(ident, opt(str('[]'))), ([ref, arr]) => ({ type: arr ? 'array' : 'any', ref }), { name: 'type', primary: true });
        const key = map(seq(name$2(ident, { name: 'key', primary: true }), opt(str('?')), ws$2, str(':'), ws$2, type), ([name, opt, , , , type]) => {
            const res = type;
            res.name = name;
            if (!opt)
                res.required = true;
            return res;
        });
        const literal = alt({ name: 'literal', primary: true }, map(alt(JString, JNum), v => {
            return { type: 'literal', literal: v };
        }), map(str('true', 'false', 'null', 'undefined'), v => {
            return { type: 'literal', literal: v === 'true' ? true : v === 'false' ? false : v === 'null' ? null : undefined };
        }));
        const rest = map(seq(str('...'), ws$2, str(':'), ws$2, type), ([, , , , type]) => {
            return Object.assign({ name: '...' }, type);
        });
        const object = map(seq(str('{'), ws$2, repsep(comment('desc', alt(key, rest)), read1(' \t\n,;'), 'allow'), ws$2, str('}'), opt(str('[]'))), ([, , keys, , , arr], fail) => {
            const rests = keys.filter(k => k.name === '...');
            if (rests.length > 1)
                fail('only one object rest can be specified');
            else {
                const rest = rests[0];
                keys = keys.filter(k => k.name !== '...');
                const type = { type: arr ? 'object[]' : 'object' };
                if (keys.length)
                    type.fields = keys;
                if (rest) {
                    delete rest.name;
                    type.rest = rest;
                }
                return type;
            }
        });
        const tuple = map(seq(str('['), ws$2, repsep(type, read1(' \t\r\n,'), 'allow'), ws$2, str(']'), opt(str('[]'))), ([, , types, , , arr]) => {
            return { type: arr ? 'tuple[]' : 'tuple', types };
        });
        const maybe_union = map(rep1sep(seq(alt(value, object, tuple, literal, ref), conditions), seq(ws$2, str('|'), ws$2), 'disallow'), list => {
            const types = list.map(([t, c]) => {
                if (c && c[1] && c[1].length)
                    t.checks = c[1];
                return t;
            });
            if (types.length === 1)
                return types[0];
            else
                return { type: 'union', types: types };
        });
        const union_array = alt(map(seq(str('Array<'), ws$2, maybe_union, ws$2, str('>')), ([, , union], fail) => {
            if (union.type === 'union')
                return { type: 'union[]', types: union.types };
            else if (union.type === 'literal')
                fail('literal types cannot be array types');
            else if (union.type === 'array' || ~union.type.indexOf('[]'))
                fail('array types cannot be array types');
            else if (union.type === 'any')
                fail('any cannot be an array type');
            else {
                union.type += '[]';
                return union;
            }
        }), map(seq(str('('), ws$2, maybe_union, ws$2, str(')')), ([, , union]) => union), maybe_union);
        type.parser = map(seq(union_array, conditions), ([type, checks]) => {
            if (checks && checks[1] && checks[1].length)
                type.checks = checks[1];
            return type;
        });
        const root = map(seq(opt(typedefs), ws$2, type), ([defs, , type]) => {
            if (defs)
                type.defs = defs;
            return type;
        });
        return root;
    }

    const endTxt$1 = '\\{';
    const txtEsc = alt(map(str('\\{{'), () => '{{'), map(seq(str('\\'), chars(1)), ([, c]) => c));
    const text$1 = map(rep1(alt(read1To(endTxt$1, true), txtEsc, andNot(str('{'), str('{')))), txts => ({ v: txts.join('') }), 'text');
    function tag_value(names) {
        return map(seq(str('{{'), ws$2, str(...names), rws, value$1, ws$2, str('}}')), arr => [arr[2], arr[4]], 'tag');
    }
    function case_value(names) {
        return map(seq(str('{{'), ws$2, str(...names), rws, value$1, rws, str('when'), rws, value$1, str('}}')), arr => [arr[2], arr[4], arr[8]], 'tag');
    }
    const tag_end = name$2(check$1(seq(str('{{/'), readTo('}'), str('}}'))), 'tag end');
    const content$1 = {};
    function branch(names, value) {
        if (value)
            return map(tag_value(names), ([name, value]) => ({ name, value }));
        else
            return map(seq(str('{{'), ws$2, str(...names), ws$2, str('}}')), ([, , name]) => ({ name }), 'tag');
    }
    function min_one(values) {
        return map(values, v => v.length < 1 ? [{ v: '' }] : v);
    }
    const else_tag = branch(['else']);
    const branch_tag = branch(['else if', 'elseif', 'elsif', 'elif'], true);
    const each_op = map(seq(tag_value(['each']), min_one(rep(alt(branch_tag, else_tag, content$1))), tag_end), ([tag, content]) => ({ op: 'each', args: [tag[1]].concat(apply_first(cond_branches(content))) }), { primary: true, name: 'each-block' });
    const if_op = map(seq(tag_value(['if']), min_one(rep(alt(branch_tag, else_tag, content$1))), tag_end), ([tag, content]) => ({ op: 'if', args: [tag[1]].concat(cond_branches(content)) }), { primary: true, name: 'if-block' });
    const with_op = map(seq(tag_value(['with']), min_one(rep(alt(else_tag, content$1))), tag_end), ([tag, content]) => ({ op: 'with', args: [tag[1]].concat(apply_first(cond_branches(content))) }), { primary: true, name: 'with-block' });
    const unless_op = map(seq(tag_value(['unless']), min_one(rep(content$1)), tag_end), ([tag, content]) => ({ op: 'unless', args: [tag[1]].concat(concat(content)) }), { primary: true, name: 'unless-block' });
    const case_op = map(seq(case_value(['case']), min_one(rep(alt(branch(['when'], true), else_tag, content$1))), tag_end), ([tag, content]) => {
        const op = { op: 'case', args: tag.slice(1).concat(cond_branches(content)) };
        for (let i = 1; i < op.args.length; i += 2) {
            const arg = op.args[i];
            if (typeof arg === 'object' && 'op' in arg)
                replaceCase(arg);
        }
        return op;
    }, { primary: true, name: 'case-block' });
    const interpolator = map(seq(str('{{'), ws$2, value$1, ws$2, str('}}')), ([, , value]) => ({ op: 'string', args: [value] }), { primary: true, name: 'interpolator' });
    content$1.parser = alt({ primary: true, name: 'content' }, text$1, each_op, if_op, with_op, case_op, unless_op, interpolator);
    function apply_first(content) {
        if (content.length)
            content[0] = { a: content[0] };
        return content;
    }
    function cond_branches(content) {
        const res = [];
        let args = [];
        let hasTag = false;
        for (let i = 0; i < content.length; i++) {
            const c = content[i];
            if ('name' in c) {
                hasTag = true;
                if (args.length)
                    res.push(concat(args));
                else
                    res.push({ v: '' });
                if (c.value)
                    res.push(c.value);
                args = [];
            }
            else
                args.push(c);
        }
        if (args.length)
            res.push(concat(args));
        else if (hasTag)
            res.push({ v: '' });
        if (res.length % 2)
            res.push({ v: '' });
        return res;
    }
    function concat(values) {
        if (values.length === 1)
            return values[0];
        return { op: '+', args: values };
    }
    const _parse$1 = parser$2(alt(map(rep1(content$1), args => concat(args)), map(ws$2, () => ({ v: '' }))), { trim: true });
    _parse$1.namespace = 'template';
    const parse$3 = _parse$1;

    function toDataSet(value) {
        if (Array.isArray(value))
            return { value };
        if (value && typeof value === 'object') {
            for (const k in value)
                if (k !== 'schema' && k !== 'value')
                    return { value };
            return value;
        }
        return { value };
    }
    // eval
    function getKeypath$1(ref) {
        if (typeof ref.r === 'object')
            return ref.r;
        const path = parsePath(ref.r);
        if ('k' in path)
            return path;
        else
            return { k: [] };
    }
    function safeGet(root, path) {
        if (!path)
            return root.value;
        const p = typeof path === 'string' ? parsePath(path) : path;
        if ('error' in p)
            return;
        else if ('k' in p) {
            let parts = p.k;
            const prefix = p.p;
            let idx = 0;
            let ctx = root;
            let o = root.value;
            for (let i = 0; i < p.u; i++)
                ctx && (ctx = ctx.parent);
            o = ctx ? ctx.value : undefined;
            if (prefix) {
                if (prefix === '!')
                    o = root.root.parameters;
                else if (prefix === '~')
                    o = root.root.value;
                else if (prefix === '*') {
                    o = root.root.sources[parts[idx++]];
                    if (o && idx < parts.length + 1 && parts[idx] !== 'value')
                        o = o.value;
                }
                else if (prefix === '@') {
                    const which = parts[idx++];
                    if (which === 'locals' || which === 'specials') {
                        const key = which === 'locals' ? which : 'special';
                        while (ctx) {
                            if (ctx[key])
                                break;
                            ctx = ctx.parent;
                        }
                        if (ctx)
                            o = ctx[key];
                    }
                    else if (which === 'local' || which === 'special') {
                        const key = which === 'local' ? 'locals' : which;
                        o = ctx[key] || (ctx[key] = {});
                    }
                    else if (which === 'parameters' || which === 'sources') {
                        o = root.root[which];
                    }
                    else if (which !== 'value') {
                        while (ctx && (!ctx.special || !(which in ctx.special)))
                            ctx = ctx.parent;
                        o = ctx && ctx.special[which];
                        if (o && which === 'source' && parts[idx] !== undefined && parts[idx] !== 'value' && o.value)
                            o = o.value;
                        if (!o && which === 'date')
                            o = root.root.special.date = new Date();
                    }
                }
            }
            else {
                const first = parts[0];
                if (first === '_') {
                    if (ctx.special && ctx.special.pipe)
                        o = ctx.special.pipe;
                    idx++;
                }
                else if (typeof first === 'string') {
                    let lctx = ctx;
                    while (lctx && (!lctx.locals || !(first in lctx.locals)))
                        lctx = lctx.parent;
                    if (lctx && first in lctx.locals) {
                        o = lctx.locals[first];
                        idx++;
                    }
                }
            }
            for (let i = idx; i < parts.length; i++) {
                const part = parts[i];
                const v = typeof part !== 'object' ? part : evalValue(root, part);
                if (Array.isArray(o) && typeof v === 'number' && v < 0)
                    o = o[o.length + v];
                else
                    o = o && o[v];
                if (o === null || o === undefined)
                    return;
            }
            return o;
        }
    }
    function safeSet(root, path, value, islet) {
        if (!path)
            return;
        const p = typeof path === 'string' ? (islet ? parseLetPath(path) : parsePath(path)) : path;
        if ('error' in p)
            return;
        else if ('k' in p) {
            let parts = p.k;
            const prefix = p.p;
            let ctx = root;
            let o = root.value;
            for (let i = 0; i < p.u; i++)
                ctx && (ctx = ctx.parent);
            o = ctx ? ctx.value : undefined;
            const keys = parts.map(p => typeof p !== 'object' ? p : evalValue(root, p));
            if (islet) {
                o = root.locals || (root.locals = {});
            }
            else if (prefix) {
                if (prefix === '~')
                    o = root.root.value;
                else
                    return;
            }
            if (!islet) {
                const first = keys[0];
                while (ctx) {
                    if (ctx.locals && first in ctx.locals)
                        break;
                    ctx = ctx.parent;
                }
                if (ctx)
                    o = ctx.locals;
            }
            const last = keys.length - 1;
            for (let i = 0; i < last; i++) {
                if (typeof o !== 'object' && typeof o !== 'function' || !o)
                    return;
                const key = keys[i];
                const next = keys[i + 1];
                if (!(key in o) || o[key] == null)
                    o[key] = typeof next === 'number' ? [] : {};
                o = o[key];
            }
            if (o) {
                const cur = o[keys[last]];
                o[keys[last]] = value;
                return cur;
            }
        }
    }
    function evaluate(root, value) {
        let r;
        let e;
        if (isValueOrExpr(root)) {
            r = new Root();
            e = root;
        }
        else if (isContext(root)) {
            r = root;
            !Array.isArray(value) && (e = value);
        }
        else if (root && typeof root === 'object' && 'context' in root && isContext(root.context)) {
            r = root.context;
            !Array.isArray(value) && (e = value);
        }
        else if (isValueOrExpr(value)) {
            r = new Root(root);
            e = value;
        }
        else {
            r = new Root();
            e = root;
        }
        return evalParse(r, e);
    }
    function template$2(root, template) {
        let r;
        let t;
        if (typeof root === 'string') {
            r = new Root();
            t = root;
        }
        else if (isContext(root)) {
            r = root;
            t = template || '';
        }
        else if (root && typeof root === 'object' && 'context' in root && isContext(root.context)) {
            r = root.context;
            t = template || '';
        }
        else if (root && typeof root !== 'string') {
            r = new Root(root);
            t = template || '';
        }
        else {
            r = new Root();
            t = root;
        }
        r = extend$2(r, { parser: parse$3 });
        return evalParse(r, t);
    }
    /**
     * Evaluate an applicative with the given locals, naming them if the applicative declares named arguments.
     * If swap is not true, then a new context extension will be used. Otherwise, the context locals will be
     * swapped for the evaluation and replaced afterwards. Swap should only be used for applications that are
     * passing the context value as the first local.
     */
    function evalApply(ctx, value, locals, special) {
        if (isApplication(value)) {
            const c = extend$2(ctx, { value: locals[0], special, fork: !ctx.locals });
            let res;
            if ('n' in value) {
                const map = value.n.reduce((a, c, i) => (a[c] = locals[i], a), {});
                c.locals = map;
            }
            res = evalValue(c, value.a);
            return res;
        }
        else {
            const v = evalParse(extend$2(ctx, { value: locals[0], special, fork: !ctx.locals }), value);
            if (isApplication(v))
                return evalApply(ctx, v, locals, special);
            else
                return v;
        }
    }
    function evalParse(ctx, expr) {
        if (typeof expr === 'string') {
            const p = ctx.parser || parse$4;
            const ns = p.namespace || 'unknown';
            const cache = ctx.root.exprs[ns] || (ctx.root.exprs[ns] = {});
            expr = cache[expr] || (cache[expr] = p(expr));
        }
        if (typeof expr !== 'object')
            expr = { v: expr };
        return evalValue(ctx, expr);
    }
    function evalValue(ctx, expr) {
        if (!expr)
            return expr;
        if ('r' in expr)
            return safeGet(ctx, expr.r);
        else if ('v' in expr)
            return expr.v;
        else if ('op' in expr)
            return applyOperator(ctx, expr);
        else if (isApplication(expr))
            return expr;
        else if (isDateRel(expr) || isTimespan(expr))
            return expr;
    }
    const opMap = {};
    function registerOperator(...ops) {
        for (const op of ops) {
            for (const name of op.names)
                opMap[name] = op;
        }
    }
    function getOperator(name) {
        return opMap[name];
    }
    const _defaultGetValue = (c, b, v) => evalApply(c, b, [v]);
    function sort$1(context, arr, sorts, getValue) {
        let sortArr;
        if (Array.isArray(sorts)) {
            sortArr = sorts;
        }
        else if (isApplication(sorts)) {
            sortArr = [sorts];
        }
        else if (typeof sorts === 'object' && sorts && 'by' in sorts) {
            sortArr = [sorts];
        }
        else {
            const s = evalParse(context, sorts);
            if (Array.isArray(s))
                sortArr = s;
            else if (typeof s === 'string')
                sortArr = [{ v: s }];
            else if (typeof sorts === 'string')
                sortArr = [sorts];
        }
        if (sortArr) {
            let el;
            for (let i = 0; i < sortArr.length; i++) {
                el = sortArr[i];
                const by = isLiteral(el) ? el.v : el;
                if (typeof by === 'string') {
                    if (by[0] === '-')
                        sortArr[i] = { by: by.slice(1), desc: true };
                    else
                        sortArr[i] = { by: by[0] === '+' ? by.slice(1) : by, desc: false };
                }
            }
        }
        getValue = getValue || _defaultGetValue;
        if (sortArr && sortArr.length) {
            const dirs = sortArr.map(s => {
                if (typeof s === 'object') {
                    if ('by' in s) {
                        if ('desc' in s) {
                            if (typeof s.desc === 'boolean')
                                return s.desc;
                            return evalParse(context, s.desc);
                        }
                        else if ('dir' in s) {
                            const lower = typeof s.dir === 'string' ? s.dir.toLowerCase() : s.dir;
                            const dir = lower === 'asc' || lower === 'desc' ? lower : evalParse(context, s.dir);
                            const val = typeof dir === 'string' ? dir.toLowerCase() : dir;
                            if (val === 'desc')
                                return true;
                        }
                    }
                }
                // default to asc
                return false;
            });
            arr.sort((a, b) => {
                for (let i = 0; i < sortArr.length; i++) {
                    const s = sortArr[i];
                    const desc = dirs[i];
                    const by = typeof s === 'string' ? s : s && s.by ? s.by : s;
                    const l = getValue(context, by, a);
                    const r = getValue(context, by, b);
                    const cmp = l == null && r != null ? -1
                        : l != null && r == null ? 1
                            : (l < r) === (r < l) ? 0
                                : l < r ? -1
                                    : l > r ? 1
                                        : 0;
                    if (cmp)
                        return (desc ? -1 : 1) * cmp;
                }
                return 0;
            });
        }
        return arr;
    }
    function filter(ds, filter, sorts, groups, context) {
        const _ds = Array.isArray(ds) ? { value: ds } : ds;
        if (!_ds || !Array.isArray(_ds.value))
            return _ds;
        let _context;
        if (!context)
            _context = new Root(_ds.value, { special: { source: _ds } });
        else if (isContext(context))
            _context = extend$2(context, { special: { source: _ds.value } });
        else
            _context = new Root(context);
        const values = filter ? [] : _ds.value.slice();
        if (filter) {
            let flt = typeof filter === 'string' ? parse$4(filter) : filter;
            if ('m' in flt)
                flt = { v: true };
            _ds.value.forEach((row, index) => {
                if (!!evalApply(extend$2(_context, { value: row, special: { value: row, index } }), flt, [row, index]))
                    values.push(row);
            });
        }
        if (sorts)
            sort$1(_context, values, sorts);
        if (groups && !Array.isArray(groups))
            groups = [groups];
        if (Array.isArray(groups) && groups.length) {
            return { value: { schema: _ds.schema, grouped: groups.length, level: 0, value: group(values, groups, _context, 1), all: values } };
        }
        if (Array.isArray(ds))
            return values;
        else
            return { schema: _ds.schema, value: values };
    }
    function group(arr, groups, ctx, level = 0) {
        const cache = {};
        const res = [];
        const order = [];
        for (const e of arr) {
            const g = isApplication(groups[0]) ? `${evalApply(ctx, groups[0], [e])}` : `${evalParse(extend$2(ctx, { value: e }), groups[0])}`;
            if (!cache[g]) {
                order.push(g);
                cache[g] = [];
            }
            cache[g].push(e);
        }
        for (const k of order) {
            res.push({ group: k, grouped: groups.length - 1, value: groups.length > 1 ? group(cache[k], groups.slice(1), ctx, level + 1) : cache[k], all: cache[k], level });
        }
        return res;
    }
    function hasPipeRef(ref) {
        const path = getKeypath$1(ref);
        return path.k[0] === '_' || path.p === '@' && path.k[0] === 'pipe';
    }
    function applyOperator(root, operation) {
        const op = opMap[operation.op];
        // if the operator doesn't exist, try a local, pipe, or skip
        if (!op) {
            const local = safeGet(root, operation.op) || safeGet(root.root, operation.op);
            if (isApplication(local)) {
                return evalApply(root, local, (operation.args || []).map(a => evalParse(root, a)));
            }
            else if (operation.op === 'pipe') { // handle the special built-in pipe operator
                if (!operation.args || !operation.args.length)
                    return true;
                let v = evalParse(root, operation.args[0]);
                for (let i = 1; i < operation.args.length; i++) {
                    let a = operation.args[i];
                    if (isOperation(a) && (!a.args || !a.args.find(a => isReference(a) && hasPipeRef(a))))
                        a = Object.assign({}, a, { args: [{ r: { k: ['pipe'], p: '@' } }].concat(a.args || []) });
                    if (isApplication(a))
                        v = evalApply(root, a, [v]);
                    else
                        v = evalParse(extend$2(root, { special: { pipe: v } }), a);
                }
                return v;
            }
            return true;
        }
        let args;
        if (op.type === 'checked') {
            args = [];
            const flts = operation.args || [];
            const ctx = op.extend ? extend$2(root, {}) : root;
            const opts = operation.opts ? evalParse(ctx, operation.opts) : undefined;
            for (let i = 0; i < flts.length; i++) {
                const a = flts[i];
                const arg = evalParse(ctx, a);
                const res = op.checkArg(operation.op, i, flts.length - 1, arg, opts, ctx, a);
                if (res === 'continue')
                    args.push(arg);
                else if ('skip' in res) {
                    i += res.skip;
                    if ('value' in res)
                        args.push(res.value);
                }
                else if ('result' in res)
                    return res.result;
            }
            return op.apply(operation.op, args, opts, ctx);
        }
        else if (op.type === 'value') {
            args = (operation.args || []).map(a => evalParse(root, a));
            return op.apply(operation.op, args, operation.opts ? evalParse(root, operation.opts) : undefined, root);
        }
        else {
            let arr;
            const ctx = op.extend ? extend$2(root, {}) : root;
            const args = (operation.args || []).slice();
            const opts = operation.opts ? evalParse(ctx, operation.opts) : undefined;
            let arg;
            if (!op.value) {
                arg = evalParse(ctx, args[0]);
                if (Array.isArray(arg)) {
                    args.shift();
                    arr = arg;
                }
                else if (typeof arg === 'object' && 'value' in arg && Array.isArray(arg.value)) {
                    args.shift();
                    arr = arg.value;
                }
                if (!arr) {
                    const src = evalValue(ctx, { r: '@source' });
                    if (Array.isArray(src))
                        arr = src;
                    else if (typeof src === 'object' && 'value' in src && Array.isArray(src.value))
                        arr = src.value;
                    else
                        arr = [];
                }
            }
            return op.apply(operation.op, Array.isArray(arr) ? arr : [], args, opts, ctx);
        }
    }
    function isKeypath(v) {
        return typeof v === 'string' || (typeof v === 'object' && Array.isArray(v.k));
    }
    function isLiteral(v) {
        return typeof v === 'object' && 'v' in v;
    }
    function isReference(v) {
        return typeof v === 'object' && 'r' in v;
    }
    function isOperation(v) {
        return typeof v === 'object' && typeof v.op === 'string';
    }
    function isApplication(v) {
        if (typeof v !== 'object' || !('a' in v) || typeof v.a !== 'object')
            return false;
        const len = Object.keys(v).length;
        return len === 1 || len === 2 && 'n' in v;
    }
    function isValueOrExpr(o) {
        return typeof o === 'string' || isValue(o);
    }
    function isValue(o) {
        return typeof o === 'object' && o && (('r' in o && typeof o.r === 'string') ||
            ('op' in o && typeof o.op === 'string') ||
            ('v' in o) ||
            (isApplication(o)));
    }
    function isContext(v) {
        return typeof v === 'object' && typeof v.path === 'string' && typeof v.root == 'object' && 'value' in v && (typeof v.parent === 'object' || v.root === v);
    }
    class Root {
        constructor(root = {}, opts) {
            this.root = this;
            this.parameters = {};
            this.sources = {};
            this.special = {};
            this.exprs = {};
            this.path = '';
            this.value = root;
            if (opts) {
                Object.assign(this.parameters, opts.parameters);
                Object.assign(this.special, opts.special);
                if (opts.parser)
                    this.parser = opts.parser;
            }
        }
    }
    function extend$2(context, opts) {
        return {
            parent: opts.fork ? (context.parent || context.root) : context,
            root: context.root,
            path: opts.path || '',
            value: 'value' in opts ? opts.value : context.value,
            special: opts.fork ? Object.assign({}, context.special, { pipe: undefined }, opts.special) : (opts.special || {}),
            parser: opts.parser,
            locals: opts.locals,
        };
    }
    const formats$1 = {};
    const virtualFormats = {};
    function registerFormat(name, format, defaults = {}) {
        if (Array.isArray(name))
            name.forEach(n => formats$1[n] = { apply: format, defaults });
        else
            formats$1[name] = { apply: format, defaults };
    }
    function dateRelToRange(rel) {
        if (rel instanceof Date)
            return [rel, rel];
        let from = new Date();
        let to = 'd' in rel && rel.d ? new Date() : undefined;
        from.setUTCFullYear(from.getFullYear(), from.getMonth(), from.getDate());
        from.setUTCHours(0, 0, 0, 0);
        let tz = 'z' in rel && rel.z != null ? rel.z : null;
        if (rel.f === 'n') { // DateRelSpan (MS or Full)
            from = typeof rel.o === 'number' ? new Date(+new Date() + rel.o) : dateAndTimespan(new Date(), { d: rel.o }, 'd' in rel ? rel.d : 1);
            to = from;
            tz = undefined;
        }
        else if (rel.f === 'd') { // DateRelRange - day
            from.setUTCDate(from.getUTCDate() + rel.o);
            if (!to)
                to = new Date(from);
            if ('t' in rel) { // DateRelTimeRange
                const t = rel.t;
                from.setUTCHours(t[0], t[1] || 0, t[2] || 0, t[3] || 0);
                to.setUTCHours(t[0], t[1] == null ? 59 : t[1], t[2] == null ? 59 : t[2], t[3] == null ? 999 : t[3]);
                if (t[4] != null)
                    tz = t[4];
            }
        }
        else if (rel.f === 'w') { // DateRelRange - week
            from.setUTCDate(from.getUTCDate() - (from.getUTCDay() + (rel.o === -1 ? 7 : rel.o === 1 ? -7 : 0)));
            if (!to) {
                to = new Date(from);
                to.setDate(from.getUTCDate() + 6);
            }
            if ('z' in rel && rel.z != null)
                tz = rel.z;
        }
        else if (rel.f === 'm') { // DateRelRange - month
            from.setUTCDate(1);
            from.setUTCMonth(from.getUTCMonth() + rel.o);
            if (!to) {
                to = new Date(from);
                to.setUTCMonth(from.getUTCMonth() + 1);
                to.setUTCDate(0);
            }
        }
        else if (rel.f === 'y') { // DateRelRange - year
            from.setUTCDate(1);
            from.setUTCMonth(0);
            from.setUTCDate(1);
            if (!to) {
                to = new Date(from);
                to.setUTCFullYear(from.getUTCFullYear() + 1);
                to.setUTCDate(0);
            }
        }
        else if (Array.isArray(rel.f)) { // DateExactRange
            const v = rel.f.slice();
            from = new Date(Date.UTC(v[0], v[1] || 0, v[2] || 1, v[3] || 0, v[4] || 0, v[5] || 0, v[6] || 0));
            for (let i = 1; i < 7; i++) {
                if (v[i] == null) {
                    v[i - 1]++;
                    break;
                }
            }
            if (v[6] != null)
                v[6]++;
            to = new Date(Date.UTC(v[0], v[1] || 0, v[2] || 1, v[3] || 0, v[4] || 0, v[5] || 0, v[6] || 0));
            to.setUTCMilliseconds(to.getUTCMilliseconds() - 1);
            if (v[7] != null)
                tz = v[7];
        }
        if (rel.f === 'd' || rel.f === 'w' || rel.f === 'm' || rel.f === 'y')
            to.setUTCHours(23, 59, 59, 999);
        if (tz !== undefined) {
            if (tz != null) {
                from.setUTCMinutes(from.getUTCMinutes() - tz);
                if (from !== to)
                    to.setUTCMinutes(to.getUTCMinutes() - tz);
            }
            else { // shift to local time
                const offset = from.getTimezoneOffset();
                from.setUTCMinutes(from.getUTCMinutes() + offset);
                if (from !== to)
                    to.setUTCMinutes(to.getUTCMinutes() + offset);
            }
        }
        return [from, to];
    }
    function isDateRel(v) {
        return v && typeof v === 'object' && (('f' in v && (Array.isArray(v.f) || 'o' in v)) || v instanceof Date);
    }
    function isDateExactRange(v) {
        return v && typeof v === 'object' && 'f' in v && Array.isArray(v.f);
    }
    function dateRelToDate(rel) {
        const range = dateRelToRange(rel);
        if ('e' in rel && rel.e != null)
            return range[1];
        else
            return range[0];
    }
    function dateRelToExactRange(rel) {
        if (!rel)
            return;
        if (isDateExactRange(rel))
            return rel;
        const dt = dateRelToDate(rel);
        const offset = dt.getTimezoneOffset();
        const z = 'z' in rel && rel.z != null ? rel.z : 'f' in rel && rel.f === 'd' && 't' in rel && rel.t[4] != null ? rel.t[4] : null;
        if (rel instanceof Date && z != null)
            dt.setMinutes(dt.getMinutes() - (offset + z));
        return {
            f: [dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), dt.getSeconds(), dt.getMilliseconds(), z != null ? z : -offset],
        };
    }
    function isTimespan(v) {
        return typeof v === 'number' || (typeof v === 'object' && Array.isArray(v.d)) || isTimespanMS(v);
    }
    function addTimespan(l, r) {
        if (typeof l === 'number' && typeof r === 'number')
            return l + r;
        else {
            const res = { d: [] };
            if (typeof l === 'number')
                res.d[6] = l;
            else if (isTimespanMS(l))
                res.d[6] = l.ms;
            else
                for (let i = 0; i < 7; i++)
                    if (l.d[i])
                        res.d[i] = l.d[i];
            if (typeof r === 'number')
                res.d[6] = (res.d[6] || 0) + r;
            else if (isTimespanMS(r))
                res.d[6] = (res.d[6] || 0) + r.ms;
            else
                for (let i = 0; i < 7; i++)
                    if (r.d[i])
                        res.d[i] = (res.d[i] || 0) + r.d[i];
            return res;
        }
    }
    function datesDiff(l, r) {
        if (isNaN(+l) || isNaN(+r))
            return { d: [] };
        if (r < l) {
            const s = r;
            r = l;
            l = s;
        }
        const a = new Date(l);
        const b = r;
        const res = { d: [0, 0, 0, 0, 0, 0, 0], s: +a };
        let num = b.getFullYear() - a.getFullYear() - 1;
        let tmp1, tmp2;
        if (num > 0) {
            res.d[0] += num;
            a.setFullYear(b.getFullYear() - 1);
        }
        a.setFullYear(a.getFullYear() + 1);
        if (a > b)
            a.setFullYear(a.getFullYear() - 1);
        else
            res.d[0]++;
        // watch out for leap year
        if (l.getMonth() === 1 && l.getDate() === 29 && a.getMonth() !== 1) {
            a.setDate(29);
            a.setMonth(1);
        }
        // jumping months can make days get weird
        while (true) {
            num = a.getDate();
            tmp1 = a.getMonth();
            tmp2 = a.getFullYear();
            a.setDate(num + 1);
            if (a.getMonth() !== tmp1) {
                a.setDate(1);
                a.setMonth(tmp1 + 2);
                a.setDate(0);
            }
            else {
                a.setDate(num);
                a.setMonth(tmp1 + 1);
                if (tmp1 === 11 ? a.getMonth() !== 0 : a.getMonth() !== tmp1 + 1) {
                    a.setDate(1);
                    a.setMonth(tmp1 + 2);
                    a.setDate(0);
                }
            }
            if (a > b) {
                // make sure we stay in the correct year
                a.setFullYear(tmp2);
                a.setDate(1);
                a.setMonth(tmp1);
                a.setDate(num);
                break;
            }
            else
                res.d[1]++;
        }
        while (true) {
            a.setDate(a.getDate() + 1);
            if (a > b) {
                a.setDate(a.getDate() - 1);
                break;
            }
            else
                res.d[2]++;
        }
        while (true) {
            a.setHours(a.getHours() + 1);
            if (a > b) {
                a.setHours(a.getHours() - 1);
                break;
            }
            else
                res.d[3]++;
        }
        while (true) {
            a.setMinutes(a.getMinutes() + 1);
            if (a > b) {
                a.setMinutes(a.getMinutes() - 1);
                break;
            }
            else
                res.d[4]++;
        }
        while (true) {
            a.setSeconds(a.getSeconds() + 1);
            if (a > b) {
                a.setSeconds(a.getSeconds() - 1);
                break;
            }
            else
                res.d[5]++;
        }
        if (a.getMilliseconds() <= b.getMilliseconds())
            res.d[6] = b.getMilliseconds() - a.getMilliseconds();
        else
            res.d[6] = (1000 - a.getMilliseconds()) + b.getMilliseconds();
        return res;
    }
    function dateAndTimespan(l, r, m) {
        if (typeof r === 'number')
            return new Date(+l + r * m);
        else if (isTimespanMS(r))
            return new Date(+l + r.ms * m);
        else {
            let d = new Date(l);
            if (r.d[0])
                d.setFullYear(d.getFullYear() + r.d[0] * m);
            if (r.d[1]) {
                const dd = d.getDate();
                d.setDate(1);
                d.setMonth(d.getMonth() + r.d[1] * m);
                const mm = d.getMonth();
                d.setDate(dd);
                if (mm !== d.getMonth())
                    d.setDate(0);
            }
            if (r.d[2])
                d.setDate(d.getDate() + r.d[2] * m);
            if (r.d[3])
                d.setHours(d.getHours() + r.d[3] * m);
            if (r.d[4])
                d.setMinutes(d.getMinutes() + r.d[4] * m);
            if (r.d[5])
                d.setSeconds(d.getSeconds() + r.d[5] * m);
            if (r.d[6])
                d.setMilliseconds(d.getMilliseconds() + r.d[6] * m);
            return d;
        }
    }

    function addStyle$1(context, id, style) {
        if (!context.styles[id])
            context.styles[id] = style;
    }
    function error(context, placement, message = 'Widget overflow error') {
        addStyle$1(context, 'error', `.error { position: absolute; box-sizing: border-box; color: red; border: 1px dotted; width: 100%; height: 2rem; padding: 0.5rem; }`);
        return { output: `<div class="error" style="top: ${placement.y}rem;">${message}</div>`, height: 2 };
    }

    function isComputed(v) {
        return v && typeof v === 'object' && isValueOrExpr(v.x);
    }
    function maybeComputed(v, context) {
        if (!isComputed(v))
            return v;
        else if (v.x)
            return evaluate(context, v.x);
    }
    function extend$1(context, opts) {
        return { report: context.report, context: extend$2(context.context, opts), styles: context.styles, styleMap: context.styleMap };
    }
    const htmlChars = /[><&]/g;
    const htmlReplace = { '<': '&lt;', '>': '&gt;', '&': '&amp;' };
    function escapeHTML(html) {
        return ('' + html).replace(htmlChars, m => htmlReplace[m] || '');
    }
    const renderers = {};
    function registerRenderer(type, renderer, options) {
        renderers[type] = typeof renderer === 'function' ? { render: renderer } : renderer;
        if (options)
            Object.assign(renderers[type], options);
    }
    /** Decent guesstimates for char width at 16px/em */
    const avgs = {
        sans: 7.4,
        serif: 6.7,
        mono: 7.85,
        narrow: 5.9,
    };
    /** Text height measurement function for the given text, font, available width in rem, and line height in rem.
     * The text is assumed to be rendered as white-space: pre-wrap.
     */
    function measureEstimate(text, width, context, font) {
        const family = (font && maybeComputed(font.family, context)) || 'sans';
        const size = (font && maybeComputed(font.size, context)) || 0.83;
        const line = (font && maybeComputed(font.line, context)) || size;
        const brw = font && 'break-word' in font ? font['break-word'] : true;
        const avg = (((font && maybeComputed(font.metric, context)) || ((family === 'mono' || /fixed|mono/i.test(family) ? avgs.mono :
            family === 'narrow' || /narrow|condensed/i.test(family) ? avgs.narrow :
                family === 'sans' || /sans|arial|helvetica/i.test(family) ? avgs.sans :
                    avgs.serif))) * size) / 16;
        const lines = text.split(/\r?\n/g);
        return lines.reduce((a, c) => {
            const [word, lines] = c.split(/\s|-/g).reduce((a, c) => {
                const wlen = (c.length + 1) * avg;
                if (a[0] + wlen > width) {
                    if (a[0] === 0 || wlen > width) {
                        if (brw) {
                            a[0] = (wlen - (width - a[0])) % width;
                            if (wlen > width)
                                a[1] += Math.floor(wlen / width);
                        }
                        a[1]++;
                    }
                    else {
                        a[0] = wlen;
                        a[1]++;
                    }
                }
                else {
                    a[0] += wlen;
                }
                return a;
            }, [0, 0]);
            return a + ((lines + (word > 0 ? 1 : 0)) || 1);
        }, 0) * line;
    }
    /** Text height measurement function for the given text, font, available width in rem, and line height in rem.
     * The text is assumed to be rendered as white-space: pre-wrap.
     */
    let measure = measureEstimate;
    /** Render the given widget to string or a continuation using a registered renderer */
    function renderWidget(w, context, placement, state) {
        const renderer = renderers[w.type];
        if (!renderer || (w.hide && evaluate(extend$2(context.context, { special: { widget: w, placement } }), w.hide)))
            return { output: '', height: 0 };
        if (!('height' in w) && renderer.container)
            w.height = 'auto';
        const h = getHeightWithMargin(w, placement, context);
        if (placement.maxY && !isNaN(h) && h > placement.maxY)
            return error(context, placement);
        if (placement.availableY && h > placement.availableY)
            return { output: '', continue: { offset: 0 }, cancel: true };
        let extraHeight = 0;
        if (w.margin) {
            const m = expandMargin(w, context, placement);
            extraHeight += m[0] + m[2];
            if (placement.availableY)
                placement.availableY -= m[0] + m[2];
        }
        if (w.border && !h) {
            const b = expandBorder(w, context, placement);
            extraHeight += b[0] + b[2];
        }
        const r = renderer.render(w, context, placement, state);
        if (typeof r === 'string')
            return { output: r, height: h, width: getWidthWithMargin(w, placement, context) };
        if (placement.maxY && r.height > placement.maxY)
            return error(context, placement);
        if (isNaN(h) && placement.availableY && r.height > placement.availableY)
            return { output: '', continue: { offset: 0 }, height: r.height, cancel: true };
        r.height = r.height || 0;
        r.height += extraHeight;
        return r;
    }
    const layouts = {};
    function registerLayout(name, layout) {
        layouts[name] = layout;
    }
    registerLayout('row', (w, o, m, p, ps, context) => {
        let n;
        let br = isComputed(w.br) ? evaluate(extend$2(context.context, { special: { placement: p, widget: w } }), w.br.x) : w.br;
        let availableX = p.maxX - ps[0][0] - ps[0][2] + ps[ps.length - 1][0];
        if (availableX <= 0) {
            availableX = p.maxX;
            br = true;
        }
        if (br || ps[0][0] + ps[0][2] + getWidthWithMargin(w, { x: p.x, y: p.y, maxX: p.maxX, maxY: p.maxY, availableY: p.availableY, availableX }, context) - ps[ps.length - 1][0] > p.maxX) {
            n = { x: m[3], y: maxYOffset(ps), availableX: p.maxX, maxX: p.maxX };
            n.availableY = p.availableY - (n.y - o);
        }
        else {
            n = { x: ps[0][0] + ps[0][2], y: ps[0][1], availableX, maxX: p.maxX, availableY: p.availableY };
        }
        n.y -= o;
        return n;
    });
    /** Render child widgets handling continuation across pages */
    function renderWidgets(widget, context, placement, state, layout) {
        if (Array.isArray(widget.widgets)) {
            let s = '';
            const offset = (state || { offset: 0 }).offset;
            const ps = [[0, offset, 0, 0]];
            const m = expandMargin(widget, context, placement);
            ps[0][0] += m[3];
            ps[0][1] += m[0];
            if (widget.border) {
                const b = expandBorder(widget, context, placement);
                if (placement.maxX)
                    placement.maxX -= b[1] + b[3];
                if (placement.availableX)
                    placement.availableX -= b[1] + b[3];
                if (placement.maxY)
                    placement.maxY -= b[0] + b[2];
                if (placement.availableY)
                    placement.availableY -= b[0] + b[2];
            }
            for (let i = state && state.last || 0; i < widget.widgets.length; i++) {
                let w = widget.widgets[i];
                if (w.macro)
                    w = expandMacro(w.macro, w, context, placement, state);
                if (w.hide && evaluate(extend$2(context.context, { special: { widget: w, placement } }), w.hide))
                    continue;
                // allow widgets that are taller than max height to be dropped
                let h = placement && getHeightWithMargin(w, placement, context);
                if (h > placement.maxY)
                    h = 1;
                if (placement && placement.availableY && h > placement.availableY) {
                    const offset = maxYOffset(ps);
                    state = state || { offset };
                    state.last = i;
                    return { output: s, continue: state, height: offset };
                }
                else {
                    let lp = Array.isArray(layout) && (layout[i] || [0, 0]);
                    if (!lp || !Array.isArray(lp))
                        lp = [0, 0];
                    if (!lp[0])
                        lp[0] = 0;
                    if (!lp[1])
                        lp[1] = 0;
                    let p = Array.isArray(lp) ? { x: lp[0] < 0 ? lp[0] : lp[0] + m[3], y: lp[1] < 0 ? lp[1] : lp[1] + m[0], maxX: placement.maxX } : (lp || placement);
                    if (Array.isArray(lp))
                        p.availableX = p.maxX;
                    if (!layout || typeof layout === 'string') {
                        const l = layout ? layouts[layout] || layouts.row : layouts.row;
                        p = l(w, offset, m, placement, ps, context);
                        if (h > p.availableY) {
                            const offset = maxYOffset(ps);
                            state = state || { offset };
                            state.last = i;
                            return { output: s, continue: state, height: offset };
                        }
                    }
                    p.maxX = p.maxX || placement.maxX;
                    p.maxY = p.maxY || placement.maxY;
                    if (p.x < 0) {
                        p.offsetX = m[3];
                        p.x = (placement.availableX || 1) + p.x - getWidthWithMargin(w, placement, context) + 1;
                    }
                    if (p.y < 0) {
                        p.offsetY = m[0];
                        p.y = (placement.availableY || 1) + p.y - h + 1;
                    }
                    const { x, y } = p;
                    const r = renderWidget(w, context, p, state && state.child);
                    // skip empty output
                    if (typeof r === 'string' && !r || (!r.cancel && !r.output && !r.continue && !r.height))
                        continue;
                    if (typeof r === 'string') {
                        s += r;
                        ps.unshift([x, y, getWidthWithMargin(w, placement, context), getHeightWithMargin(w, placement, context)]);
                    }
                    else {
                        if (r.cancel)
                            return { output: '', cancel: true };
                        const h = r.height || getHeightWithMargin(w, placement, context) || 0;
                        if (y + h > placement.availableY) {
                            const offset = maxYOffset(ps);
                            state = state || { offset };
                            state.last = i;
                            state.attempt = (+state.attempt || 0) + 1;
                            if (state.attempt > 1)
                                return error(context, placement);
                            return { output: s, continue: state, height: offset };
                        }
                        s += r.output;
                        ps.unshift([x, y, r.width || getWidthWithMargin(w, placement, context), h]);
                        if (r.continue) {
                            state = state || { offset: 0 };
                            state.child = r.continue;
                            state.last = i;
                            state.offset = maxYOffset(ps);
                            return { output: s, continue: state, height: maxYOffset(ps), width: maxXOffset(ps) };
                        }
                    }
                    if (p.availableX === 0)
                        ps[0][2] = p.maxX;
                }
            }
            return { output: s, height: getHeightWithMargin(widget, placement, context) || maxYOffset(ps) - m[0], width: getWidthWithMargin(widget, placement, context) || maxXOffset(ps) - m[3] };
        }
        return { output: '', height: 0 };
    }
    function getWidth(w, placement, context) {
        let width = isComputed(w.width) ? evaluate(extend$2(context.context, { special: { widget: w, placement } }), w.width.x) : w.width;
        const m = w.margin && expandMargin(w, context, placement);
        let pct = false;
        if (width === 'grow')
            width = placement.availableX || placement.maxX;
        else if (!width && width !== 0)
            width = placement.maxX || 51;
        else if (typeof width === 'number')
            ;
        else {
            width = +((width.percent / 100) * (placement.maxX || 51)).toFixed(4);
            pct = true;
        }
        if (typeof width === 'number' && (w.box === 'contain' || (pct || width === placement.availableX) && w.box !== 'expand')) {
            if (m)
                width -= m[1] + m[3];
            else if (w.font && w.font.right)
                width -= w.font.right;
        }
        return width;
    }
    function getWidthWithMargin(w, placement, context) {
        let r = getWidth(w, placement, context);
        if (w.margin) {
            const m = expandMargin(w, context, placement);
            r += m[1] + m[3];
        }
        else if (w.font && w.font.right) {
            r += w.font.right;
        }
        return r;
    }
    function maxFontSize(w) {
        let n = w.height || 1;
        if (w.font && w.font.size > n)
            n = w.font.size;
        if ('text' in w && Array.isArray(w.text)) {
            for (let i = 0; i < w.text.length; i++) {
                const t = w.text[i];
                if (typeof t === 'object' && 'font' in t && t.font && t.font.size > n)
                    n = t.font.size;
            }
        }
        return n;
    }
    function getHeight(w, placement, context, computed, linesize) {
        let r = 1;
        let h = isComputed(w.height) ? evaluate(extend$2(context.context, { special: { widget: w, placement, computed, linesize } }), w.height.x) : w.height;
        const m = w.margin && expandMargin(w, context, placement);
        const b = w.border && expandBorder(w, context, placement);
        let pct = false;
        if (h == null && linesize)
            h = maxFontSize(w);
        if (typeof h === 'number')
            r = h;
        else if (h && typeof h === 'object' && 'percent' in h && h.percent && placement.maxY) {
            r = +(placement.maxY * (h.percent / 100)).toFixed(4);
            pct = true;
        }
        else if (h === 'grow') {
            r = placement.availableY || 0;
        }
        else if (h === 'auto' || typeof h === 'string' || (h == null && w.type === 'container') || (computed && !h)) {
            if (b)
                return computed + b[0] + b[2] || NaN;
            return computed || NaN;
        }
        if (typeof r === 'number' && (w.box === 'contain' || (pct || r === placement.availableY) && w.box !== 'expand')) {
            if (m)
                r -= m[0] + m[2];
        }
        return r;
    }
    function getHeightWithMargin(w, placement, context, computed, linesize) {
        let h = getHeight(w, placement, context, computed, linesize);
        if (w.margin) {
            const m = expandMargin(w, context, placement);
            h += m[0] + m[2];
        }
        return h;
    }
    function maxYOffset(points) {
        return points.reduce((a, c) => a > c[1] + c[3] ? a : c[1] + c[3], 0);
    }
    function maxXOffset(points) {
        return points.reduce((a, c) => a > c[0] + c[2] ? a : c[0] + c[2], 0);
    }
    function expandMargin(w, context, placement) {
        if (w.margin) {
            const m = isComputed(w.margin) ? evaluate(extend$2(context.context, { special: { widget: w, placement } }), w.margin.x) : w.margin;
            if (Array.isArray(m)) {
                if (m.length === 4)
                    return m.map(e => +e);
                else if (m.length === 2)
                    return [+m[0], +m[1], +m[0], +m[1]];
            }
            else if (typeof m === 'number')
                return [m, m, m, m];
        }
        return [0, 0, 0, 0];
    }
    function expandBorder(w, context, placement) {
        let b = w.border;
        let res = [0, 0, 0, 0];
        if (typeof b === 'string' || (b && !Array.isArray(b) && typeof b === 'object' && ('v' in b || 'r' in b || 'op' in b)))
            b = evaluate(extend$2(context.context, { special: { widget: w, placement } }), b);
        if (typeof b === 'number')
            res = [0, 0, b, 0];
        else if (Array.isArray(b)) {
            if (b.length === 1)
                res = [b[0], b[0], b[0], b[0]];
            else if (b.length === 2)
                res = [b[0], b[1], b[0], b[1]];
            else if (b.length === 3)
                res = [b[0], b[1], b[2], b[1]];
            else if (b.length >= 4)
                res = [b[0], b[1], b[2], b[3]];
        }
        else if (b && typeof b === 'object')
            res = [b.top || 0, b.right || 0, b.bottom || 0, b.left || 0];
        for (let i = 0; i < 4; i++)
            res[i] = res[i] * 0.0625;
        return res;
    }
    function expandMacro(macro, w, ctx, placement, state) {
        const res = evaluate(extend$2(ctx.context, { special: { widget: w, placement, state } }), macro);
        if (res && !Array.isArray(res) && typeof res === 'object') {
            if ('content' in res || 'props' in res || 'properties' in res)
                w = Object.assign({}, w, res.props, res.properties, { widgets: Array.isArray(res.content) ? res.content : res.content ? [res.content] : w.widgets, macro: undefined });
            else if ('replace' in res && res.replace && typeof res.replace === 'object' && 'type' in res.replace)
                return res.replace;
            else
                w = Object.assign({}, w, { widgets: [res], macro: undefined });
        }
        else if (Array.isArray(res))
            w = Object.assign({}, w, { widgets: res, macro: undefined });
        return w;
    }

    function nextStyleId(ctx, prefix) {
        if (!ctx.styleMap.ids[prefix])
            ctx.styleMap.ids[prefix] = 0;
        return ctx.styleMap.ids[prefix]++;
    }
    function mapStyle(ctx, style, prefix) {
        if (!style)
            return '';
        const mapped = ctx.styleMap.styles[style];
        if (mapped)
            return mapped;
        const id = `${prefix}${nextStyleId(ctx, prefix)}`;
        return ctx.styleMap.styles[style] = id;
    }
    function styleClass(ctx, cls, [style, inline], inlineStyle, classPrefix) {
        if (ctx.report.classifyStyles !== false) {
            const cs = [];
            if (inline)
                cs.push(mapStyle(ctx, inline, 'h'));
            cs.push(mapStyle(ctx, style, classPrefix || 's'));
            return ` class="${cls.concat(cs).join(' ')}"${inlineStyle ? ` style="${inlineStyle}"` : ''}`;
        }
        else {
            const s = `${style}${inlineStyle || ''}${inline || ''}`;
            const c = `${cls.length ? ` class="${cls.join(' ')}"` : ''}`;
            return `${c}${s ? ` style="${s}"` : ''}`;
        }
    }
    function style$2(w, placement, context, opts) {
        let s = `left:${(placement.x || 0) + (placement.offsetX || 0)}rem;top:${((placement.y || 0) + (placement.offsetY || 0))}rem;`;
        let i = ``;
        s += `width:${getWidthWithMargin(w, placement, context)}rem;`;
        let h = getHeightWithMargin(w, placement, context, opts && opts.computedHeight, opts && opts.lineSize) || 1;
        if (w.height === 'grow' && w.margin) {
            const m = expandMargin(w, context, placement);
            h += m[0] + m[2];
        }
        if (opts && opts.container && opts.computedHeight)
            i = `height:${h}rem;`;
        else
            s += `height:${h}rem;`;
        const line = w.font && maybeComputed(w.font.line, context);
        const size = w.font && maybeComputed(w.font.size, context);
        if (line != null || size != null)
            s += `line-height: ${line !== null && line !== void 0 ? line : size}rem;`;
        if (w.margin) {
            const m = expandMargin(w, context, placement);
            if (m[0] || m[1] || m[2] || m[3])
                s += `padding:${m[0]}rem ${m[1]}rem ${m[2]}rem ${m[3]}rem;`;
        }
        else if (w.font && w.font.right) {
            s += `padding-right:${w.font.right}rem;`;
        }
        if ((opts && opts.font) || w.font)
            s += styleFont((opts && opts.font) || w.font, context);
        if (w.border)
            s += styleBorder(w, context, placement);
        s += styleExtra(w, context);
        return [s, i];
    }
    function styleExtra(w, context) {
        let s = '';
        const bg = maybeComputed(w.bg, context);
        if (bg)
            s += `background-color:${bg};`;
        const radius = maybeComputed(w.radius, context);
        if (radius)
            s += `border-radius:${radius};`;
        return s;
    }
    function styleFont(f, context) {
        if (!f)
            return '';
        let t;
        let size;
        let s = '';
        if (t = maybeComputed(f.family, context))
            s += `font-family:${t};`;
        if (t = maybeComputed(f.color, context))
            s += `color:${t};`;
        if (t = maybeComputed(f.align, context))
            s += `text-align:${t};`;
        if (t = maybeComputed(f.size, context)) {
            s += `font-size:${t}rem;`;
            size = t;
        }
        t = maybeComputed(f.line, context);
        if (t === 0)
            s += `line-height:initial;`;
        else if (t != null)
            s += `line-height:${t}rem;`;
        else if (size)
            s += `line-height:${size}rem;`;
        if (t = maybeComputed(f.weight, context))
            s += `font-weight:${t};`;
        if (t = maybeComputed(f.pre, context))
            s += `white-space:pre-wrap;word-break:break-word;`;
        const pre = t;
        if (t = maybeComputed(f.clamp, context))
            s += `${pre ? '' : 'white-space:nowrap;'}overflow:hidden;`;
        return s;
    }
    function styleBorder(w, context, placement) {
        const b = expandBorder(w, context, placement);
        if (b[0] + b[1] + b[2] + b[3])
            return `border-style:solid;border-width:${b[0]}rem ${b[1]}rem ${b[2]}rem ${b[3]}rem;`;
        return '';
    }
    function styleImage(fit) {
        const s = `background-size:${!fit || fit === 'contain' ? 'contain;background-position:center' : fit === 'stretch' ? '100% 100%' : 'cover'};`;
        return [s, ''];
    }

    const PageSizes = {
        letter: {
            width: 51,
            height: 66,
            margin: [1.5, 1.5],
        },
        legal: {
            width: 51,
            height: 84,
            margin: [1.5, 1.5],
        },
        tabloid: {
            width: 66,
            height: 102,
            margin: [1.5, 1.5],
        },
        a4: {
            width: 49.606302,
            height: 70.15746,
            margin: [1.5, 1.5],
        }
    };
    /** Initialize a parameter map based on the parameters defined by the given report. */
    function initParameters(report, sources, parameters) {
        const ctx = parameters && 'root' in parameters && parameters.root === parameters ? parameters : new Root(Object.assign({}, report.context), { parameters });
        ctx.parameters = Object.assign({}, report.defaultParams, ctx.parameters);
        const inits = {};
        if (report.sources)
            applySources(ctx, report.sources, sources);
        if (Array.isArray(report.parameters)) {
            for (const p of report.parameters) {
                if (p.init && p.name) {
                    inits[p.name] = evaluate(ctx, p.init);
                }
            }
        }
        return inits;
    }
    /** Run the given report to string. If the report is displayed, the result will be HTML. Otherwise, it will be plain text. */
    function run(report, sources, parameters, extra) {
        const ctx = parameters && 'root' in parameters && parameters.root === parameters ? parameters : new Root(Object.assign({}, report.context), { parameters });
        if (report.sources)
            applySources(ctx, report.sources, sources);
        ctx.parameters = Object.assign({}, initParameters(report, sources), ctx.parameters);
        if (report.extraContext) {
            const res = evaluate(ctx, report.extraContext);
            if (res && typeof res === 'object')
                ctx.value = Object.assign(ctx.value, res);
        }
        if (report.type === 'delimited')
            return runDelimited(report, ctx, { table: extra === null || extra === void 0 ? void 0 : extra.table });
        else if (report.type === 'flow')
            return runFlow(report, ctx, extra);
        else
            return runPage(report, ctx, extra);
    }
    /** Apply multiple sources to a context together. Each source base is available before filter/sort/group is applied in case a source needs to reference a later source for those purposes. */
    function applySources(context, sources, map) {
        const srcs = context.sources;
        for (const source of sources) {
            let base = map[source.source || source.name] || { value: [] };
            if (source.base)
                base = evaluate(extend$2(context, { value: base.value, special: { source: base } }), source.base);
            srcs[source.name || source.source] = toDataSet(base);
        }
        for (const source of sources) {
            if (source.filter || source.sort || source.group)
                srcs[source.name || source.source] = filter(srcs[source.name || source.source], source.filter, source.sort, source.group, context);
        }
    }
    function runDelimited(report, context, options) {
        const source = context.root.sources[report.source ? report.source : (report.sources[0].name || report.sources[0].source)];
        const values = Array.isArray(source.value) ?
            source.value :
            typeof source.value === 'object' && 'grouped' in source.value && Array.isArray(source.value.all) ? // watch out for grouped sources
                source.value.all :
                [source.value];
        let fields = report.fields;
        let headers = report.headers;
        if (!fields || !fields.length && values.length) {
            fields = Object.keys(values[0]);
            if (!headers || !headers.length)
                headers = Object.keys(values[0]).map(k => `'${k.replace(/'/g, '\\\'')}'`);
        }
        let res = '';
        if (headers) {
            const ctx = extend$2(context, { parser: parse$3 });
            if (options === null || options === void 0 ? void 0 : options.table)
                res += `<tr class=header><th style="border-right: 2px solid;"></th>${headers.map(h => `<th>${evaluate(ctx, h)}</th>`).join('')}</tr>`;
            else
                res += headers.map(h => `${report.quote || ''}${evaluate(ctx, h)}${report.quote || ''}`).join(report.field || ',') + (report.record || '\n');
        }
        if (options === null || options === void 0 ? void 0 : options.table) {
            let idx = 1;
            for (const value of values) {
                const c = extend$2(context, { value });
                if (report.rowContext) {
                    if (!c.locals)
                        c.locals = {};
                    const v = evaluate(c, report.rowContext);
                    if (v)
                        c.value = v;
                }
                res += `<tr class=row><th>${idx}</th>${fields.map(f => {
                let val = f ? evaluate(c, f) : '';
                if (val === undefined)
                    val = '';
                if (typeof val !== 'string')
                    val = `${val}`;
                return `<td>${val}</td>`;
            }).join('')}</tr>`;
                idx++;
            }
            res = `<table>${res}</table>`;
        }
        else {
            const unquote = report.quote ? new RegExp(report.quote, 'g') : undefined;
            for (const value of values) {
                const c = extend$2(context, { value });
                if (report.rowContext) {
                    if (!c.locals)
                        c.locals = {};
                    const v = evaluate(c, report.rowContext);
                    if (v)
                        c.value = v;
                }
                res += fields.map(f => {
                    let val = f ? evaluate(c, f) : '';
                    if (val === undefined)
                        val = '';
                    if (typeof val !== 'string')
                        val = `${val}`;
                    if (unquote)
                        val = val.replace(unquote, report.quote + report.quote);
                    return `${report.quote || ''}${val}${report.quote || ''}`;
                }).join(report.field || ',') + (report.record || '\n');
            }
        }
        return res;
    }
    function runPage(report, context, extras) {
        var _a, _b, _c, _d, _e, _f, _g;
        let size = report.orientation !== 'portrait' ? { width: report.size.height, height: report.size.width, margin: [report.size.margin[1], report.size.margin[0]] } : report.size;
        const ctx = { context, report, styles: {}, styleMap: { ids: {}, styles: {} } };
        const margin = expandMargin(report, ctx, { x: 0, y: 0 });
        context.special = context.special || {};
        context.special.page = 0;
        context.special.pages = 0;
        const pages = [''];
        let page = 0;
        const printX = size.width - 2 * size.margin[1];
        const printY = size.height - 2 * size.margin[0];
        let availableY = printY - margin[0] - margin[2];
        const pageY = availableY;
        let maxY = availableY;
        let y = 0;
        const availableX = printX - margin[1] - margin[3];
        let state = null;
        let headSize = 0;
        if (report.header) {
            const r = renderWidget(report.header, ctx, { x: 0, y: 0, availableX, availableY, maxX: availableX, maxY });
            headSize = r.height;
            if (!((_a = report.header) === null || _a === void 0 ? void 0 : _a.outer)) {
                availableY -= headSize;
                maxY -= headSize;
                y += headSize;
            }
        }
        let footSize = 0;
        if (report.footer) {
            const r = renderWidget(report.footer, ctx, { x: 0, y: 0, availableX, availableY, maxX: availableX, maxY });
            footSize = r.height;
            if (!((_b = report.footer) === null || _b === void 0 ? void 0 : _b.outer)) {
                availableY -= footSize;
                maxY -= footSize;
            }
        }
        for (let w of report.widgets) {
            if (w.macro)
                w = expandMacro(w.macro, w, ctx, { x: 0, y: 0, availableX, availableY, maxX: availableX, maxY }, state);
            let r;
            do {
                r = renderWidget(w, ctx, { x: 0, y, availableX, availableY, maxX: availableX, maxY }, state);
                pages[page] += r.output;
                if (r.continue) {
                    page++;
                    pages[page] = '';
                    y = ((_c = report.header) === null || _c === void 0 ? void 0 : _c.outer) ? 0 : headSize;
                    availableY = printY - (((_d = report.header) === null || _d === void 0 ? void 0 : _d.outer) ? 0 : headSize) - (((_e = report.footer) === null || _e === void 0 ? void 0 : _e.outer) ? 0 : footSize) - margin[0] - margin[2];
                    state = r.continue;
                }
                else {
                    y += r.height;
                    availableY -= r.height;
                    state = null;
                }
            } while (state !== null);
        }
        context.special.pages = pages.length;
        const footPlace = ((_f = report.footer) === null || _f === void 0 ? void 0 : _f.outer) ?
            { x: 0, y: printY - footSize, maxX: printX, maxY: printY } :
            { x: 0 + margin[3], y: printY - margin[0] - footSize, maxX: printX - margin[3] - margin[1], maxY: printY - margin[0] - margin[2] };
        const headPlace = ((_g = report.header) === null || _g === void 0 ? void 0 : _g.outer) ?
            { x: 0, y: 0, maxX: printX, maxY: printY } :
            { x: 0 + margin[3], y: margin[0], maxX: printX - margin[3] - margin[1], maxY: printY - margin[0] - margin[2] };
        context.special.size = { x: availableX, y: pageY };
        pages.forEach((p, i) => {
            let n = `<div class="page-back pb${i}"><div${styleClass(ctx, ['page', `ps${i}`], ['', ''], '', 'p')}>\n`;
            context.special.page = i + 1;
            if (report.watermark) {
                const r = renderWidget(report.watermark, ctx, { x: 0, y: 0, maxX: printX, availableX: printX, maxY: printY, availableY: printY });
                n += r.output + '\n';
            }
            if (report.header) {
                const r = renderWidget(report.header, ctx, headPlace);
                n += r.output + '\n';
            }
            n += `<div class="page-inner">${p}</div>`;
            if (report.footer) {
                const r = renderWidget(report.footer, ctx, footPlace);
                n += r.output + '\n';
            }
            if (report.overlay) {
                const r = renderWidget(report.overlay, ctx, { x: 0, y: 0, maxX: printX, availableX: printX, maxY: printY, availableY: printY });
                n += r.output + '\n';
            }
            n += '\n</div></div>';
            pages[i] = n;
        });
        return `<html style="font-size:100%;margin:0;padding:0;"><head><style>
    .page { width: ${printX}rem; height: ${printY}rem; position: absolute; overflow: hidden; left: ${size.margin[1]}rem; top: ${size.margin[0]}rem; ${report.font ? styleFont(report.font, ctx) : ''} }
    .page-inner { position: absolute; width: ${printX - margin[1] - margin[3]}rem; height: ${printY - margin[0] - margin[2]}rem; left: ${margin[3]}rem; top: ${margin[0]}rem; }
    .page-back { width: ${size.width}rem; height: ${size.height}rem; }
    body { font-size: 0.83rem; }
    @media screen {
      html { min-width: ${size.width + 2}rem; }
      body { background-color: #999; display: flex; flex-direction: column; align-items: center; }
      .page-back { background-color: #fff; box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.4); position: relative; overflow: hidden; box-sizing: border-box; margin: 0.5em; }
    }
    @media print {
      body { margin: 0; padding: 0; ${size ? `width:${size.width}rem;` : ''}background-color: none; display: block; height: ${pages.length * size.height}rem }
      .page-back { position: absolute; box-shadow: none; background-color: none; margin: 0; padding: 0; left: 0rem; }
      ${pages.map((_p, i) => `.pb${i} { top: ${i * size.height}rem; }`).join('')}
    }
    @page {
      size: ${size.width}em ${size.height}em;
    }${Object.entries(ctx.styles).map(([_k, v]) => v).join('\n')}${Object.entries(ctx.styleMap.styles).map(([style, id]) => `.${id} { ${style} }`).join('\n')}
  </style>${extras && extras.head || ''}</head><body>\n${pages.reduce((a, c) => a + c, '')}${extras && extras.foot || ''}</body></html>`;
    }
    function runFlow(report, context, extras) {
        const ctx = { context, report, styles: {}, styleMap: { ids: {}, styles: {} } };
        let html = '';
        let y = 0;
        let state = null;
        let width;
        const margin = report.size && report.size.margin ? expandMargin(report.size, ctx, { x: 0, y: 0, availableX: width, maxX: width }) : [1.5, 1.5, 1.5, 1.5];
        if (report.width)
            width = report.width;
        else if (report.size)
            width = report.orientation !== 'portrait' ? report.size.height : report.size.width;
        // account for margins
        if (width)
            width -= (margin[1] || 0) + (margin[3] || 0);
        function render(w, cls) {
            html += `<div${styleClass(ctx, cls ? [cls] : [], [`position:absolute;right:0rem;left:0rem;${width ? `width:${width}rem;` : ''}`, ''], `top:${y}rem;`, 'p')}>\n`;
            let r;
            let yy = 0;
            do {
                r = renderWidget(w, ctx, { x: 0, y: yy, availableX: width, maxX: width }, state);
                if (typeof r === 'string')
                    throw new Error(`Container widget didn't specify used height`);
                else {
                    html += r.output;
                    yy += r.height;
                    if (r.continue) {
                        state = r.continue;
                    }
                    else {
                        state = null;
                    }
                }
            } while (state !== null);
            y += yy;
            html += `</div>\n`;
        }
        if (report.watermark)
            render(report.watermark, 'watermark');
        let maxY = y || 0;
        y = 0;
        for (const w of report.widgets)
            render(w, 'main');
        if (y > maxY)
            maxY = y;
        y = 0;
        if (report.overlay)
            render(report.overlay, 'overlay');
        if (y > maxY)
            maxY = y;
        return `<html><head><style>
    html { font-size: 100%; margin: 0; padding: 0; }
    body { font-size: 0.83rem; padding: 0; margin: 0;${width ? ` width: ${width}rem;` : ''}; height: ${maxY}rem; position: relative; }
    .page-back { ${width ? `width: ${width}rem; ` : ''}height: ${maxY}rem; padding: ${margin[0] || 0}rem ${margin[1] || 0}rem ${margin[2] || 0}rem ${margin[3] || 0}rem; position: absolute; left: 0; top: 0; }
    #wrapper { height:${maxY}rem; position: relative; ${report.font ? styleFont(report.font, ctx) : ''} }
    .watermark { z-index: 0; }
    .main { z-index: 5; }
    .overlay { z-index: 10; }
    @media screen {
      body { margin: 1rem${width ? ' auto' : ''}; background-color: #fff; box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.4); padding: ${margin[0]}rem ${margin[1]}rem ${margin[2]}rem ${margin[3]}rem !important; }
      html { background-color: #999; }
    }${Object.entries(ctx.styles).map(([_k, v]) => v).join('\n')}${Object.entries(ctx.styleMap.styles).map(([style, id]) => `.${id} { ${style} }`).join('\n')}
  </style>${extras && extras.head || ''}</head><body>\n<div class=page-back><div id=wrapper>${html}</div></div>${extras && extras.foot || ''}</body></html>`;
    }

    // zero width space
    const zwsp = '&#8203;';
    const sp = read1(' \r\n\t');
    const ws$1 = read(' \r\n\t');
    const hex = '0123456789abcdef';
    const integer = map(read1('0123456789'), v => +v);
    const number$1 = map(seq(opt(str('-')), read1('0123456789'), opt(seq(str('.'), read1('0123456789')))), ([m, n, d]) => +[m, n, d === null || d === void 0 ? void 0 : d[0], d === null || d === void 0 ? void 0 : d[1]].filter(v => v).join(''));
    const color = map(seq(opt(str('#')), alt(chars(8, hex), chars(6, hex), chars(4, hex), chars(3, hex))), ([, color]) => `#${color}`);
    const remOrPercent = map(seq(number$1, opt(str('%'))), ([n, p]) => `${n}${p ? '%' : 'rem'}`);
    const places = str('left', 'right', 'top', 'bottom', 'center');
    const align = map(seq(str('align'), opt(seq(str('='), alt(seq(str('top', 'middle', 'bottom', 'base'), opt(seq(sp, str('left', 'right', 'center')))), seq(str('left', 'right', 'center'), opt(seq(sp, str('top', 'middle', 'bottom', 'base')))))))), ([, v]) => { var _a; return ({ tag: 'align', value: v ? [v[1][0], (_a = v[1][1]) === null || _a === void 0 ? void 0 : _a[1]].filter(v => v) : null }); });
    const valign = map(seq(str('valign'), opt(seq(str('='), str('top', 'middle', 'bottom', 'base')))), ([, v]) => ({ tag: 'valign', value: v ? v[1] : null }));
    const pad$1 = map(seq(str('pad'), opt(seq(str('='), rep1sep(number$1, sp)))), ([, v]) => ({ tag: 'pad', value: v ? v[1] : null }));
    const margin = map(seq(str('margin'), opt(seq(str('='), rep1sep(number$1, sp)))), ([, v]) => ({ tag: 'margin', value: v ? v[1] : null }));
    const width = map(seq(str('width', 'w'), opt(seq(str('='), remOrPercent))), ([, v]) => ({ tag: 'width', value: v ? v[1] : null }));
    const height = map(seq(str('height', 'h'), opt(seq(str('='), remOrPercent))), ([, v]) => ({ tag: 'height', value: v ? v[1] : null }));
    const line = map(seq(str('line'), opt(seq(str('='), number$1))), ([, v]) => ({ tag: 'line', value: v ? v[1] : null }));
    const fg = map(seq(str('fg', 'color', 'fore'), opt(seq(str('='), color))), ([, v]) => ({ tag: 'fg', value: v ? v[1] : null }));
    const bg = map(seq(str('bg', 'background', 'back'), opt(seq(str('='), color))), ([, v]) => ({ tag: 'bg', value: v ? v[1] : null }));
    const size = map(seq(str('size'), opt(seq(str('='), number$1))), ([, v]) => ({ tag: 'size', value: v ? v[1] : null }));
    const font = map(seq(str('font'), opt(seq(str('='), read1To(',|')))), ([, v]) => ({ tag: 'font', value: v ? v[1] : null }));
    const rotate = map(seq(str('rotate'), opt(seq(str('='), number$1, ws$1, opt(str('left', 'right')), opt(seq(sp, alt(remOrPercent, places), sp, alt(remOrPercent, places)))))), ([, v]) => ({ tag: 'rotate', value: v ? { turn: v[1] * (v[3] === 'left' ? -1 : 1), origin: v[4] ? [v[4][1], v[4][3]] : undefined } : null }));
    const move = map(seq(str('move'), opt(seq(str('='), remOrPercent, sp, remOrPercent))), ([, v]) => ({ tag: 'move', value: v ? { x: v[1], y: v[3] } : null }));
    const trash = map(readTo(',|'), v => ({ tag: 'trash', value: v }));
    const border = map(seq(str('border'), opt(seq(str('='), opt(str('solid', 'dot', 'dash', 'double')), ws$1, rep1sep(integer, sp), ws$1, opt(seq(str('/'), ws$1, rep1sep(number$1, sp))), ws$1, opt(color)))), ([, v]) => { var _a; return ({ tag: 'border', value: v ? { style: v[1] || 'solid', width: v[3], radius: (_a = v[5]) === null || _a === void 0 ? void 0 : _a[2], color: v[7] } : null }); });
    const bools = map(alt(str('sub', 'sup', 'bold', 'italic', 'underline', 'strike', 'overline', 'overflow', 'nowrap', 'pre', 'br', 'b', 'i', 'u')), tag => ({ tag }));
    const tag = map(seq(str('|'), ws$1, rep1sep(alt(border, align, fg, bg, valign, size, line, font, pad$1, margin, width, height, bools, rotate, move, trash), seq(ws$1, str(','), ws$1), 'allow'), readTo('|'), str('|')), ([, , tags]) => tags.filter(t => t.tag !== 'trash'));
    const text = map(rep1(alt(read1To('\\|', true), map(str('\\|'), () => '|'))), txts => txts.join(''));
    const all = rep(alt(text, tag));
    const parser$1 = parser$2(all, { consumeAll: true, undefinedOnError: true });
    const blocks = ['border', 'width', 'height', 'pad', 'margin', 'align', 'overflow', 'nowrap', 'rotate', 'move'];
    const aliases = {
        b: 'bold',
        i: 'italic',
        u: 'underline',
    };
    function process(stuff) {
        let res = '';
        let open = false;
        const state = { bool: {}, value: {} };
        const blockstack = [];
        for (const s of stuff) {
            if (typeof s === 'string') {
                if (!state.bool.pre && /^\s/.test(s))
                    res += zwsp;
                res += s;
                if (!state.bool.pre && /\s$/.test(s))
                    res += zwsp;
            }
            else {
                let drop = false;
                let block;
                for (const style of s) {
                    const tag = aliases[style.tag] || style.tag;
                    if ('value' in style) {
                        if (style.value !== null) {
                            (state.value[tag] || (state.value[tag] = [])).push(style.value);
                            if (blocks.includes(tag) || block && tag === 'bg')
                                (block || (block = [])).push(tag);
                        }
                        else {
                            if (blocks.includes(tag))
                                drop = true;
                            else if (tag === 'bg' && (drop || blockstack && blockstack.length && blockstack[blockstack.length - 1].includes('bg')))
                                drop = true;
                            else
                                (state.value[tag] || (state.value[tag] = [])).pop();
                        }
                    }
                    else {
                        if (tag === 'br')
                            res += '<br/>';
                        else if (blocks.includes(tag) && block.length)
                            block.push(tag);
                        else
                            state.bool[tag] = !state.bool[tag];
                    }
                }
                if (open)
                    res += `</span>`;
                open = true;
                if (drop) {
                    const frame = blockstack.pop();
                    if (frame) {
                        res += '</span>';
                        for (const b of frame)
                            (state.value[b] || (state.value[b] = [])).pop();
                    }
                }
                if (block) {
                    blockstack.push(block);
                    res += `<span style="${getStyle$1(state, block)}">`;
                }
                res += `<span style="${getStyle$1(state, 'inline')}">`;
            }
        }
        if (open)
            res += `</span>`;
        for (const f of blockstack)
            res += '</span>';
        return res;
    }
    function style$1(str) {
        const parsed = parser$1(str);
        if (Array.isArray(parsed))
            return process(parsed);
        return str;
    }
    const flexAlign = { top: 'start', middle: 'center', bottom: 'end', base: 'baseline' };
    const borderStyle = { dot: 'dotted', dash: 'dashed' };
    function getStyle$1(state, which) {
        let res = '';
        if (which === 'inline') {
            const bs = state.bool;
            if (bs.underline || bs.overline || bs.strike)
                res += `text-decoration-line:${[bs.underline && 'underline', bs.overline && 'overline', bs.strike && 'line-through'].filter(v => v).join(' ')};`;
            if (bs.sup || bs.sub) {
                res += `font-size:70%;`;
                if (bs.sup)
                    res += `vertical-align:super;`;
                if (bs.sub)
                    res += `vertical-align:sub;`;
            }
            if (bs.italic)
                res += `font-style:italic;`;
            if (bs.bold)
                res += `font-weight:bold;`;
            if (bs.pre)
                res += `white-space:pre-wrap;`;
            const vs = state.value;
            if (Array.isArray(vs.valign)) {
                const v = vs.valign[vs.valign.length - 1];
                if (v)
                    res += `vertical-align:${v === 'base' ? 'baseline' : v};`;
            }
            if (Array.isArray(vs.fg)) {
                const v = vs.fg[vs.fg.length - 1];
                if (v)
                    res += `color:${v};`;
            }
            if (Array.isArray(vs.bg)) {
                const v = vs.bg[vs.bg.length - 1];
                if (v)
                    res += `background-color:${v};`;
            }
            if (Array.isArray(vs.size)) {
                const v = vs.size[vs.size.length - 1];
                if (v != null)
                    res += `font-size:${v}rem;`;
            }
            if (Array.isArray(vs.font)) {
                const v = vs.font[vs.font.length - 1];
                if (v != null)
                    res += `font-family:${v};`;
            }
            if (Array.isArray(vs.line)) {
                const v = vs.line[vs.line.length - 1];
                if (v != null)
                    res += `line-height:${v}rem;`;
            }
        }
        else {
            res += `display:inline-flex;box-sizing:content-box;overflow:hidden;`;
            const vs = state.value;
            let transforms;
            if (which.includes('align') && Array.isArray(vs.align)) {
                const v = vs.align[vs.align.length - 1];
                if (Array.isArray(v)) {
                    let vv = v.find(v => ['top', 'middle', 'bottom', 'base'].includes(v));
                    if (vv)
                        res += `align-items:${flexAlign[vv]};`;
                    vv = v.find(v => ['left', 'right', 'center'].includes(v));
                    if (vv)
                        res += `justify-content:${vv};`;
                }
            }
            if (which.includes('width') && Array.isArray(vs.width)) {
                const v = vs.width[vs.width.length - 1];
                if (v != null)
                    res += `width:${v};`;
            }
            if (which.includes('height') && Array.isArray(vs.height)) {
                const v = vs.height[vs.height.length - 1];
                if (v != null)
                    res += `height:${v};`;
            }
            if (which.includes('pad') && Array.isArray(vs.pad)) {
                const v = vs.pad[vs.pad.length - 1];
                if (Array.isArray(v) && v.length) {
                    res += `padding:${v[0]}rem`;
                    if (v.length > 1)
                        res += ` ${v[1]}rem`;
                    if (v.length > 2)
                        res += ` ${v[2]}rem`;
                    if (v.length > 3)
                        res += ` ${v[3]}rem`;
                    res += ';';
                }
            }
            if (which.includes('margin') && Array.isArray(vs.margin)) {
                const v = vs.margin[vs.margin.length - 1];
                if (Array.isArray(v) && v.length) {
                    res += `margin:${v[0]}rem`;
                    if (v.length > 1)
                        res += ` ${v[1]}rem`;
                    if (v.length > 2)
                        res += ` ${v[2]}rem`;
                    if (v.length > 3)
                        res += ` ${v[3]}rem`;
                    res += ';';
                }
            }
            if (which.includes('border') && Array.isArray(vs.border)) {
                const v = vs.border[vs.border.length - 1];
                if (v) {
                    res += `border-style:${borderStyle[v.style] || v.style};border-width:${v.width[0]}px`;
                    if (v.width.length > 1)
                        res += ` ${v.width[1]}px`;
                    if (v.width.length > 2)
                        res += ` ${v.width[2]}px`;
                    if (v.width.length > 3)
                        res += ` ${v.width[3]}px`;
                    res += ';';
                    if (v.color)
                        res += `border-color:${v.color};`;
                    if (v.radius) {
                        res += `border-radius:${v.radius[0]}rem`;
                        if (v.radius.length > 1)
                            res += ` ${v.radius[1]}rem`;
                        if (v.radius.length > 2)
                            res += ` ${v.radius[2]}rem`;
                        if (v.radius.length > 3)
                            res += ` ${v.radius[3]}rem`;
                        res += ';';
                    }
                }
            }
            if (which.includes('bg') && Array.isArray(vs.bg)) {
                const v = vs.bg[vs.bg.length - 1];
                if (v)
                    res += `background-color:${v};`;
            }
            if (which.includes('rotate') && Array.isArray(vs.rotate)) {
                const v = vs.rotate[vs.rotate.length - 1];
                if (v) {
                    if (v.origin)
                        res += `transform-origin:${v.origin[0]} ${v.origin[1]};`;
                    (transforms || (transforms = []))[which.indexOf('rotate')] = `rotate(${v.turn}turn)`;
                }
            }
            if (which.includes('move') && Array.isArray(vs.move)) {
                const v = vs.move[vs.move.length - 1];
                if (v)
                    (transforms || (transforms = []))[which.indexOf('move')] = `translate(${v.x}, ${v.y})`;
            }
            if (transforms)
                res += `transform:${transforms.filter(v => v).join(' ')};`;
            if (which.includes('nowrap'))
                res += `white-space:nowrap;`;
            if (which.includes('overflow'))
                res += `overflow:visible;`;
        }
        return res;
    }

    registerRenderer('label', (w, ctx, placement) => {
        addStyle$1(ctx, 'label', `.label {position:absolute;box-sizing:border-box;white-space:normal;}`);
        let str = '';
        let sval;
        let val = (Array.isArray(w.text) ? w.text : [w.text]).map(v => {
            let val = evaluate(ctx, typeof v === 'object' && 'text' in v ? v.text : v);
            if (typeof val === 'string')
                val = escapeHTML(val);
            if (typeof v === 'object' && 'id' in v) {
                let c = ctx.context;
                while (c) {
                    if (c.special && c.special.values)
                        (c.special.values[v.id] || (c.special.values[v.id] = [])).push(val);
                    c = c.parent;
                }
            }
            str += val;
            sval = val;
            if (w.styled)
                val = style$1(val);
            if (typeof v === 'object' && 'text' in v) {
                return `<span${styleClass(ctx, [], [styleFont(v.font, ctx) + styleExtra(v, ctx), ''])}>${val}</span>`;
            }
            else {
                return val;
            }
        }).join('');
        if (w.id) {
            let c = ctx.context;
            while (c) {
                if (c.special && c.special.values)
                    (c.special.values[w.id] || (c.special.values[w.id] = [])).push(str);
                c = c.parent;
            }
        }
        if (w.format && w.format.name) {
            const args = [{ v: !Array.isArray(w.text) || w.text.length === 1 ? sval : val }, { v: w.format.name }];
            val = evaluate(ctx, { op: 'format', args: args.concat(w.format.args || []) });
        }
        return `<span${styleClass(ctx, ['label'], style$2(w, placement, ctx, { lineSize: true }))}>${val}</span>`;
    });
    registerRenderer('container', (w, ctx, placement, state) => {
        addStyle$1(ctx, 'container', `.container {position:absolute;box-sizing:border-box;}`);
        let h;
        if (!w.height)
            w.height = 'auto';
        else if (w.height !== 'auto')
            h = getHeightWithMargin(w, placement, ctx);
        const wctx = ((state || {}).state || {}).ctx ? Object.assign({}, ctx, { context: state.state.ctx }) : ctx;
        if (w.context && !((state || {}).state || {}).ctx) {
            if (!wctx.context.locals)
                wctx.context.locals = {};
            const value = evaluate(extend$1(wctx, { special: { placement, widget: w }, locals: wctx.context.locals }), w.context);
            if (value)
                wctx.context = extend$2(wctx.context, { value, special: { placement, widget: w } });
        }
        const cw = getWidth(w, placement, ctx) || placement.availableX;
        const r = renderWidgets(w, wctx, { x: 0, y: 0, availableX: cw, availableY: h || placement.availableY, maxX: cw, maxY: h != null ? h : placement.maxY }, state, w.layout);
        if (!r.cancel) {
            r.output = `<div${styleClass(ctx, ['container'], style$2(w, placement, ctx, { computedHeight: h || r.height, container: true }))}>${r.output}</div>`;
            r.height = h || r.height;
            r.width = getWidthWithMargin(w, placement, ctx);
        }
        if ((r.cancel || r.continue) && !w.bridge) {
            const state = r.continue || {};
            state.offset = 0;
            // must start over
            delete state.last;
            state.attempt = (state.attempt || 0) + 1;
            if (state.attempt > 1)
                return error(ctx, placement);
            return { continue: state, output: '' };
        }
        else if (r.continue) {
            if (w.context)
                r.continue.state = { ctx: wctx.context };
            r.continue.offset = 0;
        }
        return r;
    }, { container: true });
    registerRenderer('repeater', (w, ctx, placement, state) => {
        addStyle$1(ctx, 'container', `.container {position:absolute;box-sizing:border-box;}`);
        if (!w.height)
            w.height = 'auto';
        let availableY = placement.availableY;
        let availableX = placement.availableX;
        let r;
        let html = '';
        let commit = false;
        const m = expandMargin(w, ctx, placement);
        let y = !state || !state.state || state.state.part === 'header' ? m[0] : 0;
        availableY -= y;
        let group;
        let groupNo = false;
        const newPage = state && state.state && state.state.newPage;
        let src = state && state.state && state.state.src;
        if (!src) {
            if (!w.source)
                return '';
            src = isValueOrExpr(w.source) ?
                evaluate(ctx, w.source) :
                filter(ctx.context.root.sources[w.source.source] || { value: [] }, w.source.filter, w.source.sort, w.source.group, ctx.context).value;
            (ctx.context.special || (ctx.context.special = {})).values || (ctx.context.special.values = {});
        }
        let arr;
        if (!Array.isArray(src)) {
            if (!src || !Array.isArray(src.value))
                return { output: '', height: 0 };
            group = src;
            arr = group.value;
            if (w.group) {
                groupNo = w.group.length > group.grouped ? w.group.length - group.grouped - 1 : false;
            }
        }
        else {
            arr = src;
        }
        if (w.header && (newPage || !state || !state.state || state.state.part === 'header' || state.state.part === 'group')) {
            const hctx = state && state.state && state.state.context && state.state.context.context;
            if (group) {
                const c = extend$1(ctx, { special: { source: group && group.grouped ? group.all : arr, level: group && group.level, grouped: groupNo !== false, group: group && group.group, values: (hctx && hctx.special || {}).values } });
                if (w.group && groupNo !== false && (!state || !state.state || state.state.part === 'group')) {
                    r = renderWidget(w.group[groupNo], extend$1(ctx, { value: group, special: { source: group && group.grouped ? group.all : arr, level: group && group.level, grouped: true, group: group.group } }), { x: 0, y, availableX: placement.availableX, maxX: placement.maxX, maxY: placement.maxY });
                    if (r) {
                        if (r.height > availableY) {
                            if (html)
                                html = `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`;
                            return { output: html, height: y, continue: { offset: 0, state: { part: 'group', src, current: 0, newPage: true } } };
                        }
                        else
                            availableY -= r.height;
                        html += r.output;
                        y += r.height;
                    }
                }
                if (w.groupHeaders && w.groupHeaders[group.grouped] && (!state || !state.state || !state.state.current) || newPage && w.headerPerPage !== false)
                    r = renderWidget(w.header, c, { x: 0, y, availableX: placement.availableX, maxX: placement.maxX, maxY: placement.maxY });
                else
                    r = { output: '', height: 0 };
                if (r.height > availableY)
                    return { output: `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`, height: y, continue: { offset: y, state: { part: 'header', src, current: 0, context: ctx, newPage: true } } };
                else
                    availableY -= r.height;
                html += r.output;
                y += r.height;
            }
            else {
                if (!state || newPage && w.headerPerPage !== false)
                    r = renderWidget(w.header, ctx, { x: 0, y, availableX: placement.availableX, maxX: placement.maxX, maxY: placement.maxY });
                else
                    r = { output: '', height: 0 };
                if (r.height > availableY)
                    return { output: `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`, height: y, continue: { offset: y, state: { part: 'header', src, current: 0, context: ctx, newPage: true } } };
                else
                    availableY -= r.height;
                html += r.output;
                y += r.height;
            }
        }
        let rctx = state && state.state && state.state.context || extend$1(ctx, { special: { source: group && group.grouped ? group.all : arr, level: group && group.level, grouped: groupNo !== false, group: group && group.group, values: {}, last: arr.length - 1, count: arr.length } });
        const elide = w.row && (isComputed(w.row.elide) ? evaluate(extend$1(rctx, { special: { placement, widget: w } }), w.row.elide.x) : w.row.elide);
        if (!state || !state.state || state.state.part !== 'footer') {
            let usedX = 0;
            let usedY = 0;
            let initY = y;
            if (!elide && !arr.length && w.alternate) {
                if (w.alternate) {
                    r = renderWidget(w.alternate, rctx, { x: usedX, y, availableX: availableX - usedX, maxX: placement.maxX, availableY, maxY: placement.maxY }, state ? state.child : undefined);
                    if (r.height > availableY)
                        return { output: html, height: 0, continue: { offset: 0, state: { part: 'body', src, current: 0, newPage: true } } };
                    else
                        availableY -= r.height;
                    html += r.output;
                    y += r.height;
                }
            }
            else {
                for (let i = (state && state.state && state.state.current) || 0; i < arr.length; i++) {
                    const c = group && group.grouped ?
                        extend$1(rctx, { value: arr[i], special: { index: i, values: {} } }) :
                        extend$1(rctx, { value: arr[i], special: { index: i } });
                    if (group && group.grouped) {
                        const s = (state && state.child) || { offset: 0, state: { current: 0, src: arr[i], part: 'group' } };
                        r = renderWidget(w, c, { x: 0, y, availableX: availableX - usedX, availableY, maxX: placement.maxX, maxY: placement.maxY }, s);
                    }
                    else {
                        if (elide) {
                            renderWidget(w.row, c, { x: 0, y: 0, availableX: placement.maxX, maxX: placement.maxX, availableY: placement.maxY, maxY: placement.maxY }, state ? state.child : undefined);
                            continue;
                        }
                        else {
                            r = renderWidget(w.row, c, { x: usedX, y, availableX: availableX - usedX, maxX: placement.maxX, availableY, maxY: placement.maxY }, state ? state.child : undefined);
                        }
                    }
                    if (state)
                        state.child = null;
                    if (r.width && r.width <= availableX - usedX && r.width !== availableX) {
                        usedX += r.width;
                        if (r.height > usedY) {
                            usedY = r.height;
                            if (r.height > availableY)
                                initY -= r.height;
                        }
                    }
                    else if (r.width && usedX && r.width > availableX - usedX) {
                        y += usedY;
                        initY = y;
                        availableY -= usedY;
                        usedY = 0;
                        usedX = 0;
                        i--;
                        continue;
                    }
                    if (r.height > availableY || r.cancel) {
                        if (initY === y && usedY)
                            y += usedY;
                        if (commit)
                            return { output: `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`, height: y, continue: { offset: y, state: { part: 'body', src, current: i, context: rctx, newPage: !group || groupNo === false }, child: r.continue } };
                        else
                            return { output: '', height: y, continue: { offset: y, state: { part: state && state.state && state.state.part || 'body', src, current: i, context: rctx, newPage: !group || groupNo === false }, child: r.continue } };
                    }
                    if (!usedY) {
                        y += r.height;
                        availableY -= r.height;
                    }
                    html += r.output;
                    commit = true;
                    if (r.continue) {
                        if (initY === y && usedY)
                            y += usedY;
                        return { output: `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`, height: y, continue: { offset: y, state: { part: 'body', src, current: i, context: rctx, newPage: !group || groupNo === false }, child: r.continue } };
                    }
                }
            }
            if (initY === y && usedY)
                y += usedY;
        }
        if (w.footer) {
            const fctx = (rctx && rctx.context) || (state && state.state && state.state.context && state.state.context.context);
            const c = extend$1(ctx, { special: { source: group && group.grouped ? group.all : arr, level: group && group.level, grouped: groupNo !== false, group: group && group.group, values: (fctx && fctx.special || {}).values } });
            if (group) {
                if (w.groupEnds && w.groupEnds[group.grouped])
                    r = renderWidget(w.footer, c, { x: 0, y, availableX: placement.availableX, maxX: placement.maxX, maxY: placement.maxY });
                else
                    r = { output: '', height: 0 };
            }
            else
                r = renderWidget(w.footer, c, { x: 0, y, availableX: placement.availableX, maxX: placement.maxX, maxY: placement.maxY });
            if (r.height > availableY)
                return { output: `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`, height: y, continue: { offset: y, state: { part: 'footer', src, current: 0, context: rctx, newPage: true } } };
            html += r.output;
            y += r.height;
        }
        return { output: `<div${styleClass(ctx, ['container', 'repeat'], style$2(w, placement, ctx, { computedHeight: y, container: true }))}>\n${html}</div>`, height: y };
    }, { container: true });
    registerRenderer('image', (w, ctx, placement) => {
        addStyle$1(ctx, 'image', `.image {position:absolute;box-sizing:border-box;} .image .inner {background-repeat:no-repeat;height:100%;}`);
        const fit = w.fit && typeof w.fit === 'object' ? evaluate(ctx, w.fit.x) : w.fit;
        if (fit === 'stretch') {
            return `<img src="${evaluate(ctx, w.url)}" ${styleClass(ctx, ['image'], style$2(w, placement, ctx))} />`;
        }
        else {
            return `<div ${styleClass(ctx, ['image'], style$2(w, placement, ctx))}><div ${styleClass(ctx, ['inner'], styleImage(fit), `background-image:url('${evaluate(ctx, w.url)}');`)}></div></div>`;
        }
    });
    registerRenderer('measured', (w, ctx, placement, state) => {
        addStyle$1(ctx, 'measured', `.measured {position:absolute;box-sizing:border-box;white-space:pre-wrap;font-family:serif;font-size:0.83rem;word-break:break-word;}`);
        const text = evaluate(ctx, w.text);
        const height = measure(text, getWidth(w, placement, ctx) || placement.availableX, ctx, w.font);
        if (!state && height > placement.availableY) {
            return { output: '', height: 0, continue: { state: {}, offset: 0 } };
        }
        else {
            let s = style$2(w, placement, ctx, { computedHeight: height, container: true });
            s[0] = `line-height:1em;` + s[0];
            return {
                height, output: `<span${styleClass(ctx, ['measured', 'label'], s)}>${escapeHTML(text)}</span>`
            };
        }
    });
    registerRenderer('html', (w, ctx, placement) => {
        addStyle$1(ctx, 'html', `.html {position:absolute;box-sizing:border-box;overflow:hidden;line-height:1rem;}`);
        const html = evaluate(extend$1(ctx, { parser: parse$3 }), w.html);
        return `<div${styleClass(ctx, ['html'], style$2(w, placement, ctx, { container: true }))}>${html}</div>`;
    });

    const decRE = /(\d)(?=(\d{3})+\.)/g;
    const intRE = /(\d)(?=(\d{3})+$)/g;
    const isNumRE = /^[-0-9\\.,]+$/;
    function number(v, dec = 2, group = ',', negative = 'sign') {
        v = typeof v !== 'number' ? parseFloat(v || '') : v;
        if (isNaN(v))
            return '';
        const neg = v < 0;
        v = v.toFixed(dec);
        if (dec === 0)
            v = v.replace(/\..*/, '');
        if (neg && negative !== 'sign')
            v = `(${negative === 'both' ? v : v.substr(1)})`;
        if (group)
            return v.replace(v.indexOf('.') === -1 ? intRE : decRE, `$1${group}`);
        else
            return v;
    }
    function dollar(v, alt, dec = 2, group = ',', sign = '$', negative = 'sign') {
        if (v != null && isNumRE.test(v)) {
            if (!isNaN(+v))
                return `${sign}${number(v, dec, group, negative)}`;
            else
                return alt !== undefined ? alt : v;
        }
        else {
            return alt !== undefined ? alt : v;
        }
    }
    function phone(v) {
        if (!v)
            v = '';
        if (typeof v !== 'string')
            v = v.toString();
        v = v || '';
        v = v.replace(/[^\d]/g, '');
        if (v.length === 7)
            return `${v.substr(0, 3)}-${v.substr(3, 4)}`;
        else if (v.length === 10)
            return `(${v.substr(0, 3)}) ${v.substr(3, 3)}-${v.substr(6, 4)}`;
        else if (v.length === 11)
            return `${v[0]}-${v.substr(1, 3)}-${v.substr(4, 3)}-${v.substr(7, 4)}`;
        else
            return v;
    }
    const dateRE = /y+|M+|d+|E+|H+|m+|s+|k+|h+|a+|S+|z+/g;
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    let dateDefault;
    function date$1(d, fmt) {
        if (!d)
            return '';
        let Y, M, D, DD, H, MM, S, SS, Z;
        // convert an exact range to numbers
        if (typeof d === 'object' && 'f' in d && Array.isArray(d.f)) {
            const f = d.f, l = f.length, e = d.e;
            Y = f[0], M = l > 1 && f[1] != null ? f[1] : e ? 11 : 0, D = l > 2 && f[2] != null ? f[2] : e ? 0 : 1,
                H = l > 3 && f[3] != null ? f[3] : e ? 23 : 0, MM = l > 4 && f[4] != null ? f[4] : e ? 59 : 0, S = l > 5 && f[5] != null ? f[5] : e ? 59 : 0,
                SS = l > 6 && f[6] != null ? f[6] : e ? 999 : 0;
            let dt = new Date(Y, M, D || 1, H, MM, S, SS);
            Z = l > 7 && f[7] != null ? -f[7] : dt.getTimezoneOffset();
            if (!D) {
                dt.setMonth(M + 1);
                dt.setDate(0);
                D = dt.getDate();
            }
            DD = dt.getDay();
        }
        else {
            if (typeof d === 'string')
                d = new Date(d);
            if (Object.prototype.toString.call(d) !== '[object Date]')
                return '';
            if (isNaN(d))
                return '';
            const v = d;
            Y = v.getFullYear(), M = v.getMonth(), D = v.getDate(), DD = v.getDay(), H = v.getHours(), MM = v.getMinutes(), S = v.getSeconds(), SS = v.getMilliseconds(), Z = v.getTimezoneOffset();
        }
        if (!fmt)
            fmt = dateDefault || 'yyyy-MM-dd';
        return fmt.replace(dateRE, m => {
            if (m[0] === 'y') {
                return m.length <= 2 ? (`${Y}`).substr(2, 2) : `${Y}`;
            }
            else if (m[0] === 'M') {
                if (m.length === 1)
                    return `${M + 1}`;
                else if (m.length === 2)
                    return M < 9 ? `0${M + 1}` : `${M + 1}`;
                else if (m.length === 3)
                    return months[M].substr(0, 3);
                else
                    return months[M];
            }
            else if (m[0] === 'd') {
                if (m.length === 1)
                    return `${D}`;
                else if (m.length === 2)
                    return D <= 9 ? `0${D}` : `${D}`;
                else
                    return ordinal(D);
            }
            else if (m[0] === 'E') {
                if (m.length === 1)
                    return `${DD + 1}`;
                else if (m.length === 2)
                    return days[DD].substr(0, 3);
                else
                    return days[DD];
            }
            else if (m[0] === 'H') {
                return m.length === 1 ? `${H}` : H <= 9 ? `0${H}` : `${H}`;
            }
            else if (m[0] === 'm') {
                return m.length === 1 ? `${MM}` : MM <= 9 ? `0${MM}` : `${MM}`;
            }
            else if (m[0] === 's') {
                return m.length === 1 ? `${S}` : S <= 9 ? `0${S}` : `${S}`;
            }
            else if (m[0] === 'S') {
                const ms = SS;
                if (m.length === 1)
                    return `${ms}`;
                return ms < 10 ? `00${ms}` : ms < 100 ? `0${ms}` : `${ms}`;
            }
            else if (m[0] === 'k' || m[0] === 'h') {
                let r = `${H % 12}`;
                if (r === '0')
                    r = '12';
                return `${r}`;
            }
            else if (m[0] === 'a') {
                return H > 11 ? 'PM' : 'AM';
            }
            else if (m[0] === 'z') {
                let min = 0 - Z;
                const bit = min < 0 ? '-' : '+';
                min = Math.abs(min);
                let r = min;
                if (m.length === 1) {
                    r = Math.floor(min / 60);
                }
                else if (m.length === 2) {
                    const mm = min % 60;
                    const h = Math.floor(min / 60);
                    return `${bit}${h < 10 ? '0' : ''}${h}${mm < 10 ? '0' : ''}${mm}`;
                }
                else if (m.length === 3) {
                    const mm = min % 60;
                    const h = Math.floor(min / 60);
                    return `${bit}${h < 10 ? '0' : ''}${h}:${mm < 10 ? '0' : ''}${mm}`;
                }
                else
                    r = min;
                return `${bit}${r}`;
            }
        });
    }
    date$1.setDefault = function (format) {
        dateDefault = format;
    };
    function ordinal(num, group) {
        num = number(num, 0, group);
        let n = `${num}`;
        n = n.substr(-2, 2);
        if (n.length > 1 && n[0] === '1')
            return `${num}th`;
        switch (n[1] || n[0]) {
            case '1':
                return `${num}st`;
            case '2':
                return `${num}nd`;
            case '3':
                return `${num}rd`;
            default:
                return `${num}th`;
        }
    }

    const checkIdent = new RegExp(`[${endRef.split('').map(v => `\\${v}`).join('')}]`);
    let _noSym = false;
    let _key = false;
    let _sexprops = false;
    let _listcommas = false;
    let _noarr = false;
    let _noobj = false;
    let _tpl = false;
    let _tplmode = false;
    let _noindent = false;
    let _listwrap = { array: 60, union: 60, args: 60, keys: 60 };
    let _html = false;
    let _nochecks = false;
    let _level = 0;
    let _first = false;
    const deepops = ['===', '!==', 'deep-is', 'deep-is-not'];
    const binops$1 = deepops.concat(['**', '*', '/%', '/', '%', '+', '-', '>=', 'gte', '>', 'gt', '<=', 'lte', '<', 'lt', 'in', 'like', 'ilike', 'not-in', 'not-like', 'not-ilike', 'contains', 'does-not-contain', 'is', 'is-not', '==', '!=', 'strict-is', 'strict-is-not', 'and', '&&', 'or', '||', '??']);
    const unops = ['+', 'not'];
    const precedence = {
        '**': 1,
        '*': 2, '/%': 2, '/': 2, '%': 2,
        '+': 3, '-': 3,
        '>=': 4, '>': 4, '<=': 4, '<': 4, in: 4, like: 4, ilike: 4, 'not-in': 4, 'not-like': 4, 'not-ilike': 4, 'contains': 4, 'does-not-contain': 4, gt: 4, gte: 4, lt: 4, lte: 4,
        'is': 5, 'is-not': 5, '==': 5, '!=': 5, 'strict-is': 5, 'strict-is-not': 5, 'deep-is': 5, 'deep-is-not': 5, '===': 5, '!==': 5,
        'and': 6, '&&': 6,
        'or': 7, '||': 7, '??': 7,
    };
    const call_op = /^[-a-zA-Z_$0-9]/;
    function stringify(value, opts) {
        opts = opts || {};
        _noSym = opts.noSymbols;
        _sexprops = opts.SExprOps;
        _listcommas = opts.listCommas;
        _noarr = opts.SExprOps && opts.noArrayLiterals;
        _noobj = opts.SExprOps && opts.noObjectLiterals;
        _key = false;
        _tpl = _tplmode = opts.template;
        _noindent = opts.noIndent;
        _level = 0;
        _first = true;
        if ('listWrap' in opts) {
            const o = opts.listWrap;
            if (typeof o === 'boolean')
                _listwrap = !o ? { array: 0, union: 0, args: 0, keys: 0 } : { array: 1, union: 1, args: 1, keys: 1 };
            else if (typeof o === 'number')
                _listwrap = { array: o, union: o, args: o, keys: o };
            else {
                const b = !o.base ? 0 : o.base === true ? 1 : o.base;
                _listwrap = Object.keys(_listwrap).reduce((a, c) => (a[c] = c in o && o[c] != null ? (!o[c] ? 0 : o[c] === true ? 1 : o[c]) : b, a), {});
            }
        }
        else
            _listwrap = { array: 60, union: 60, args: 60, keys: 60 };
        _html = opts.htmlSafe;
        _nochecks = opts.noChecks;
        if (!_sexprops && typeof value === 'object' && value && 'op' in value && value.op === 'block')
            return stringifyRootBlock(value);
        else
            return _stringify(value);
    }
    function padl(v, pad, len) {
        v = `${v}`;
        if (!pad)
            return v;
        for (let i = v.length; i < len; i++) {
            v = pad + v;
        }
        return v;
    }
    function fill(char, len) {
        let res = '';
        for (let i = 0; i < len; i++)
            res += char;
        return res;
    }
    function _stringify(value) {
        if (typeof value === 'string')
            return value;
        let stringed;
        if (value == null || typeof value === 'number' || typeof value === 'boolean')
            return `${value}`;
        if (_tpl && ('op' in value || 'r' in value)) {
            if ('op' in value) {
                if (value.op === 'if' || value.op === 'with' || value.op === 'unless' || value.op === 'each') {
                    stringed = stringifyTemplateBlock(value);
                }
                else if (value.op === 'case') {
                    stringed = stringifyTemplateCase(value);
                }
                else if (value.op) {
                    if (value.op === '+')
                        return value.args.map(a => _stringify(a)).join('');
                    else {
                        _tpl = false;
                        const res = `{{${_stringify(value.op === 'string' ? value.args[0] : value)}}}`;
                        _tpl = true;
                        stringed = res;
                    }
                }
            }
            else {
                _tpl = false;
                const res = `{{${_stringify(value)}}}`;
                _tpl = true;
                stringed = res;
            }
        }
        else if ('r' in value) {
            if (typeof value.r === 'string')
                stringed = /^[0-9]/.test(value.r) ? `.${value.r}` : value.r;
            else {
                const r = value.r;
                stringed = `${fill('^', r.u || 0)}${r.p || ''}${r.k.map((p, i) => {
                if (typeof p === 'string' && checkIdent.test(p))
                    return `${i ? '' : '_'}[${_stringify({ v: p })}]`;
                else if (typeof p === 'string' || typeof p === 'number')
                    return `${i ? '.' : ''}${p}`;
                else
                    return `[${_stringify(p)}]`;
            }).join('')}`;
            }
        }
        else if ('op' in value) {
            stringed = stringifyOp(value);
        }
        else if (isApplication(value)) {
            const arrow = ((_tplmode && _html !== false) || _html) ? '\\' : '>';
            if ('n' in value)
                stringed = `|${value.n.join(_listcommas ? ', ' : ' ')}| =${arrow} ${_stringify(value.a)}`;
            else
                stringed = `=${arrow}${_stringify(value.a)}`;
        }
        else if ('v' in value) {
            stringed = stringifyLiteral(value);
        }
        else if (isDateRel(value)) {
            stringed = stringifyDate(value);
        }
        else if (isTimespan(value)) {
            stringed = stringifyTimespan(value);
        }
        if ('c' in value && value.c.length)
            stringed = (_first ? '' : '\n') + value.c.map(c => `${padl('', '  ', _level)}// ${c}\n`).join('') + `${padl('', '  ', _level)}${stringed}`;
        return stringed;
    }
    function stringifyBinopArg(op, arg, pos) {
        let res;
        if (op === '**' && pos === 1 && typeof arg !== 'string' && 'op' in arg && arg.op === '**')
            res = `(${_stringify(arg)})`;
        if (typeof arg !== 'string' && 'op' in arg) {
            if (binops$1.includes(arg.op) && precedence[arg.op] > precedence[op])
                res = `(${_stringify(arg)})`;
            else if (arg.op === 'if' || arg.op === 'unless' || arg.op === 'case' || arg.op === 'fmt' || arg.op === 'format')
                res = `(${_stringify(arg)})`;
            else
                res = _stringify(arg);
        }
        else
            res = _stringify(arg);
        return res;
    }
    function findNestedStringOpL(op, value) {
        if (value.args && value.args.find(a => typeof a === 'object' && typeof a.v === 'string'))
            return true;
        if (!value.args || !value.args.length)
            return false;
        const left = value.args[0];
        if (typeof left === 'object' && 'op' in left && left.op === op)
            return findNestedStringOpL(op, left);
        return false;
    }
    function flattenNestedBinopsL(op, value, agg = []) {
        if (value.args && value.args.length) {
            let i = 0;
            for (; i < value.args.length; i++) {
                if (typeof value.args[i] === 'object' && typeof value.args[i].v === 'string')
                    agg.push(value.args[i]);
                else
                    break;
            }
            const left = value.args[i];
            if (typeof left === 'object' && 'op' in left && left.op === op)
                flattenNestedBinopsL(op, left, agg);
            else
                agg.push(left);
            agg.push.apply(agg, value.args.slice(i + 1));
        }
        return agg;
    }
    function stringifyOp(value) {
        let op = value.op;
        if ((_tplmode && _html !== false) || _html) {
            if (op === '>')
                op = 'gt';
            else if (op === '>=')
                op = 'gte';
            else if (op === '<')
                op = 'lt';
            else if (op === '<=')
                op = 'lte';
            else if (op === '&&')
                op = 'and';
        }
        if (!_noarr && op === 'array' && !value.opts) {
            return wrapArgs('[', value.args, value.opts, ']');
        }
        else if (!_noobj && op === 'object' && value.args && !value.args.find((a, i) => i % 2 === 0 && (typeof a === 'string' || !('v' in a) || typeof a.v !== 'string'))) {
            if (!value.args || !value.args.length)
                return '{}';
            return wrapArgs('{', value.args, value.opts, '}', 2);
        }
        else if (_sexprops) {
            if (!value.args || !value.args.length)
                return `(${op})`;
            return wrapArgs(`(${op} `, value.args, value.opts, ')', 0);
        }
        else if (op === 'if' || op === 'unless' && value.args && value.args.length > 2) {
            return stringifyIf(value);
        }
        else if (op === 'case' && value.args && value.args.length > 2) {
            return stringifyCase(value);
        }
        else if (op === '+' && value.args && value.args.length > 1 && findNestedStringOpL(op, value)) {
            const args = flattenNestedBinopsL(op, value);
            return `'${args.map(a => typeof a !== 'string' && 'v' in a && typeof a.v === 'string' ? a.v.replace(/[{']/g, v => `\\${v}`).replace(/\$$/, '\\$') : `{${_stringify(a)}}`).join('')}'`;
        }
        else if ((op === 'fmt' || op === 'format') && value.args && typeof value.args[1] === 'object' && 'v' in value.args[1] && typeof value.args[1].v === 'string') {
            const val = value.args[0];
            let vs = _stringify(val);
            if (typeof val !== 'string' && 'op' in val && (binops$1.includes(val.op) || unops.includes(val.op)))
                vs = `(${vs})`;
            if (value.opts)
                return `${vs}#${[value.args[1].v]}${wrapArgs('(', value.args.slice(2), value.opts, ')')}`;
            else
                return `${vs}#${[value.args[1].v].concat(value.args.slice(2).map(a => _stringify(a))).join(',')}`;
        }
        else if (binops$1.includes(op) && value.args && value.args.length > 1 && !value.opts && (!deepops.includes(op) || value.args.length === 2)) {
            let parts = value.args.map((a, i) => stringifyBinopArg(op, a, i === 0 ? 1 : 2));
            const long = parts.find(p => p.length > 30 || ~p.indexOf('\n')) || parts.reduce((a, c) => a + c.length, 0) && parts.length > 2;
            const split = _noindent ? ' ' : long ? `\n${padl('', '  ', _level + 1)}` : ' ';
            if (split.length > 1 || (!_noindent && long))
                parts = [parts[0]].concat(parts.slice(1).map(p => indentAll('  ', p)));
            return `${parts[0]} ${op}${split}${parts.slice(1).join(` ${op}${split.length > 1 ? `${split}` : split}`)}`;
        }
        else if (unops.includes(op) && value.args && value.args.length === 1) {
            const arg = value.args[0];
            if (typeof arg !== 'string' && 'op' in arg && (binops$1.includes(arg.op) || unops.includes(arg.op)))
                return `${op}(${_stringify(arg)})`;
            else
                return `${op}${call_op.test(op) ? ' ' : ''}${_stringify(arg)}`;
        }
        else if (op === 'block') {
            if (!value.args || !value.args.length)
                return '';
            _level++;
            const _f = _first;
            const parts = value.args.map((a, i) => (_first = i === 0, _stringify(a)));
            _first = _f;
            let split = _noindent ? '' : `\n${padl('', '  ', _level)}`;
            _level--;
            if (parts.length === 1 && !~parts[0].indexOf('\n'))
                return `{ ${parts[0]} }`;
            return `{${split}${parts.join(split)}\n${padl('', '  ', _level)}}`;
        }
        else if ((op === 'let' || op === 'set') && value.args && value.args.length === 2) {
            let path;
            let arg = value.args[0];
            if (typeof arg === 'string')
                path = arg;
            else if ('v' in arg && typeof arg.v === 'string')
                path = arg.v;
            else if ('v' in arg && typeof arg.v === 'object' && 'k' in arg.v)
                path = _stringify({ r: arg.v });
            else
                path = _stringify(arg);
            return `${op} ${path} = ${_stringify(value.args[1])}`;
        }
        else if (op === 'get' && value.args.length === 2 && typeof value.args[1] === 'object' && 'v' in value.args[1] && typeof value.args[1].v === 'object' && 'k' in value.args[1].v) {
            return `${_stringify(value.args[0])}${_stringify({ r: { k: ['r'].concat(value.args[1].v.k) } }).substr(1)}`;
        }
        else if (call_op.test(op)) {
            return wrapArgs(`${op}(`, value.args || [], value.opts, ')', 0);
        }
        else {
            if (!value.args || !value.args.length)
                return `(${op})`;
            return wrapArgs(`(${op} `, value.args, value.opts, ')', 0);
        }
    }
    function stringifyRootBlock(block) {
        if (!block.args || !block.args.length)
            return '';
        return block.args.map((a, i) => (_first = i === 0, _stringify(a))).join('\n');
    }
    function stringifyLiteral(value) {
        if (value.s === 1) {
            _level++;
            const res = stringifySchema(value.v);
            _level--;
            if (~res.indexOf('\n')) {
                const level = _noindent ? ' ' : `\n${padl('', '  ', _level)}`;
                return `@[${level}${level !== ' ' ? '  ' : ''}${res}${level}]`;
            }
            else
                return `@[${res}]`;
        }
        else if (typeof value.v === 'string') {
            if (_tpl)
                return value.v.replace(/\\(.)/g, '\\\\$1').replace(/{{/g, '\\{{');
            if ((_key || !_noSym) && !checkIdent.test(value.v) && value.v.length)
                return `${_key ? '' : ':'}${value.v}`;
            else if (!~value.v.indexOf("'"))
                return `'${value.v.replace(/[{']/g, v => `\\${v}`).replace(/\${/g, '\\${')}'`;
            else if (!~value.v.indexOf('`'))
                return `\`${value.v.replace(/[{`]/g, v => `\\${v}`).replace(/\${/g, '\\${')}\``;
            else if (!~value.v.indexOf('"'))
                return `"${value.v}"`;
            else
                return `'${value.v.replace(/['{]/g, s => `\\${s}`).replace(/\${/g, '\\${')}'`;
        }
        else if (typeof value.v === 'number' || typeof value.v === 'boolean' || value.v === 'true' || value.v === 'false') {
            return `${value.v}`;
        }
        else if (value.v === 'undefined' || value.v === undefined) {
            return 'undefined';
        }
        else if (value.v === 'null' || value.v === null) {
            return 'null';
        }
        else if (Array.isArray(value.v)) {
            if (_noarr)
                return wrapArgs('(array', value.v.map(v => ({ v })), null, ')', null, 'array');
            return wrapArgs('[', value.v.map(v => ({ v })), null, ']', null, 'array');
        }
        else if (typeof value.v === 'object') {
            if (isDateRel(value.v)) {
                return stringifyDate(value.v);
            }
            else {
                return wrapArgs('{', Object.entries(value.v).reduce((a, c) => (a.push({ v: c[0] }, { v: c[1] }), a), []), null, '}', 2, 'keys');
            }
        }
    }
    function offsetToTimezone(dir, offset) {
        if (offset == null)
            return '';
        offset = offset * dir;
        const o = Math.abs(offset);
        const h = Math.floor(o / 60);
        const m = o % 60;
        if (!offset)
            return 'Z';
        else
            return `${offset > 0 ? '-' : '+'}${h}${m ? `:${padl(m, '0', 2)}` : ''}`;
    }
    const spanKeys = ['w', 'd', 'h', 'mm', 's'];
    const spanExact = ['y', 'm', 'd', 'h', 'mm', 's', 'ms'];
    function stringifyDate(value) {
        let str = '';
        if (value instanceof Date) { // date object
            const y = value.getFullYear();
            const m = value.getMonth() + 1;
            const d = value.getDate();
            const h = value.getHours();
            const mn = value.getMinutes();
            const s = value.getSeconds();
            const ms = value.getMilliseconds();
            str = `${y}-${padl(m, '0', 2)}-${padl(d, '0', 2)}`;
            if (h + mn + s + ms > 0) {
                str += ` ${padl(h, '0', 2)}:${padl(mn, '0', 2)}`;
                if (s + ms > 0) {
                    str += `:${padl(s, '0', 2)}`;
                    if (ms > 0)
                        str += `.${padl(ms, '0', 3)}`;
                }
            }
            return `#${str}${offsetToTimezone(1, value.getTimezoneOffset())}#`;
        }
        else if (Array.isArray(value.f)) { // precise date
            const a = value.f;
            str = `${a[0]}`;
            if (a[1] != null)
                str += `-${padl(a[1] + 1, '0', 2)}`;
            if (a[2] != null)
                str += `-${padl(a[2], '0', 2)}`;
            if (a[3] != null)
                str += ` ${padl(a[3], '0', 2)}`;
            if (a[4] != null)
                str += `:${padl(a[4], '0', 2)}`;
            if (a[5] != null)
                str += `:${padl(a[5], '0', 2)}`;
            if (a[6] != null)
                str += `.${padl(a[6], '0', 3)}`;
            if (a[7] != null)
                str += ` ${offsetToTimezone(-1, a[7])}`;
            if ('e' in value && value.e)
                str += '<';
            return `#${str}#`;
        }
        else if (value.f === 'n') { // relative point in time
            if (Array.isArray(value.o)) { // inconsistent units
                spanExact.forEach((k, i) => {
                    if (value.o[i] != null)
                        str += `${value.o[i]}${k}`;
                });
                str += `${'d' in value && value.d === -1 ? ' ago' : ' from now'}${offsetToTimezone(-1, value.z)}`;
                return `#${str}#`;
            }
            else if (typeof value.o === 'number') { // milliseconds
                if (value.o === 0)
                    return `#now#`;
                let rem = Math.abs(value.o);
                spanKeys.forEach(k => {
                    const t = Math.floor(rem / timespans[k]);
                    rem = rem % timespans[k];
                    if (t)
                        str += `${t}${k}`;
                });
                if (rem)
                    str += `${rem}ms`;
                return `#${str}${value.o < 0 ? ' ago' : value.o > 0 ? ' from now' : ''}${offsetToTimezone(-1, value.z)}#`;
            }
        }
        else if ('d' in value && value.d === 1 && value.o === 0) { // span to date
            str = `#${value.f === 'w' ? 'week' : value.f === 'm' ? 'month' : 'year'} to date${offsetToTimezone(-1, value.z)}${value.e && '>' || ''}#`;
        }
        else if ('t' in value && Array.isArray(value.t)) { // time on relative day
            const a = value.t;
            str = `${value.o < 0 ? 'yesterday' : value.o > 0 ? 'tomorrow' : 'today'} at `;
            if (!a[0] && !a[1] && !a[2] && !a[3])
                str += 'midnight';
            else if (a[0] === 12 && !a[1] && !a[2] && !a[3])
                str += 'noon';
            else {
                str += a[0];
                if (a[1] != null)
                    str += `:${padl(a[1], '0', 2)}`;
                if (a[2] != null)
                    str += `:${padl(a[2], '0', 2)}`;
                if (a[3] != null)
                    str += `.${padl(a[3], '0', 3)}`;
            }
            return `#${str}${offsetToTimezone(-1, a[4])}${value.e ? '>' : ''}#`;
        }
        else if (!('t' in value) && !('d' in value) && !Array.isArray(value.f)) { // relative span
            const v = value;
            if (v.f === 'd') {
                str += `${v.o < 0 ? 'yesterday' : v.o > 0 ? 'tomorrow' : 'today'}`;
            }
            else {
                str += `${v.o < 0 ? 'last' : v.o > 0 ? 'next' : 'this'} ${v.f === 'w' ? 'week' : v.f === 'm' ? 'month' : 'year'}`;
            }
            return `#${str}${offsetToTimezone(-1, v.z)}${v.e ? '>' : ''}#`;
        }
        return str;
    }
    function stringifyTimespan(value) {
        if (typeof value === 'number' || isTimespanMS(value)) {
            let str = '';
            let rem = Math.abs(timeSpanToNumber(value));
            spanKeys.forEach(k => {
                const t = Math.floor(rem / timespans[k]);
                rem = rem % timespans[k];
                if (t)
                    str += `${t}${k}`;
            });
            if (rem)
                str += `${rem}ms`;
            return `#${str}#`;
        }
        else {
            const o = value.d;
            let str = '';
            spanExact.forEach((k, i) => {
                if (o[i] != null)
                    str += `${o[i]}${k}`;
            });
            return `#${str}#`;
        }
    }
    const leadingSpace = /^\s+/;
    const allLeadingSpace = /^\s+/gm;
    function outdentAll(amount, str) {
        if (amount)
            return str.replace(allLeadingSpace, s => s.substr(amount.length));
        else
            return str;
    }
    function indentAll(amount, str) {
        return str.replace(/\n/gm, `\n${amount}`);
    }
    function wrapArgs(open, args, opts, close, keyMod, wrapSetting) {
        if ((!args || !args.length) && !opts)
            return `${open}${close}`;
        _level++;
        const _f = _first;
        let parts;
        if (keyMod) {
            parts = [];
            for (let i = 0; i < args.length; i++) {
                if (i % keyMod === 0) {
                    _key = true;
                    parts.push(_stringify(args[i]) + ':');
                    _key = false;
                }
                else {
                    _level++;
                    _first = i === 1;
                    const res = _stringify(args[i]);
                    if (res[0] === '\n')
                        parts[parts.length - 1] += ' ' + res.replace(leadingSpace, '');
                    else
                        parts[parts.length - 1] += res;
                    _level--;
                }
            }
        }
        else {
            parts = args.map((a, i) => {
                _first = i === 0;
                return _stringify(a);
            });
        }
        if (opts && typeof opts === 'object') {
            const args = 'op' in opts && opts.args ? opts.args : 'v' in opts ? Object.entries(opts.v).reduce((a, c) => (a.push({ v: c[0] }, { v: c[1] }), a), []) : [];
            for (let i = 0; i < args.length; i++) {
                if (i % 2 === 0) {
                    _key = true;
                    parts.push(_stringify(args[i]) + ':');
                    _key = false;
                }
                else {
                    _level++;
                    _first = i === 1;
                    const res = _stringify(args[i]);
                    if (res[0] === '\n')
                        parts[parts.length - 1] += ' ' + res.replace(leadingSpace, '');
                    else
                        parts[parts.length - 1] += res;
                    _level--;
                }
            }
        }
        _level--;
        _first = _f;
        let join = _listcommas ? ', ' : ' ';
        if (_noindent || (parts.length == 1 && !~parts[0].indexOf('\n')))
            return `${open}${parts.join(join)}${close}`;
        let wrap = _listwrap[wrapSetting || 'args'];
        const base = parts.join(_listcommas ? ', ' : ' ');
        if (!wrap && ~base.indexOf('\n'))
            wrap = 1;
        if (wrap === 1 && _listcommas)
            join = ',\n';
        const level = padl('', '  ', _level);
        if (!wrap)
            return `${open}${base}${close}`;
        else if (wrap === 1)
            return `${open}\n${parts.map(p => `${level}  ${p}`).join(join)}\n${level}${close}`;
        if (base.length <= wrap)
            return `${open}${base}${close}`;
        let res = `${open}`;
        let str = '';
        const last = parts.length - 1;
        for (let i = 0; i < parts.length; i++) {
            if (~parts[i].indexOf('\n')) {
                if (str)
                    res += str;
                res += `\n${parts[i][0] === ' ' ? '' : level + '  '}${parts[i]}${i !== last ? join : ''}`;
                str = '';
                continue;
            }
            if (!str)
                str += `\n${level}  `;
            str += `${parts[i]}${i !== last ? join : ''}`;
            if (str.length >= wrap) {
                res += str;
                str = '';
            }
        }
        if (str)
            res += str;
        return `${res}\n${level}${close}`;
    }
    function isBlock(v) {
        return typeof v === 'object' && 'op' in v && v.op === 'block';
    }
    function stringifyIf(op) {
        if (!op.args || op.args.length < 2)
            return 'false';
        let str = '';
        const last = op.args.length - 1;
        const block = !!op.args.find((p, i) => (i % 2 === 1 || i === last) && isBlock(p));
        _level++;
        const parts = op.args.map((a, i) => _stringify(block && (i % 2 === 1 || i === last) && !isBlock(a) ? { op: 'block', args: [a] } : a));
        _level--;
        const long = parts.find(p => p.length > 30 || ~p.indexOf('\n')) || '';
        let split = _noindent ? '' : parts.length > 3 || long ? `\n${padl('', '  ', _level)}` : '';
        const cindent = long && `${split}  ` || ' ';
        split = split || ' ';
        for (let i = 0; i <= last; i++) {
            if (i === 0) {
                if (block)
                    str += `if ${parts[i++]} ${outdentAll('  ', parts[i]).trimLeft()}`;
                else {
                    const cond = parts[i++];
                    str += `if ${cond}${~cond.indexOf('\n') ? split : ' '}then${cindent}${parts[i].trimLeft()}`;
                }
            }
            else if (i === last) {
                if (block)
                    str = str.trimRight() + ` else ${outdentAll('  ', parts[i]).trimLeft()}`;
                else
                    str += `${split}else${cindent}${parts[i].trimLeft()}`;
            }
            else {
                if (block)
                    str = str.trimRight() + ` elif ${parts[i++]} ${outdentAll('  ', parts[i]).trimLeft()}`;
                else
                    str += `${split}elif ${parts[i++]} then${cindent}${parts[i].trimLeft()}`;
            }
        }
        if (!block && _level)
            str += `${split}end`;
        return str;
    }
    const caseRE = /@case\b/g;
    function stringifyCase(op) {
        if (!op.args || op.args.length < 2)
            return 'false';
        let str = '';
        const last = op.args.length - 1;
        const block = !!op.args.find((p, i) => ((i > 1 && i % 2 === 0) || i === last) && isBlock(p));
        _level++;
        const parts = op.args.map((a, i) => {
            let res;
            if (i !== 0)
                _level++;
            if (block && (i > 1 && i % 2 === 0 || i === last)) {
                res = _stringify(isBlock(a) ? a : { op: 'block', args: [a] });
            }
            else if (i % 2 === 0 || i === last) {
                res = _stringify(a);
            }
            else {
                res = typeof a === 'object' && 'op' in a ? _stringify(a).replace(caseRE, '_') : _stringify(a);
            }
            if (i !== 0)
                _level--;
            return res;
        });
        _level--;
        const long = parts.find(p => p.length > 30 || ~p.indexOf('\n')) || '';
        let split = _noindent ? '' : parts.length > 3 || long ? `\n${padl('', '  ', _level)}` : '';
        const wsplit = split ? `${split}  ` : ' ';
        const cindent = long && `${wsplit}  ` || ' ';
        split = split || ' ';
        for (let i = 0; i <= last; i++) {
            if (i === 0) {
                if (block)
                    str += `case ${parts[i]}`;
                else
                    str += `case ${parts[i]}`;
            }
            else if (i === last) {
                if (block)
                    str = str.trimRight() + wsplit + `else ${outdentAll('  ', parts[i]).trimLeft()}`;
                else
                    str += `${wsplit}else${cindent}${parts[i].trimLeft()}`;
            }
            else {
                if (block)
                    str = str.trimRight() + wsplit + `when ${parts[i++]} ${outdentAll('  ', parts[i]).trimLeft()}`;
                else {
                    const cond = parts[i++];
                    str += `${wsplit}when ${cond}${~cond.indexOf('\n') ? wsplit : ' '}then${cindent}${parts[i].trimLeft()}`;
                }
            }
        }
        if (!block && _level)
            str += `${split}end`;
        return str;
    }
    function stringifyTemplateBlock(op) {
        _tpl = false;
        const cond = _stringify(op.args[0]);
        _tpl = true;
        const first = _stringify(op.args[1]);
        let res = `{{${op.op} ${cond}}}${op.op === 'with' || op.op === 'each' ? first.slice(2) : first}`;
        if (op.op === 'unless')
            return `${res}{{/}}`;
        for (let i = 2; i < op.args.length; i++) {
            if (i + 1 >= op.args.length) {
                const arg = op.args[i];
                if (typeof arg === 'object' && 'v' in arg && arg.v === '')
                    continue;
                else
                    res += `{{else}}${_stringify(arg)}`;
            }
            else {
                _tpl = false;
                res += `{{elseif ${_stringify(op.args[i++])}}}`;
                _tpl = true;
                res += _stringify(op.args[i]);
            }
        }
        res += '{{/}}';
        return res;
    }
    function stringifyTemplateCase(op) {
        const last = op.args.length - 1;
        const parts = op.args.map((a, i) => {
            _tpl = true;
            if (i === 0 || i % 2 === 1)
                _tpl = false;
            if (i === last)
                _tpl = true;
            return typeof a === 'object' && 'op' in a ? _stringify(a).replace(caseRE, '_') : _stringify(a);
        });
        _tpl = true;
        let res = `{{${op.op} ${parts[0]} when ${parts[1]}}}`;
        for (let i = 2; i <= last; i++) {
            if (i === last)
                res += `{{else}}${parts[i]}`;
            else if (i % 2 === 1)
                res += `{{when ${parts[i]}}}`;
            else
                res += parts[i];
        }
        res += '{{/}}';
        return res;
    }
    function stringifySchema(schema, noChecks) {
        if (noChecks !== undefined)
            _nochecks = noChecks;
        if (!schema)
            return 'any';
        const t = schema.type;
        const ts = schema.types;
        let strs;
        let fin = '', open = '', close = '', join = '';
        let wrap = _listwrap.array;
        switch (t) {
            case 'object':
            case 'object[]':
                const arr = !!~t.indexOf('[]');
                if ((!schema.fields || !schema.fields.length) && !schema.rest) {
                    fin = `{}${arr ? '[]' : ''}`;
                    break;
                }
                wrap = _listwrap.keys;
                _level++;
                strs = schema.fields ? schema.fields.map((f, i) => {
                    const str = stringifySchema(f);
                    return (f.desc && f.desc.length ? (i === 0 ? '' : `\n${padl('', '  ', _level)}`) + f.desc.map(c => `// ${c}`).join(`\n${padl('', '  ', _level)}`) + `\n${padl('', '  ', _level)}` : '') + `${f.name}${f.required ? '' : '?'}: ${str}`;
                }) : [];
                if (schema.rest)
                    strs.push(`...: ${stringifySchema(schema.rest)}`);
                _level--;
                open = '{';
                close = `}${arr ? '[]' : ''}`;
                join = ', ';
                break;
            case 'union':
            case 'union[]':
                if (~t.indexOf('[]'))
                    open = 'Array<', close = '>';
                else if (schema.checks && schema.checks.length)
                    open = '(', close = ')';
                if (open)
                    _level++;
                strs = ts.map(u => stringifySchema(u));
                wrap = _listwrap.union;
                join = strs.length > 6 || strs.find(s => ~s.indexOf('\n')) ? ' | ' : '|';
                if (open)
                    _level--;
                break;
            case 'literal':
                if (typeof schema.literal === 'string')
                    fin = `'${schema.literal.replace(/'/g, '\\\'')}'`;
                else
                    fin = `${schema.literal}`;
                break;
            case 'tuple':
            case 'tuple[]':
                if (!t || t.length === 0) {
                    fin = '[]';
                    break;
                }
                _level++;
                open = '[', close = `]${~t.indexOf('\n') ? '[]' : ''}`;
                join = ', ';
                strs = ts.map(t => stringifySchema(t));
                _level--;
                break;
            default:
                fin = schema.ref || t || 'any';
                if (schema.ref && t === 'array')
                    fin += '[]';
                break;
        }
        let defs;
        const level = _noindent ? ' ' : padl('', '  ', _level);
        if (schema.defs) {
            const keys = Object.keys(schema.defs).sort();
            defs = keys.map((k, i) => {
                const def = schema.defs[k];
                return (def.desc && def.desc.length ? (i === 0 ? '' : `\n${level}`) + def.desc.map(c => `// ${c}`).join(`\n${level}`) + `\n${level}` : '') + `type ${k} = ${stringifySchema(def)}`;
            }).join(`\n${level}`);
        }
        if (!fin) {
            const l2 = open && !_noindent ? `${level}  ` : level;
            const nl = _noindent ? '' : '\n';
            const lopen = open ? `${open}${nl}${l2}` : '';
            const lclose = close ? `${nl}${level}${close}` : '';
            if (wrap === 0)
                fin = `${lopen}${strs.join(join)}${lclose}`;
            else if (wrap === 1)
                fin = `${lopen}${strs.join(`${join}${nl}${l2}`)}${lclose}`;
            else {
                let line = '';
                const last = strs.length - 1;
                for (let i = 0; i < strs.length; i++) {
                    if (~strs[i].indexOf('\n')) {
                        line = '';
                        fin += (i === 0 ? '' : '\n' + l2) + strs[i] + (i !== last ? join : '');
                    }
                    else {
                        fin += strs[i], line += strs[i];
                        if (i !== last)
                            fin += join, line += join;
                    }
                    if (line.length > wrap && i !== last && !~(strs[i + 1] || '').indexOf('\n')) {
                        fin += `${nl}${l2}`;
                        line = '';
                        if (~join.indexOf('|'))
                            fin += '  ';
                    }
                }
                if (~fin.indexOf('\n'))
                    fin = `${lopen}${fin}${lclose}`;
                else
                    fin = `${open}${open === '{' ? ' ' : ''}${fin}${open === '{' && fin.substr(-1) !== ' ' ? ' ' : ''}${close}`;
            }
        }
        if (!_nochecks && schema.checks && schema.checks.length) {
            fin += ` ?${schema.checks.map(c => _stringify(c)).join(' ?')} `;
        }
        if (defs)
            fin = `${defs}\n${level}\n${level}${fin}`;
        return fin;
    }

    const parseSchema = parser$2(map(seq(opt(str('@[')), ws$2, schema(), ws$2, opt(str(']'))), ([, , schema]) => schema), { trim: true, consumeAll: true });

    const space$2 = ' \t\r\n';
    const num$2 = map(seq(opt(str('-')), read1(digits)), ([neg, num]) => neg ? -num : +num);
    const num_range = map(seq(num$2, str('-', ':'), num$2), ([start, , end]) => [start, end]);
    const sign_range = map(seq(str('<', '>'), ws$2, num$2), ([sign, , num]) => sign === '<' ? [-Infinity, num - 1] : [num + 1, Infinity]);
    const star_range = map(str('*'), () => [-Infinity, Infinity]);
    const not_range = map(seq(str('!'), alt(num_range, sign_range, num$2)), ([, range]) => ({ not: range }));
    const _range = rep1sep(alt(star_range, num_range, sign_range, num$2, not_range), read1(space$2 + ',;'), 'allow');
    const range = parser$2(_range, { trim: true });

    function join(...strs) {
        return strs.filter(s => s).join('.');
    }
    const looseEqual = (v1, v2) => v1 == v2;
    const strictEqual = (v1, v2) => v1 === v2;
    const isNum$1 = /^[\d.]+$/;
    const trueStrings = /^(true|on|yes)$/i;
    const falseStrings = /^(false|off|no)$/i;
    const sqlEqual = (v1, v2) => {
        var _a, _b;
        let tmp1, tmp2;
        if ((typeof v1 === 'number' || typeof v1 === 'string' && isNum$1.test(v1)) && (typeof v2 === 'number' || typeof v2 === 'string' && isNum$1.test(v2))) {
            return +v1 === +v2;
        }
        else if ((typeof v1 === 'boolean' || typeof v2 === 'boolean') && (typeof v1 === 'string' || typeof v2 === 'string')) {
            return trueStrings.test(v1) && trueStrings.test(v2) || falseStrings.test(v1) && falseStrings.test(v2);
        }
        else if ((v1 instanceof Date || typeof v1 === 'string' && Array.isArray((_a = (tmp1 = parseDate(v1))) === null || _a === void 0 ? void 0 : _a.f)) && (v2 instanceof Date || typeof v2 === 'string' && Array.isArray((_b = (tmp2 = parseDate(v2))) === null || _b === void 0 ? void 0 : _b.f))) {
            if (tmp1)
                tmp1 = dateRelToDate(tmp1);
            else
                tmp1 = v1;
            if (tmp2)
                tmp2 = dateRelToDate(tmp2);
            else
                tmp2 = v2;
            return +tmp1 === +tmp2;
        }
        else
            return v1 == v2;
    };
    const fullnum = /^\d+$/;
    function checkIdentity(map, path) {
        const p = path.split('.').reduce((a, c) => fullnum.test(c) ? `${a}[]` : `${a}${a.length ? '.' : ''}${c}`, '');
        return map[`${p}[]`];
    }
    function diff(v1, v2, equal) {
        const type = equal && typeof equal === 'object' ? equal.type : equal;
        const eq = typeof type === 'function' ? type : type === 'strict' ? strictEqual : type === 'sql' ? sqlEqual : looseEqual;
        return _diff(v1, v2, '', {}, eq, typeof equal === 'object' ? equal.identity : undefined);
    }
    function _diff(v1, v2, path, diff, equal, ident) {
        if (typeof v1 !== 'object' || typeof v2 !== 'object') {
            if (v1 === v2)
                return diff;
            diff[path] = [v1, v2];
            return diff;
        }
        let id;
        if (Array.isArray(v1) && Array.isArray(v2) && ident && (id = checkIdentity(ident, path))) {
            const v1ids = v1.map(v => id === true ? v : typeof id === 'string' ? (v && (typeof v === 'object' || typeof v === 'function') ? v[id] : v) : id(v));
            const v2ids = v2.map(v => id === true ? v : typeof id === 'string' ? (v && (typeof v === 'object' || typeof v === 'function') ? v[id] : v) : id(v));
            for (let i = 0; i < v1ids.length; i++) {
                const idx = v2ids.indexOf(v1ids[i]);
                if (~idx) {
                    const vv1 = v1[i];
                    const vv2 = v2[idx];
                    if (vv1 === vv2)
                        continue;
                    else if (typeof vv1 === 'object' && typeof vv2 === 'object')
                        _diff(vv1, vv2, join(path, `${i}`), diff, equal, ident);
                    else if (!equal(vv1, vv2))
                        diff[join(path, `${i}`)] = [vv1, vv2];
                }
                else
                    diff[join(path, `${i}`)] = [v1[i], undefined];
            }
            const found = v1ids.slice();
            for (let i = 0; i < v1ids.length; i++) {
                if (~found.indexOf(v2ids[i]))
                    continue;
                diff[join(path, `${i + found.length}`)] = [undefined, v2[i]];
            }
        }
        else {
            const _v1 = v1 || {};
            const _v2 = v2 || {};
            const ks = Object.keys(_v1);
            for (const k of Object.keys(_v2))
                if (!~ks.indexOf(k))
                    ks.push(k);
            for (const k of ks) {
                const vv1 = _v1[k];
                const vv2 = _v2[k];
                if (vv1 === vv2)
                    continue;
                else if (typeof vv1 === 'object' && typeof vv2 === 'object')
                    _diff(vv1, vv2, join(path, k), diff, equal, ident);
                else if (!equal(vv1, vv2))
                    diff[join(path, k)] = [vv1, vv2];
            }
        }
        return diff;
    }
    function deepEqual(v1, v2, equal) {
        const eq = typeof equal === 'function' ? equal : equal === 'strict' ? strictEqual : equal === 'sql' ? sqlEqual : looseEqual;
        return _deepEqual(v1, v2, eq);
    }
    function _deepEqual(v1, v2, equal) {
        if (typeof v1 !== 'object' || typeof v2 !== 'object')
            return equal(v1, v2);
        if ((!v1 || !v2) && v1 != v2)
            return false; // eslint-ignore-line eqeqeq
        const ks = Object.keys(v1 || {});
        for (const k of Object.keys(v2 || {}))
            if (!~ks.indexOf(k))
                ks.push(k);
        for (const k of ks) {
            const vv1 = v1[k];
            const vv2 = v2[k];
            if (vv1 === vv2)
                continue;
            else if (typeof vv1 === 'object' && typeof vv2 === 'object') {
                if (!_deepEqual(vv1, vv2, equal))
                    return false;
            }
            else if (!equal(vv1, vv2))
                return false;
        }
        return true;
    }
    function labelDiff(diff, label, opts) {
        const out = (opts === null || opts === void 0 ? void 0 : opts.omit) ? {} : Object.assign({}, diff);
        _labelDiff(diff, label, '', '', out, opts);
        return out;
    }
    const num$1 = /^\d+/;
    function _labelDiff(diff, label, path, str, out, opts) {
        for (const k in label) {
            if (k.slice(-2) === '[]') {
                const p = `${path}${path && '.'}${k.slice(0, -2)}`;
                const l = Array.isArray(label[k]) ? label[k] : [label[k]];
                const all = Object.keys(diff);
                const nums = [];
                for (const k of all) {
                    if (k.indexOf(p) === 0 && num$1.test(k.substr(p.length + 1))) {
                        const idx = k.indexOf('.', p.length + 1);
                        const num = k.substring(p.length + 1, ~idx ? idx : undefined);
                        if (!~nums.indexOf(num))
                            nums.push(num);
                    }
                }
                const lbl = `${str}${str && ' '}${l[0]}`;
                for (const num of nums) {
                    const pp = `${p}${p && '.'}${num}`;
                    if (pp in diff) {
                        out[`${lbl}${lbl && ' '}${+num + 1}`] = diff[pp];
                        if (opts === null || opts === void 0 ? void 0 : opts.omit)
                            delete out[pp];
                    }
                    if (l[1])
                        _labelDiff(diff, l[1], pp, `${lbl}${lbl && ' '}${+num + 1}`, out, opts);
                }
            }
            else {
                const p = `${path}${path && '.'}${k}`;
                let l = Array.isArray(label[k]) ? label[k] : [label[k]];
                const lbl = `${str}${str && ' '}${l[0]}`;
                if (p in diff) {
                    out[lbl] = diff[p];
                    if (opts === null || opts === void 0 ? void 0 : opts.omit)
                        delete out[p];
                }
                if (l[1])
                    _labelDiff(diff, l[1], p, lbl, out, opts);
            }
        }
    }

    const date = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/;
    function isDate$1(v) {
        if (typeof v === 'object')
            return isDateRel(v);
        else if (typeof v === 'string' && date.test(v))
            return true;
        return false;
    }
    function isSchema(what) {
        return what && typeof what === 'object' && 'type' in what && typeof what.type === 'string';
    }
    function inspect(base, flat) {
        const root = getType$1(base);
        if (Array.isArray(base)) {
            const fields = [];
            fields.push({ type: 'number', name: 'length' });
            if (!flat && base.length > 0) {
                const val = inspect(base[0]);
                if (val.fields)
                    fields.push({ type: val.type, fields: val.fields, name: '0' });
                else
                    fields.push({ type: val.type, name: '0' });
            }
            return { type: root, fields };
        }
        else if (typeof base === 'object' && !isDate$1(base)) {
            const fields = [];
            for (const k in base) {
                fields.push(getField(k, base[k], flat));
            }
            return { type: root, fields };
        }
        return { type: root };
    }
    function getField(name, v, flat) {
        const type = getType$1(v);
        if (!flat && (~type.indexOf('object') || type === 'array')) {
            const cs = inspect(v);
            if (cs.fields)
                return { type, fields: cs.fields, name };
            else
                return { type, name };
        }
        return { type: getType$1(v), name };
    }
    function getType$1(v) {
        if (typeof v === 'string') {
            if (isDate$1(v))
                return 'date';
            else
                return 'string';
        }
        else if (typeof v === 'number')
            return 'number';
        else if (typeof v === 'boolean')
            return 'boolean';
        else if (Array.isArray(v)) {
            if (v.length < 1)
                return 'array';
            else if (typeof v[0] === 'string') {
                if (isDate$1(v[0]))
                    return 'date[]';
                else
                    return 'string[]';
            }
            else if (typeof v[0] === 'number')
                return 'number[]';
            else if (typeof v[0] === 'boolean')
                return 'boolean[]';
            else if (isDate$1(v[0]))
                return 'date[]';
            else if (typeof v[0] === 'object')
                return 'object[]';
            else
                return 'array';
        }
        else if (typeof v === 'object') {
            if (isDate$1(v))
                return 'date';
            else
                return 'object';
        }
        else
            return 'any';
    }
    function validate$2(value, schema, mode) {
        if (typeof schema === 'string') {
            const parsed = parseSchema(schema);
            if ('message' in parsed)
                return [{ error: 'invalid schema' }];
            schema = parsed;
        }
        if (!schema)
            schema = { type: 'any' };
        const ctx = new Root(value, { special: { types: schema.defs || {} } });
        return _validate(value, schema, mode, '', ctx);
    }
    function _validate(value, schema, mode, path, ctx, required) {
        schema = schema || {};
        let _schema = schema;
        const errs = [];
        const miss = mode === 'strict' || mode === 'missing';
        if (_schema.ref) {
            let s = _schema;
            while (s && s.ref)
                s = safeGet(ctx, `@types.${s.ref}`);
            if (s)
                _schema = s;
            else if (miss)
                errs.push({ error: `missing type definition '${_schema.ref}'`, type: 'missing' });
        }
        let { checks } = _schema;
        const { type, fields, rest, types, literal } = _schema;
        if (!checkType(value, schema.type === 'array' ? 'array' : type, literal, required))
            return [{ error: `type mismatch for${required ? ' required' : ''} '${type}'`, actual: stringifySchema(inspect(value)), value, path, expected: stringifySchema(_schema, true) }];
        if (_schema !== schema && schema.checks) {
            if (!checks)
                checks = schema.checks;
            else
                checks = checks.concat(schema.checks);
        }
        let tmp;
        if ((type === 'tuple' || type === 'tuple[]') && types) {
            const arr = ~type.indexOf('[]');
            const val = arr ? value : [value];
            for (let i = 0; i < val.length; i++) {
                const v = val[i];
                const p = arr ? join(path, `${i}`) : path;
                if (!Array.isArray(v)) {
                    errs.push({ error: 'expected a tuple', path: p, value: v });
                }
                else if (v.length < types.length) {
                    const diff = types.length - v.length;
                    errs.push({ error: `missing ${diff} field${diff > 1 ? 's' : ''} in tuple`, path: p, expected: stringifySchema({ type: 'tuple', types }) });
                }
                else {
                    for (let i = 0; i < types.length; i++) {
                        if ((tmp = _validate(v[i], types[i], mode, join(p, `${i}`), extend$2(ctx, { value: v[i], path: join(p, `${i}`) }))) !== true)
                            errs.push.apply(errs, tmp);
                    }
                    if (mode === 'strict' && v.length > types.length)
                        errs.push({ error: `too many values for tuple`, type: 'strict', path: p, expected: stringifySchema({ type: 'tuple', types }) });
                }
            }
        }
        else if ((type === 'union' || type === 'union[]') && types) {
            const arr = ~type.indexOf('[]');
            const val = arr ? value : [value];
            for (let i = 0; i < val.length; i++) {
                const v = val[i];
                const p = arr ? join(path, `${i}`) : path;
                let ok = false;
                let legit;
                for (const u of types) {
                    if ((tmp = _validate(v, u, mode, p, ctx)) === true) {
                        ok = true;
                        break;
                    }
                    else if (miss && tmp.find(e => e.type === 'missing') || tmp.find(e => e.type === 'check')) {
                        legit = tmp.filter(e => miss && e.type === 'missing' || e.type === 'check');
                    }
                    else if (tmp.find(e => e.path !== p)) {
                        legit = tmp;
                    }
                }
                if (!ok && !legit)
                    errs.push({ error: `type mismatch for union`, actual: stringifySchema(inspect(v)), expected: stringifySchema({ type: 'union', types }), value: v, path: p });
                else if (!ok && legit)
                    errs.push.apply(errs, legit);
            }
        }
        else if ((type === 'object' || type === 'object[]' || type === 'any') && fields || rest) {
            const arr = ~type.indexOf('[]') || schema.type === 'array';
            const val = arr ? value : [value];
            for (let i = 0; i < val.length; i++) {
                const v = val[i];
                const p = arr ? join(path, `${i}`) : path;
                if (typeof v !== 'object' && typeof v !== 'function') {
                    errs.push({ error: 'expected an object', value: v, path: p, actual: stringifySchema(inspect(v), true) });
                    continue;
                }
                if (fields) {
                    for (const f of fields) {
                        if (f.required && !(f.name in v))
                            errs.push({ error: `requried field ${f.name} is missing`, path: join(p, f.name) });
                        else if (v && f.name in v && (tmp = _validate(v[f.name], f, mode, join(p, f.name), extend$2(ctx, { value: v[f.name], path: join(p, f.name) }), f.required)) !== true)
                            errs.push.apply(errs, tmp);
                    }
                }
                if (rest && v) {
                    for (const k in v) {
                        if (fields && fields.find(f => f.name === k))
                            continue;
                        if (v[k] != null && (tmp = _validate(v[k], rest, mode, join(p, k), extend$2(ctx, { value: v[k], path: join(p, k) }))) !== true)
                            errs.push.apply(errs, tmp);
                    }
                }
                else if (mode === 'strict' && v) {
                    for (const k in v)
                        if (v[k] != null && !fields || !fields.find(f => f.name === k))
                            errs.push({ error: `unknown field ${k}`, path: p, type: 'strict', value: v[k] });
                }
            }
        }
        if (!errs.length && checks && checks.length) {
            let tmp;
            for (let i = 0; i < checks.length; i++) {
                const c = checks[i];
                tmp = evalApply(ctx, c, [value]);
                if (!tmp || typeof tmp == 'string')
                    errs.push({ error: typeof tmp !== 'string' || !tmp ? `check ${i + 1} failed` : tmp, path, value, type: 'check', expected: stringifySchema(schema, true) });
            }
        }
        return errs.length ? errs : true;
    }
    const values = ['string', 'number', 'boolean', 'object'];
    function checkType(value, type, literal, required) {
        switch (type || 'any') {
            case 'any':
            case 'union':
                return true;
            case 'value': return !Array.isArray(value) && !!~values.indexOf(typeof value) && (typeof value !== 'object' || isDate$1(value));
            case 'array':
            case 'tuple':
            case 'union[]':
            case 'tuple[]':
                return Array.isArray(value);
            case 'literal': return value === literal;
            case 'string': return typeof value === 'string';
            case 'number': return typeof value === 'number';
            case 'boolean': return typeof value === 'boolean';
            case 'date': return isDate$1(value);
            case 'object': return !Array.isArray(value) && typeof value === 'object' && (!required || value != null);
            case 'string[]': return Array.isArray(value) && value.reduce((a, c) => a && typeof c === 'string', true);
            case 'number[]': return Array.isArray(value) && value.reduce((a, c) => a && typeof c === 'number', true);
            case 'boolean[]': return Array.isArray(value) && value.reduce((a, c) => a && typeof c === 'boolean', true);
            case 'date[]': return Array.isArray(value) && value.reduce((a, c) => a && isDate$1(c), true);
            case 'object[]': return Array.isArray(value) && value.reduce((a, c) => a && !Array.isArray(c) && typeof c === 'object' && (!required || c != null), true);
        }
    }

    const DEFAULTS = {
        record: '\n',
        field: ',',
        header: false,
        quote: '"',
    };
    function csv(options) {
        const opts = Object.assign({}, DEFAULTS, options);
        const ws = skip(' \t\r\n'.replace(opts.field, '').replace(opts.record, '').replace(opts.quote, ''));
        const quote = str(opts.quote || '"');
        const quotedField = bracket(seq(ws, quote), map(rep(alt(readTo(opts.quote), map(seq(quote, quote), () => ''))), r => concat$1(r)), seq(quote, ws));
        const unquotedField = readTo(opts.record + opts.field, true);
        const field = alt(quotedField, unquotedField);
        const record = verify(rep1sep(field, seq(ws, str(opts.field), ws)), s => s.length > 1 || s[0].length > 0 || 'empty record');
        const csv = repsep(record, str(opts.record), 'allow');
        const _parse = parser$2(csv, { consumeAll: true });
        return function parse(input, options) {
            const res = _parse(input, options);
            if (Array.isArray(res) && res.length > 0) {
                if (opts.header) {
                    const header = res.shift().map((k, i) => [k, i]);
                    header.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
                    for (let i = 0; i < res.length; i++) {
                        for (let j = 0; j < header.length; j++)
                            res[i][header[j][0]] = res[i][header[j][1]];
                    }
                }
            }
            return res;
        };
    }
    const fields = [',', '|', '\t', ':', ';', '~'];
    const records = ['\r\n', '\r', '\n'];
    const quotes = ['\'', '"', '`', '$'];
    function detect(data, amount = 2048) {
        const sample = data.slice(0, amount);
        const fs = fields.reduce((a, c) => (a[c] = sample.replace(new RegExp(`[^${c}]`, 'g'), '').length / c.length, a), {});
        const rs = records.reduce((a, c) => (a[c] = sample.replace(new RegExp(`[^${c}]`, 'g'), '').length / c.length, a), {});
        const qs = quotes.reduce((a, c) => (a[c] = sample.replace(new RegExp(`[^${c}]`, 'g'), '').length / c.length, a), {});
        const res = { field: ',', record: '\n', quote: '"' };
        let max = 0;
        for (const k in fs)
            if (fs[k] > max)
                (res.field = k, max = fs[k]);
        max = 0;
        for (const k in rs)
            if (rs[k] > max)
                (res.record = k, max = rs[k]);
        max = 0;
        for (const k in qs)
            if (qs[k] > max)
                (res.quote = k, max = qs[k]);
        return res;
    }
    function parse$2(data, options) {
        const base = csv(Object.assign({}, options, { header: false }))(data);
        if ('message' in base)
            return [];
        if (options.header && base.length) {
            const header = base.shift().map((k, i) => [k, i]);
            header.sort((a, b) => a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0);
            return base.map(v => header.reduce((a, c) => (a[c[0]] = v[c[1]], a), {}));
        }
        return base;
    }

    const ws = read(' \r\n\t');
    const endTxt = '&<';
    const entities = { amp: '&', gt: '>', lt: '<' };
    const entity = map(seq(str('&'), str('amp', 'gt', 'lt'), str(';')), ([, which]) => entities[which] || '', 'entity');
    const name$1 = read1('abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-_:$', 'name');
    const attr = map(seq(name$1, opt(seq(ws, str('='), ws, alt(name$1, quoted('"'), quoted("'"))))), ([name, rest]) => ({ name, value: rest ? rest[3] : true }), 'attr');
    function quoted(quote) {
        return map(seq(str(quote), readTo(quote), str(quote)), ([, str]) => str);
    }
    const open = map(seq(str('<'), ws, name$1, ws, repsep(attr, ws, 'allow'), opt(str('/')), str('>')), ([, , name, , attrs, close]) => ({ open: true, name, attrs, empty: !!close }), 'open');
    const close = map(seq(str('</'), ws, name$1, ws, str('>')), ([, , name]) => ({ close: true, name }), 'close');
    const content = map(rep1(alt(read1To(endTxt, true), entity), 'content'), txts => txts.join('').trim());
    const stream = rep(alt(open, content, close));
    const _parse = parser$2(stream, { trim: true, consumeAll: true, undefinedOnError: true });
    function put(target, prop, value) {
        if (prop in target) {
            if (Array.isArray(target[prop]))
                target[prop].push(value);
            else
                target[prop] = [target[prop], value];
        }
        else {
            target[prop] = value;
        }
    }
    function parse$1(str, strict) {
        const stack = [];
        const names = [];
        const res = [];
        let content = '';
        const stream = _parse(str);
        if (!stream || 'error' in stream)
            return undefined;
        function close(end) {
            const val = stack.pop();
            if (!val)
                return;
            const name = names.pop();
            if (!stack.length) {
                res.push(val);
            }
            else {
                if (!Object.keys(val).length)
                    put(stack[stack.length - 1], name, content || '');
                else
                    put(stack[stack.length - 1], name, val);
            }
            if (end !== name)
                close(end);
        }
        for (const p of stream) {
            if (typeof p === 'string') {
                if (p)
                    content += p;
            }
            else if ('open' in p) {
                content = '';
                const val = p.attrs.reduce((a, c) => (put(a, c.name, c.value), a), {});
                if (p.empty) {
                    if (stack.length)
                        put(stack[stack.length - 1], p.name, val);
                    else
                        res.push(val);
                }
                else {
                    names.push(p.name);
                    stack.push(val);
                }
            }
            else if ('close' in p) {
                if (strict && p.name !== names[names.length - 1])
                    return;
                close(p.name);
            }
        }
        if (names.length && !strict)
            close(names[0]);
        return res.length > 1 ? res : res.length === 1 ? res[0] : undefined;
    }

    function simple(names, apply) {
        return {
            type: 'value', names, apply
        };
    }
    const spanMap = {
        y: [0, 12],
        M: [1, 30],
        d: [2, 24],
    };
    const generateDefaults = {
        max: 10000,
    };
    const roundDefaults = {
        places: 2,
        'all-numeric': false,
        method: 'half-even',
    };
    function round(amt, settings) {
        var _a, _b;
        const place = (_a = settings === null || settings === void 0 ? void 0 : settings.places) !== null && _a !== void 0 ? _a : roundDefaults.places;
        const type = (_b = settings === null || settings === void 0 ? void 0 : settings.method) !== null && _b !== void 0 ? _b : roundDefaults.method;
        if (place > 0) {
            let str = (+amt || 0).toString();
            const point = str.indexOf('.');
            if (!~point)
                return (+str).toFixed(place);
            let dec = str.slice(point + 1);
            if (dec.length <= place)
                return (+str).toFixed(place);
            str += '0';
            dec += '0';
            const l = +`${str.slice(place - dec.length, place - dec.length + 1)}` || 0;
            if (+l < 5)
                return str.slice(0, place - dec.length);
            else if (+l > 5 || +`${str.slice(1 + place - dec.length)}`)
                return (+amt).toFixed(place);
            else {
                const pre = `${str.slice(0, place - dec.length)}`;
                const f = +str.slice(place - dec.length - 1, place - dec.length);
                if (type === 'half-odd')
                    return (+`${pre}${f % 2 === 0 ? 6 : 4}`).toFixed(place);
                else if (type === 'half-up')
                    return (+`${pre}${+pre > 0 ? 6 : 4}`).toFixed(place);
                else if (type === 'half-down')
                    return (+`${pre}${+pre > 0 ? 4 : 6}`).toFixed(place);
                else if (type === 'to-0')
                    return (+`${pre}4`).toFixed(place);
                else if (type === 'from-0')
                    return (+`${pre}6`).toFixed(place);
                else
                    return (+`${pre}${f % 2 === 0 ? 4 : 6}`).toFixed(place);
            }
        }
        else if (place === 0) {
            let str = (+amt || 0).toString();
            const point = str.indexOf('.');
            if (!~point)
                return str;
            str = `${str}00`;
            const p = +str.slice(point - 1, point);
            const n = +str.slice(point + 1, point + 2);
            if (n < 5)
                return str.slice(0, point);
            else if (n > 5 || n === 5 && +str.slice(point + 2))
                return (+`${str.slice(0, point - 1)}0` + (p + 1) * (+str < 0 ? -1 : 1)).toString();
            else {
                const base = +`${str.slice(0, point - 1)}0`;
                if (type === 'half-odd')
                    return (base + (p % 2 === 0 ? p + 1 : p) * (+str < 0 ? -1 : 1)).toString();
                else if (type === 'half-up')
                    return (base + (+str > 0 ? p + 1 : p) * (+str < 0 ? -1 : 1)).toString();
                else if (type === 'half-down')
                    return (base + (+str < 0 ? p + 1 : p) * (+str < 0 ? -1 : 1)).toString();
                else if (type === 'to-0')
                    return base.toString();
                else if (type === 'from-0')
                    return (base + 1).toString();
                else
                    return (base + (p % 2 === 0 ? p : p + 1) * (+str < 0 ? -1 : 1)).toString();
            }
        }
        else {
            let str = `${+amt < 0 ? Math.floor(+amt || 0) : Math.ceil(+amt || 0)}`;
            if (0 - place > str.length)
                return `0`;
            const n = +str.slice(place, place === -1 ? undefined : place + 1);
            let p = str.slice(place - 1, place);
            if (p === '-')
                p = '';
            const zeroes = `${Math.pow(10, 0 - place).toString().slice(1)}`;
            if (!p) {
                const big = `${+str < 0 ? '-' : ''}1${zeroes}`;
                if (+str > 0 && +str < 5 || +str < 0 && +str > -5)
                    return '0';
                else if (+str > 0 && +str > 5 || +str < 0 && +str < -5)
                    return big;
                else {
                    if (type === 'half-odd')
                        return big;
                    else if (type === 'half-up')
                        return +str > 0 ? big : '0';
                    else if (type === 'half-down')
                        return +str > 0 ? '0' : big;
                    else if (type === 'to-0')
                        return '0';
                    else if (type === 'from-0')
                        return big;
                    else
                        return '0';
                }
            }
            else {
                if (n < 5)
                    return `${str.slice(0, place)}${zeroes}`;
                else if (n > 5 || place < -1 && +`${str.slice(place + 1)}`)
                    return (+`${+str.slice(0, place - 1) || 0}${0}${zeroes}` + +`${+p + 1}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                else {
                    const base = +`${str.slice(0, place - 1) || 0}0${zeroes}`;
                    if (type === 'half-odd')
                        return (base + +`${+p % 2 === 0 ? +p + 1 : +p}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                    else if (type === 'half-up')
                        return (base + +`${+str > 0 ? +p + 1 : +p}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                    else if (type === 'half-down')
                        return (base + +`${+str < 0 ? +p + 1 : +p}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                    else if (type === 'to-0')
                        return (base + +`${+p}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                    else if (type === 'from-0')
                        return (base + +`${+p + 1}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                    else
                        return (base + +`${+p % 2 === 0 ? +p : +p + 1}${zeroes}` * (+str < 0 ? -1 : 1)).toString();
                }
            }
        }
    }
    const hasNum = /^[^\d]*(\d+(?:\.\d*)?)/;
    const space$1 = /^\s*$/;
    function isNum(v) {
        return !isNaN(v) && !space$1.test(v);
    }
    function num(v) {
        if (isNaN(v) || !v)
            return 0;
        return +v;
    }
    function equals(l, r) {
        if (l === r || l == r)
            return true; // eslint-disable-line eqeqeq
        if (isDateRel(l) && isDateRel(r))
            return +dateRelToDate(l) === +dateRelToDate(r);
        if (typeof l === 'number' && typeof r === 'number')
            return isNaN(l) && isNaN(r);
        return false;
    }
    /**
     * Find a the first overlapping substring that contains threshhold percent characters of the smallest string length.
     * @param a - the first string
     * @param b - the second string
     * @param threshhold - defaults to 0.5 - the percentage of the smaller string length needed to match
     * @returns - the substring that matches
     */
    function overlap(a, b, threshhold = 0.5) {
        const res = similar(a, b, threshhold, 0);
        return res && res[1] || undefined;
    }
    /**
     * Finds the percentage similarity between two strings based on a minimum threshhold and a fudge factor. The minimum threshhold determins the earliest that the search can return. The fudge factor allows skipping characters in either string, though there is no backtracking.
     * @param a - the first string
     * @param b - the second string
     * @param threshhold - defaults to 0.5 - the required similarity between two substrings, accounting for the fidge factor
     * @param fudges - the number skippable characters in either string without a match
     * @returns - the similarity of the first qualifying match
     */
    function similarity(a, b, threshhold = 0.5, fudges = 2) {
        const res = similar(a, b, threshhold, fudges);
        return res && res[2] || 0;
    }
    /**
     * Finds the similarity between two strings based on a minimum threshhold and a fudge factor. The minimum threshhold determins the earliest that the search can return. The fudge factor allows skipping characters in either string, though there is no backtracking.
     * @param a - the first string
     * @param b - the second string
     * @param threshhold - defaults to 0.5 - the required similarity between two substrings, accounting for the fudge factor
     * @param fudges - the number skippable characters in either string without a match
     * @returns - a tuple of the substrings from each string and the similarity percentage, accounting for the fudge factor
     */
    function similar(a, b, threshhold = 0.5, fudges = 2) {
        if (!a || !b)
            return;
        const aa = a.toLowerCase();
        const bb = b.toLowerCase();
        // check containment
        if (~aa.indexOf(bb))
            ;
        if (~bb.indexOf(aa))
            ;
        let i1 = 0;
        let i2 = 0;
        let oa = 0;
        let ob = 0;
        let f = 0;
        let f1 = 0;
        let f2 = 0;
        let fs = 0;
        let sim = 0;
        const alen = a.length;
        const blen = b.length;
        let aolen = 0;
        let bolen = 0;
        // walk a
        for (i1 = 0; i1 < alen; i1++) {
            // walk b
            for (i2 = 0; i2 < blen; i2++) {
                // if there's a match, see how far it goes
                if (aa[i1] === bb[i2]) {
                    aolen = alen - i1;
                    bolen = blen - i2;
                    fs = 0;
                    // walk the remaining pieces of each string checking for matches
                    matchy: for (oa = 1, ob = 1; oa < aolen && ob < bolen;) {
                        if (aa[i1 + oa] === bb[i2 + ob]) { // nailed it
                            oa++, ob++;
                        }
                        else { // not so much, so compare closer chars in each string, walking outward
                            for (f = 0; f <= fudges; f++) {
                                for (f1 = 0; f1 <= f; f1++) {
                                    for (f2 = 0; f2 <= f; f2++) {
                                        if (aa[i1 + oa + f1] === bb[i2 + ob + f2]) {
                                            oa += f1;
                                            ob += f2;
                                            fs += Math.max(f1, f2); // keep track of the fudge factor
                                            continue matchy;
                                        }
                                    }
                                }
                            }
                            break matchy; // not even fudge could save it
                        }
                    }
                    sim = (Math.max(oa, ob) - fs) / Math.min(aa.length, bb.length); // get approximate similarity
                    if (sim >= threshhold)
                        return [aa.substr(i1, oa), bb.substr(i2, ob), sim]; // and if it exceeds the threshold, we're good
                }
            }
        }
    }
    function inRange(v, range) {
        let found = false;
        let excluded = false;
        for (const r of range) {
            if (Array.isArray(r) && v >= r[0] && v <= r[1])
                found = true;
            else if (typeof r === 'object' && 'not' in r) {
                if (Array.isArray(r.not) && v >= r.not[0] && v <= r.not[1])
                    excluded = true;
                else if (v == r.not)
                    excluded = true;
            }
            else if (v == r)
                found = true;
        }
        return found && !excluded;
    }
    // basic ops
    registerOperator(simple(['is', 'is-not', '==', '!='], (name, values) => {
        const [l, r] = values;
        let cmp = equals(l, r);
        if (!cmp && (name === 'is' || name === 'is-not') && isSchema(r))
            cmp = validate$2(l, r, 'loose') === true;
        return name === 'is' || name === '==' ? cmp : !cmp;
    }), simple(['strict-is', 'strict-is-not'], (name, values) => {
        const [l, r] = values;
        let res = l === r;
        if (!res && isSchema(r))
            res = validate$2(l, r, 'strict') === true;
        return name === 'strict-is' ? res : !res;
    }), simple(['deep-is', 'deep-is-not', '===', '!=='], (name, [l, r, equal], opts, ctx) => {
        equal = equal || (opts === null || opts === void 0 ? void 0 : opts.equal);
        if (equal && isApplication(equal)) {
            const eq = equal;
            equal = (l, r) => evalApply(ctx, eq, [l, r]);
        }
        const res = deepEqual(l, r, equal);
        return name === 'deep-is' || name === '===' ? res : !res;
    }), simple(['not'], (_name, values) => !values[0]), simple(['<', '>', '<=', '>=', 'gt', 'gte', 'lt', 'lte'], (name, values) => {
        if (name === 'gt')
            name = '>';
        else if (name === 'lt')
            name = '<';
        else if (name === 'gte')
            name = '>=';
        else if (name === 'lte')
            name = '<=';
        let [l, r] = values;
        if (l instanceof Date || r instanceof Date) {
            if (typeof l === 'number' || typeof r === 'number') {
                l = +l;
                r = +r;
            }
            else if (typeof l === 'string' || typeof r === 'string') {
                l = new Date(l);
                r = new Date(r);
            }
            else if (l && 'f' in l && 'o' in l) {
                l = dateRelToRange(l)[name[0] === '<' ? 1 : 0];
                r = new Date(r);
            }
            else if (r && 'f' in r && 'o' in r) {
                r = dateRelToRange(r)[name === '<' || name === '>=' ? 0 : 1];
                l = new Date(l);
            }
        }
        else if (isDateRel(l)) {
            l = dateRelToRange(l)[name[0] === '<' ? 1 : 0];
            r = isDateRel(r) ? dateRelToRange(r)[name === '<' || name === '>=' ? 0 : 1] : new Date(r);
        }
        else if (isDateRel(r)) {
            r = dateRelToRange(r)[name === '<' || name === '>=' ? 0 : 1];
            l = new Date(l);
        }
        return name === '<' ? l < r :
            name === '>' ? l > r :
                name === '<=' ? l <= r :
                    name === '>=' ? l >= r :
                        false;
    }), simple(['like', 'not-like', 'ilike', 'not-ilike'], (name, values) => {
        const [target, pattern, arg] = values;
        let res = false;
        const patterns = typeof pattern === 'string' ? [pattern] : pattern;
        const free = arg === 'free' || (typeof arg === 'object' && arg.free);
        if (!Array.isArray(patterns))
            return false;
        for (let i = 0; i < patterns.length && !res; i++) {
            const r = patterns[i];
            if (typeof r !== 'string')
                continue;
            const re = new RegExp(`${free ? '' : '^'}${r.replace(/[\s\%\*]+/g, '[\\s\\S]*').replace(/\?/g, '.')}${free ? '' : '$'}`, ~name.indexOf('ilike') ? 'i' : '');
            if (Array.isArray(target))
                res = !!target.find(v => re.test(v));
            else
                res = re.test(target);
        }
        return name === 'like' || name === 'ilike' ? res : !res;
    }), simple(['in', 'not-in'], (name, values, _opts, ctx) => {
        const [l, r] = values;
        let range;
        if (isDateRel(r)) {
            const range = dateRelToRange(r);
            const d = isDateRel(l) ? dateRelToRange(l)[0] : new Date(l);
            const n = d >= range[0] && d <= range[1];
            return name === 'in' ? n : !n;
        }
        else if (typeof l === 'string' && typeof r === 'object' && !Array.isArray(r)) {
            return l in r;
        }
        else if (Array.isArray(l) && l.length > 0 && typeof l[0] === 'string' && !Array.isArray(r) && r && typeof r === 'object') {
            const keys = Object.keys(r);
            const found = l.reduce((a, c) => a && ~keys.indexOf(c), true);
            return name === 'in' ? found : !found;
        }
        else if (typeof r === 'string' && isNum(l) && (range = _parseRange(ctx, r), Array.isArray(range))) {
            const found = inRange(+l, range);
            return name === 'in' ? found : !found;
        }
        else if (isApplication(l)) {
            let found = false;
            if (Array.isArray(r) || r && typeof r === 'object' && '0' in r)
                found = Array.prototype.find.call(r, (e, i) => evalApply(ctx, l, [e, i], { index: i, key: i }));
            else if (r && typeof r === 'object')
                found = Object.entries(r).find((e, i) => evalApply(ctx, l, [e[1], i, e[0]], { index: i, key: e[0] }));
            return name === 'in' ? !!found : !found;
        }
        else if (!Array.isArray(r) && typeof r !== 'string') {
            return name === 'in' ? l == r : l != r;
        }
        else if (Array.isArray(l) && Array.isArray(r)) {
            const b = l.reduce((a, c) => a && ~r.indexOf(c), true);
            return name === 'in' ? !!b : !b;
        }
        const res = !!~r.indexOf(l);
        return name === 'in' ? res : !res;
    }), simple(['contains', 'does-not-contain'], (name, values, _opts, ctx) => {
        const [l, r] = values;
        if (isDateRel(l)) {
            const range = dateRelToRange(l);
            const d = isDateRel(r) ? dateRelToRange(r)[0] : new Date(r);
            const n = d >= range[0] && d <= range[1];
            return name === 'contains' ? n : !n;
        }
        else if (isApplication(r)) {
            let found = false;
            if (Array.isArray(l) || l && typeof l === 'object' && '0' in l)
                found = Array.prototype.find.call(l, (e, i) => evalApply(ctx, r, [e, i], { index: i, key: i }));
            else if (r && typeof l === 'object')
                found = Object.entries(l).find((e, i) => evalApply(ctx, r, [e[1], i, e[0]], { index: i, key: e[0] }));
            return name === 'contains' ? !!found : !found;
        }
        else if (!Array.isArray(l) && typeof l !== 'string') {
            return false;
        }
        else if (Array.isArray(r) && Array.isArray(l)) {
            const b = r.reduce((a, c) => a && ~l.indexOf(c), true);
            return name === 'contains' ? !!b : !b;
        }
        const res = !!~l.indexOf(r);
        return name === 'contains' ? res : !res;
    }), simple(['clamp'], (_name, [min, v, max]) => {
        return v < min ? min : v > max ? max : v;
    }), simple(['get'], (_name, values, _opts, ctx) => {
        const [l, r] = values;
        const c = extend$2(ctx, { value: l });
        if (isKeypath(r))
            return safeGet(c, r);
        else if (typeof r === 'number')
            return safeGet(c, '' + r);
        else
            return evaluate(c, r);
    }), simple(['generate'], (_name, [apply], opts, ctx) => {
        if (apply && isApplication(apply)) {
            const res = [];
            let state = opts;
            let it;
            for (let i = 0; i < generateDefaults.max; i++) {
                it = evalApply(ctx, apply, [state, it, i], { index: i, last: it, state });
                if (Array.isArray(it))
                    it.forEach(v => res.push(v));
                else if (it && typeof it === 'object') {
                    const keys = Object.keys(it);
                    if (keys.find(k => k !== 'value' && k !== 'state'))
                        res.push(it);
                    else {
                        res.push(it.value);
                        state = it.state || state;
                        it = it.value;
                    }
                }
                else if (it === undefined)
                    break;
                else
                    res.push(it);
            }
            return res;
        }
        return [];
    }), simple(['array'], (_name, values, opts) => {
        if (values.length === 1 && (opts === null || opts === void 0 ? void 0 : opts.range)) {
            let range$1 = values[0];
            if (typeof range$1 === 'string')
                range$1 = range(range$1);
            if (Array.isArray(range$1)) {
                const bounds = Array.isArray(opts.bounds) && opts.bounds.length === 2 && opts.bounds.filter(b => typeof b === 'number').length === 2 ? opts.bounds : [-100, 200];
                bounds.slice().sort((l, r) => l < r ? -1 : l > r ? 1 : 0);
                let [lower, upper] = bounds;
                if (upper - lower > 10000)
                    lower = upper - 10000;
                const res = [];
                for (let i = lower; i <= upper; i++)
                    if (inRange(i, range$1))
                        res.push(i);
                return res;
            }
            else
                return [];
        }
        return values;
    }), simple(['object'], (_name, values) => {
        const res = {};
        for (let i = 0; i < values.length; i += 2) {
            res[values[i]] = values[i + 1];
        }
        return res;
    }), simple(['split'], (_name, [str, split]) => {
        if (typeof str !== 'string')
            return [str];
        else
            return str.split(split || '');
    }), simple(['filter'], (_name, values, _opts, ctx) => {
        let [arr, flt, sorts, groups] = values;
        if (!Array.isArray(arr)) {
            if (arr && Array.isArray(arr.value))
                arr = arr.value;
            else if (typeof arr === 'object' && arr) {
                let step = Object.entries(arr).filter((e, i) => evalApply(ctx, flt, [e[1], i, e[0]], { index: i, key: e[0] }));
                if (sorts)
                    step = sort$1(ctx, step, sorts, (c, b, v) => evalApply(c, b, [v[1], v[0]], { key: v[0] }));
                return step.reduce((a, c) => (a[c[0]] = c[1], a), {});
            }
            else
                return [];
        }
        return filter({ value: arr }, flt, sorts, groups, ctx).value;
    }), simple(['source'], (_name, values, _opts, ctx) => {
        const [val, app] = values;
        let source = toDataSet(val);
        if (isApplication(app))
            return evalApply(ctx, app, [], { source });
        return source;
    }), simple(['group'], (_name, values, _opts, ctx) => {
        let [arr, groups] = values;
        if (!Array.isArray(arr)) {
            if (arr && Array.isArray(arr.value))
                arr = arr.value;
            else
                return {};
        }
        return filter({ value: arr }, null, null, groups, ctx).value;
    }), simple(['sort'], (_name, values, _opts, ctx) => {
        let [arr, sorts] = values;
        if (!Array.isArray(arr)) {
            if (arr && Array.isArray(arr.value))
                arr = arr.value;
            else if (arr && typeof arr === 'object') {
                if (!sorts)
                    sorts = [{ a: { r: { p: '@', k: ['key'] } } }];
                return sort$1(ctx, Object.entries(arr), sorts, (c, b, v) => evalApply(c, b, [v[1], v[0]], { key: v[0] })).reduce((a, c) => (a[c[0]] = c[1], a), {});
            }
            else
                return {};
        }
        if (!sorts)
            sorts = [{ a: { r: { k: ['_'] } } }];
        return sort$1(ctx, arr.slice(), sorts);
    }), simple(['time-span', 'time-span-ms'], (_name, args, opts) => {
        const namedArgs = opts || {};
        const span = isDateRel(args[0]) && isDateRel(args[1]) ? datesDiff(dateRelToDate(args[0]), dateRelToDate(args[1])) : isTimespan(args[0]) ? args[0] : 0;
        // if a unit is specified, break the span up
        if (namedArgs.unit) {
            const u = (Array.isArray(namedArgs.unit) ? namedArgs.unit : [namedArgs.unit]).map(u => {
                if (u[0] === 'y')
                    return 'y';
                else if (u[0] === 'M' || (u[0] === 'm' && u[1] !== 'i' && u[1] !== 'm'))
                    return 'M';
                else if (u[0] === 'w')
                    return 'w';
                else if (u[0] === 'd')
                    return 'd';
                else if (u[0] === 'h')
                    return 'h';
                else if (u[0] === 'm' && (!u[1] || u[1] === 'i' || u[1] === 'm'))
                    return 'm';
                else if (u[0] === 's')
                    return 's';
                else if (u[0] === 'm' && u[1] === 's')
                    return 'l';
                return '';
            }).filter(u => !!u);
            // fraction tracks what would be left for rounding
            let fraction;
            let res;
            // special case for full spans
            if (typeof span !== 'number' && !isTimespanMS(span)) {
                const us = u.join('');
                if (us === 'd') {
                    if (span.s) {
                        const from = new Date(span.s);
                        from.setHours(0);
                        from.setMinutes(0);
                        from.setSeconds(0);
                        from.setMilliseconds(0);
                        const to = new Date(+from);
                        to.setDate(1);
                        to.setFullYear(to.getFullYear() + span.d[0]);
                        to.setMonth(from.getMonth() + span.d[1]);
                        const m = to.getMonth();
                        to.setDate(from.getDate());
                        // watch out for last day of month next to longer month
                        const end = new Date(+from);
                        const endM = end.getMonth();
                        end.setDate(end.getDate() + 1);
                        if (endM !== end.getMonth()) {
                            // make sure target date is last day of month
                            to.setMonth(to.getMonth() + 1);
                            to.setDate(0);
                        }
                        if (to.getMonth() !== m)
                            to.setDate(0);
                        to.setDate(to.getDate() + span.d[2]);
                        const dist = +to - +from;
                        let d = Math.floor(dist / 86400000);
                        const r = dist % 86400000;
                        if (r >= 82800000)
                            d++;
                        res = [d];
                    }
                    else {
                        // this is an approximation
                        res[0] += span.d[0] * 365;
                        res[0] += span.d[1] * 30;
                    }
                }
                else if (u.length < 4 && (us === 'y' || us === 'yM' || us === 'yMd' || us === 'M' || us === 'Md' || us === 'd')) {
                    res = u.map(u => {
                        fraction = span.d[spanMap[u][0] + 1] / spanMap[u][1];
                        return span.d[spanMap[u][0]];
                    });
                    if (u[0] === 'M')
                        res[0] += span.d[0] * 12;
                }
            }
            // this isn't special cased, so get a number of ms
            if (!res) {
                let ms = typeof span === 'number' || isTimespanMS(span) ? timeSpanToNumber(span) : span && 's' in span ? +dateAndTimespan(new Date(span.s), span, 1) - +new Date(span.s) : (span.d[0] * timespans.y + span.d[1] * timespans.m + span.d[2] * timespans.d +
                    span.d[3] * timespans.h + span.d[4] * timespans.mm + span.d[5] * timespans.s + span.d[6]);
                res = u.map(() => 0);
                const next = { y: 'm', M: 'w', w: 'd', d: 'h', h: 'mm', m: 's' };
                const nextDiv = { y: 12, M: 4.3, w: 7, d: 24, h: 60, m: 60 };
                for (let i = 0; i < res.length; i++) {
                    const k = u[i] === 'm' ? 'mm' : u[i] === 'M' ? 'm' : u[i];
                    if (k === 'l') {
                        res[i] = ms;
                        fraction = 0;
                        break;
                    }
                    res[i] = Math.floor(ms / timespans[k]);
                    ms -= res[i] * timespans[k];
                    if (next[u[i]])
                        fraction = (ms / timespans[next[u[i]]]) / nextDiv[u[i]];
                    else if (u[i] === 's')
                        fraction = ms % 1000;
                }
            }
            // check for rounding
            if (namedArgs.round === true) {
                if (fraction >= 0.5)
                    res[res.length - 1]++;
            }
            else if ((namedArgs.round || '')[0] === 'c') {
                if (fraction > 0)
                    res[res.length - 1]++;
                // very special case for months that get rounded to a year
                if (u[0] === 'y' && u[1] === 'M' && u.length === 2 && res[1] === 12) {
                    res[0]++;
                    res[1] = 0;
                }
            }
            // check to see if stringification is needed
            if (namedArgs.string) {
                const units = { y: 'year', M: 'month', w: 'week', d: 'day', h: 'hour', m: 'minute', s: 'second', l: 'millisecond' };
                let str = '';
                for (let i = 0; i < u.length; i++) {
                    if (!res[i])
                        continue;
                    str += `${str.length ? ' ' : ''}${res[i]} ${units[u[i]]}${res[i] > 1 ? 's' : ''}`;
                }
                return str;
            }
            else
                return Array.isArray(namedArgs.unit) ? res : res[0];
        }
        else {
            if (namedArgs.string) {
                if (typeof span === 'number' || isTimespanMS(span)) {
                    let ms = timeSpanToNumber(span);
                    let res = '';
                    const order = ['w', 'd', 'h', 'mm', 's'];
                    const units = ['week', 'day', 'hour', 'minute', 'second', 'millisecond'];
                    for (let i = 0; i < order.length; i++) {
                        if (ms > timespans[order[i]]) {
                            const u = Math.floor(ms / timespans[order[i]]);
                            ms -= timespans[order[i]] * u;
                            res += `${res.length ? ' ' : ''}${u} ${units[i]}${u > 1 ? 's' : ''}`;
                        }
                    }
                    if (ms) {
                        res += `${res.length ? ' ' : ''}${ms} millisecond${ms > 1 ? 's' : ''}`;
                    }
                }
                else {
                    let res = '';
                    const units = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'];
                    for (let i = 0; i < span.d.length; i++) {
                        if (span.d[i])
                            res += `${res.length ? ' ' : ''}${span.d[i]} ${units[i]}${span.d[i] > 1 ? 's' : ''}`;
                    }
                    return res;
                }
            }
            else
                return span;
        }
    }), simple(['string', 'unparse'], (name, args, opts) => {
        const [value] = args;
        opts = opts || args[1] || {};
        if (!opts || typeof opts !== 'object')
            opts = {};
        if (name === 'unparse')
            opts = Object.assign({}, opts, { raport: 1 });
        if (opts.raport && opts.tpl)
            opts.template = 1;
        if (!opts && (value === null || value === undefined))
            return '';
        if (typeof opts === 'object') {
            if (opts.json)
                return JSON.stringify(value);
            if (opts.schema)
                return stringifySchema(value);
            else if (opts.raport) {
                let v = stringify(value, opts);
                if (v === undefined)
                    v = stringify({ v: value }, opts);
                return v;
            }
            else if (typeof value === 'string' && opts.styled)
                return style$1(value);
            else if (value == null)
                return '';
        }
        if (Array.isArray(value))
            return value.join(', ');
        let res = `${value}`;
        if (res.slice(0, 7) === '[object')
            return JSON.stringify(value);
        return res;
    }), simple(['call'], (_name, args, _opts, ctx) => {
        if (args[0] != null && typeof args[1] === 'string' && typeof args[0][args[1]] === 'function') {
            const obj = args.shift();
            const name = args.shift();
            return obj[name].apply(obj, args);
        }
        if (typeof args[0] === 'function') {
            const fn = args.shift();
            return fn.apply(null, args);
        }
        if (isValue(args[0])) {
            return evalApply(ctx, args[0], args.slice(1));
        }
    }), simple(['intersect'], (_name, [left, right]) => {
        if (!Array.isArray(left) || !Array.isArray(right))
            return [];
        const res = [];
        let el;
        for (let i = 0; i < left.length; i++) {
            el = left[i];
            if (~right.indexOf(el) && !~res.indexOf(el))
                res.push(el);
        }
        for (let i = 0; i < right.length; i++) {
            el = right[i];
            if (!~res.indexOf(el) && ~left.indexOf(el))
                res.push(el);
        }
        return res;
    }), simple(['let'], (_name, [name, value], _opts, ctx) => {
        return safeSet(ctx, name, value, true);
    }), simple(['set'], (_name, [name, value], _opts, ctx) => {
        return safeSet(ctx, name, value);
    }), simple(['similarity'], (_name, [left, right, threshhold, fudges]) => {
        return similarity(`${left || ''}`, `${right || ''}`, threshhold, fudges);
    }), simple(['similar'], (_name, [left, right, threshhold, fudges]) => {
        return similar(`${left || ''}`, `${right || ''}`, threshhold, fudges);
    }), simple(['overlap'], (_name, [left, right, threshhold]) => {
        return overlap(`${left || ''}`, `${right || ''}`, threshhold);
    }), simple(['validate', 'valid'], (name, [left, right, mode], opts) => {
        const res = validate$2(left, right, mode || (opts === null || opts === void 0 ? void 0 : opts.mode) || ((opts === null || opts === void 0 ? void 0 : opts.strict) && 'strict'));
        if (name === 'valid')
            return res === true;
        else
            return res;
    }), simple(['inspect'], (_name, [v, mode], opts) => {
        if ((mode || (opts === null || opts === void 0 ? void 0 : opts.mode)) === 'schema')
            return stringifySchema(inspect(v, opts === null || opts === void 0 ? void 0 : opts.flat));
        else
            return inspect(v);
    }), simple(['diff'], (_, [left, right, equal], opts, ctx) => {
        equal = equal || (opts === null || opts === void 0 ? void 0 : opts.equal);
        if (equal && isApplication(equal)) {
            const eq = equal;
            equal = (l, r) => evalApply(ctx, eq, [l, r]);
        }
        return diff(left, right, equal);
    }), simple(['label-diff'], (_, [diff, label], opts) => {
        return labelDiff(diff, label, opts);
    }));
    // math
    registerOperator(simple(['+', 'add'], (_name, values, _opts, ctx) => {
        var _a;
        if (values.length === 1) {
            if (isDateRel(values[0]))
                return +dateRelToDate(values[0]);
            else if (!values[0])
                return 0;
            return parseFloat(values[0]);
        }
        if (Array.isArray(values[0]))
            return values[0].concat.apply(values[0], values.slice(1));
        else if (isDateRel(values[0]) && values.length > 1 && values.slice(1).reduce((a, c) => a && isTimespan(c), true))
            return values.slice(1).reduce((a, c) => dateAndTimespan(a, c, 1), dateRelToDate(values[0]));
        else if (typeof values[0] !== 'number' && values.length > 1 && isTimespan(values[0]))
            return values.slice(1).reduce((a, c) => addTimespan(a, c), values[0]);
        else if (values.reduce((a, c) => a && typeof c === 'object' && !isDateRel(c), true))
            return Object.assign.apply(Object, [{}].concat(values));
        const num = values.reduce((a, c) => a && isNum(c), true);
        if (num) {
            if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.round)
                return +values.reduce((a, c) => +round(a + +c, ctx.special.round), 0);
            else
                return values.reduce((a, c) => a + +c, 0);
        }
        else {
            return values.reduce((a, c) => a + (c === undefined || c === null ? '' : c), '');
        }
    }), simple(['num'], (_name, [v]) => {
        let match;
        if (match = hasNum.exec(v))
            return +match[1];
        return parseInt(v);
    }), simple(['-', 'subtract'], (_name, values, _opts, ctx) => {
        var _a;
        const first = values.shift();
        if (!values.length)
            return -first;
        if (isDateRel(first)) {
            if (values.reduce((a, c) => a && isDateRel(c), true))
                return values.reduce((a, c) => a - +dateRelToDate(c), +dateRelToDate(first));
            if (values.reduce((a, c) => a && isTimespan(c), true))
                return values.reduce((a, c) => dateAndTimespan(a, c, -1), dateRelToDate(first));
        }
        if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.round)
            return values.reduce((a, c) => +round(a - (!isNum(c) ? 0 : +c), ctx.special.round), !isNum(first) ? 0 : +first);
        else
            return values.reduce((a, c) => a - (!isNum(c) ? 0 : +c), !isNum(first) ? 0 : +first);
    }), simple(['*', 'multiply'], (_name, values, _opts, ctx) => {
        const first = values.shift();
        if (!isNum(first)) {
            if (values.length === 1 && isNum(values[0]) && +values[0] > 0) {
                if (typeof first === 'string') {
                    let s = '';
                    for (let i = 0; i < values[0]; i++)
                        s += first;
                    return s;
                }
                else if (Array.isArray(first) && +values[0] < 10000 && first.length < 1000) {
                    const res = [];
                    for (let i = 0; i < values[0]; i++)
                        res.push.apply(res, first);
                    return res;
                }
            }
            return 0;
        }
        if (ctx.special.round)
            return values.reduce((a, c) => +round(a * (!isNum(c) ? 0 : +c), ctx.special.round), +first);
        else
            return values.reduce((a, c) => a * (!isNum(c) ? 0 : +c), +first);
    }), simple(['/', '/%', 'divide', 'intdiv'], (name, values, _opts, ctx) => {
        var _a;
        const first = values.shift();
        if (isNaN(first))
            return 0;
        if (name.length > 1 || name === 'intdiv')
            return values.reduce((a, c) => Math.floor(a / (isNaN(c) ? 1 : +c)), +first);
        if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.round)
            return values.reduce((a, c) => +round(a / (isNaN(c) ? 1 : +c), ctx.special.round), +first);
        else
            return values.reduce((a, c) => a / (isNaN(c) ? 1 : +c), +first);
    }), simple(['%', 'modulus'], (_name, values) => {
        const first = values.shift();
        return values.reduce((a, c) => a % (isNaN(c) ? 1 : +c), isNaN(first) ? 0 : +first);
    }), simple(['pow', '**'], (_name, values, _opts, ctx) => {
        var _a;
        const pow = values.pop();
        const first = Math.pow(values.pop(), pow);
        if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.round)
            return values.reverse().reduce((a, c) => +round(Math.pow(c, a), ctx.special.round), first);
        else
            return values.reverse().reduce((a, c) => Math.pow(c, a), first);
    }), simple(['abs'], (_name, values) => {
        if (typeof values[0] !== 'number')
            return values[0];
        return Math.abs(values[0]);
    }), simple(['round'], (_name, [num, precision, method]) => {
        if (precision !== undefined || roundDefaults['all-numeric'])
            return +round(num, { places: precision, method: method });
        else
            return Math.round(num);
    }), simple(['floor'], (_name, values) => {
        return Math.floor(values[0]);
    }), simple(['ceil'], (_name, values) => {
        return Math.ceil(values[0]);
    }), simple(['rand', 'random'], (_name, [min, max, dec]) => {
        let res;
        if (min == null)
            return Math.random();
        else if (typeof max !== 'number')
            res = Math.random() * min;
        else if (typeof max === 'number')
            res = Math.random() * (max - min) + min;
        if (max === true || dec === true)
            return res;
        else
            return Math.round(res);
    }));
    // string
    function pad(where, str, count, pad) {
        if (typeof str !== 'string')
            str = '' + str;
        if (!isNum(count))
            return str;
        if (!pad)
            pad = ' ';
        if (typeof pad !== 'string')
            pad = '' + pad;
        if (pad.length < 1)
            pad = ' ';
        const ct = (count - str.length) / 2;
        for (let i = 0; str.length < count; i++) {
            if (where === 'l')
                str = pad + str;
            else if (where === 'r')
                str = str + pad;
            else if (i < ct)
                str = pad + str;
            else
                str = str + pad;
        }
        return str;
    }
    const triml = /^\s*/;
    const trimr = /\s*$/;
    const escapeRe = /([\.\[\]\{\}\(\)\^\$\*\+\-])/g;
    registerOperator(simple(['eval'], (_name, [v], opts, ctx) => {
        if (opts === null || opts === void 0 ? void 0 : opts.template)
            return template$2((opts === null || opts === void 0 ? void 0 : opts.context) || ctx, v);
        else
            return evaluate((opts === null || opts === void 0 ? void 0 : opts.context) || ctx, v);
    }), simple(['padl', 'padr', 'pad'], (name, args) => {
        let [str, count, val] = args;
        return pad(name === 'padl' ? 'l' : name === 'padr' ? 'r' : 'c', str, count, val);
    }), simple(['trim', 'triml', 'trimr'], (name, args) => {
        let [str] = args;
        str = '' + str;
        if (name === 'trim' || name === 'trimr')
            str = str.replace(trimr, '');
        if (name === 'trim' || name === 'triml')
            str = str.replace(triml, '');
        return str;
    }), simple(['slice', 'substr'], (_name, [src, start, end], _opts, ctx) => {
        if (src && typeof src.slice === 'function')
            return src.slice(start, end);
        else {
            const op = getOperator('string');
            if (op)
                return `${op.apply('string', [src], undefined, ctx)}`.slice(start, end);
        }
    }), simple(['len', 'length'], (_name, [src]) => {
        if (typeof src === 'string' || src && 'length' in src)
            return src.length;
        return 0;
    }), simple(['replace', 'replace-all'], (name, [str, find, rep, flags]) => {
        str = `${str}`;
        const re = typeof flags === 'string';
        if (name === 'replace-all' || re) {
            return str.replace(new RegExp(re ? find : find.replace(escapeRe, '\\$1'), (name === 'replace' || (flags && ~flags.indexOf('g')) ? flags : `${flags || ''}g`) || 'g'), rep);
        }
        else {
            return str.replace(find, rep);
        }
    }), simple(['reverse'], (_name, [src]) => {
        if (typeof src === 'string') {
            let r = '';
            for (let i = 0; i < src.length; i++)
                r = src[i] + r;
            return r;
        }
        else if (Array.isArray(src)) {
            return src.slice().reverse();
        }
    }), simple(['wrap-count'], (_name, [str, width, font], opts, ctx) => {
        var _a;
        let w = width || (opts === null || opts === void 0 ? void 0 : opts.width);
        const avail = safeGet(ctx, '@placement.availableX') || 48;
        if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.widget) {
            const ww = ctx.special.widget.width;
            if (ww) {
                if (ww === 'grow')
                    w = avail;
                else if (typeof ww === 'number')
                    w = ww;
                else if (typeof ww === 'object' && typeof ww.percent === 'number')
                    w = (ww.percent / 100) * avail;
                else if (typeof ww === 'object' && typeof ww.x === 'string')
                    w = evaluate(ctx, ww.x);
            }
        }
        if (!w)
            w = avail;
        font = font || (opts === null || opts === void 0 ? void 0 : opts.font) || safeGet(ctx, '@widget.font');
        if (opts) {
            font = Object.assign({}, font);
            for (const k of ['family', 'size', 'line', 'metric', 'break-word'])
                if (k in opts)
                    font[k] = opts[k];
        }
        return measure(str, w, { context: ctx }, font);
    }), simple(['keys'], (_name, [src, proto]) => {
        if (!src)
            return [];
        if (proto) {
            const res = [];
            for (const k in src)
                res.push(k);
            return res;
        }
        else {
            return Object.keys(src);
        }
    }), simple(['values'], (_name, [src]) => {
        if (!src)
            return [];
        return Object.values(src);
    }), simple(['date'], (_name, args, opts, ctx) => {
        let [v, t] = args;
        if (typeof opts !== 'object' || !opts)
            opts = {};
        let res;
        if (v !== undefined) {
            if (isDateRel(v))
                res = dateRelToDate(v);
            else if (typeof v === 'string') {
                let dt = parseDate(v);
                if (isDateRel(dt)) {
                    res = dt;
                }
                else {
                    if (!dt)
                        dt = new Date(v);
                    if (isNaN(dt)) {
                        let val = evaluate(ctx, ~v.indexOf('#') ? v : `#${v}#`);
                        if (isDateRel(val)) {
                            if (opts.rel || opts.parse)
                                res = val;
                            else
                                res = dateRelToDate(val);
                        }
                    }
                }
            }
            if (!res)
                res = new Date(v);
        }
        else
            res = new Date();
        if ((opts.rel || opts.parse) && isDateRel(res)) {
            let rel = dateRelToExactRange(res);
            if (typeof t === 'string')
                t = parseTime(t);
            if (Array.isArray(t)) {
                const f = rel.f;
                f[3] = t[0], f[4] = t[1], f[5] = t[2], f[6] = t[3];
                t = t[4];
            }
            if (typeof t === 'number') {
                if (opts.shift) {
                    const diff = (+rel.f[7] || 0) - t;
                    const dt = dateRelToDate(rel);
                    dt.setMinutes(dt.getMinutes() - diff);
                    rel = dateRelToExactRange(dt);
                }
                rel.f[7] = t;
                res = rel;
            }
        }
        else {
            const rdt = isDateRel(res) ? dateRelToDate(res) : res;
            if ('y' in opts && !isNaN(opts.y))
                rdt.setFullYear(opts.y);
            const y = rdt.getFullYear();
            if ('m' in opts && !isNaN(opts.m)) {
                rdt.setMonth(+opts.m - 1);
                if (opts.clamp && rdt.getFullYear() !== y) {
                    rdt.setFullYear(y);
                    rdt.setMonth(11);
                }
            }
            const m = rdt.getMonth();
            if ('d' in opts && !isNaN(opts.d)) {
                rdt.setDate(opts.d);
                if (opts.clamp && (rdt.getMonth() !== m || rdt.getFullYear() !== y)) {
                    rdt.setDate(1);
                    rdt.setFullYear(y);
                    rdt.setMonth(m + 1);
                    rdt.setDate(0);
                }
            }
            if (t) {
                if (res === v) {
                    if (typeof v === 'string') {
                        const dt = parseDate(v);
                        if (dt && isDateRel(dt))
                            res = dateRelToDate(dt);
                        else
                            res = new Date(v);
                    }
                    else
                        res = new Date(v);
                }
                if (typeof t === 'string')
                    t = parseTime(t);
                if (Array.isArray(t)) {
                    rdt.setHours(t[0] || 0, t[1] || 0, t[2] || 0, t[3] || 0);
                    if (t[4] != null) {
                        const offset = -rdt.getTimezoneOffset() - t[4];
                        rdt.setMinutes(rdt.getMinutes() + offset);
                    }
                }
                else if (typeof t === 'number') {
                    const offset = -rdt.getTimezoneOffset() - t;
                    rdt.setMinutes(rdt.getMinutes() + offset);
                }
            }
            res = rdt;
        }
        if (res instanceof Date && isNaN(+res))
            return undefined;
        return res;
    }), simple(['interval'], (_name, [v], _opts, ctx) => {
        return evaluate(ctx, ~v.indexOf('#') ? v : `#${v}#`);
    }), simple(['upper', 'lower'], (name, [v]) => {
        v = v == null ? '' : v;
        return name === 'upper' ? `${v}`.toUpperCase() : `${v}`.toLowerCase();
    }), simple(['format', 'fmt'], (_name, args, opts, ctx) => {
        let [v, fmt, ...s] = args;
        const op = formats$1[fmt];
        if (!op) {
            const op = getOperator(fmt);
            if (op) {
                const args = [v, ...s];
                if (op.type === 'aggregate')
                    return op.apply(fmt, Array.isArray(v) ? v : [v], s.map(v => ({ v })), (opts || virtualFormats[fmt]), ctx);
                if (op.type === 'checked') {
                    for (let i = 0; i < args.length; i++) {
                        const res = op.checkArg(fmt, i, args.length - 1, args[i], (opts || virtualFormats[fmt]), ctx, { v: args[i] });
                        if (typeof res !== 'object' || !('result' in res))
                            continue;
                        else
                            return res.result;
                    }
                    return op.apply(fmt, args, (opts || virtualFormats[fmt]), ctx);
                }
                return op.apply(fmt, args, (opts || virtualFormats[fmt]), ctx);
            }
            else
                return `${v}`;
        }
        else
            return op.apply(v, s, (opts || op.defaults));
    }), simple(['set-defaults'], (_name, [type, name], opts, ctx) => {
        if (type === 'format' && typeof name === 'string') {
            const fmt = formats$1[name];
            if (fmt)
                return Object.assign(fmt.defaults, opts);
            const vfmt = virtualFormats[name];
            if (vfmt)
                return Object.assign(vfmt.defaults, opts);
        }
        else if (type === 'round') {
            if (opts === null || opts === void 0 ? void 0 : opts.context) {
                if (opts === null || opts === void 0 ? void 0 : opts.unset) {
                    if (ctx.special)
                        delete ctx.special.round;
                }
                else
                    (ctx.special || (ctx.special = {})).round = Object.assign({}, opts, { context: undefined });
            }
            else
                Object.assign(roundDefaults, opts);
        }
        else if (type === 'generate') {
            Object.assign(generateDefaults, opts);
        }
    }), simple(['parse'], (_name, args, opts) => {
        opts = opts || args[1] || {};
        if (!opts || typeof opts !== 'object')
            opts = {};
        const [v] = args;
        if (opts.date)
            return parseDate(v, opts);
        else if (opts.template || opts.tpl)
            return parse$3(v, opts);
        else if (opts.time)
            return parseTime(v, opts);
        else if (opts.expr)
            return parseExpr(v, opts);
        else if (opts.schema)
            return parseSchema(v);
        else if (opts.range)
            return range(v, opts);
        else if (opts.xml)
            return parse$1(v, opts.strict);
        else if (opts.csv) {
            if (opts.detect)
                opts = Object.assign(detect(v), opts);
            return parse$2(v, opts);
        }
        else if (opts.base64)
            return atob(v);
        else
            return parse$4(v, opts);
    }), simple(['detect-delimiters'], (_name, [data]) => {
        if (typeof data !== 'string')
            return {};
        return detect(data);
    }));
    // short circuiting
    registerOperator({
        type: 'checked',
        names: ['and', '&&'],
        checkArg(_name, _i, _total, value) {
            if (value)
                return 'continue';
            else
                return { result: value };
        },
        apply(_name, args) {
            return args[args.length - 1]; // passed the check, all is well
        },
    }, {
        type: 'checked',
        names: ['or', '||', '??'],
        checkArg(name, _i, _total, value) {
            if (name === '??' ? value != null : value)
                return { result: value };
            else
                return 'continue';
        },
        apply(name) {
            return name === '??' ? undefined : false; // if we made it this far, none were true
        },
    }, {
        type: 'checked',
        names: ['if', 'unless'],
        checkArg(name, i, last, value) {
            if (i % 2 === 0) {
                if (i === last)
                    return { result: value }; // else case
                else if (name === 'if' ? !value : value)
                    return { skip: 1 }; // non-matching branch, skip next
                else
                    return 'continue'; // matching, carry on to next
            }
            else
                return { result: value }; // odd branch that wasn't skipped means previous condition matched
        },
        apply() { }
    }, {
        type: 'checked',
        names: ['case', 'switch'],
        checkArg(_name, i, last, value, _opts, ctx, ast) {
            if (i === 0) { // set the value and move to the next
                (ctx.special || (ctx.special = {})).case = value;
                return 'continue';
            }
            else if (i % 2 === 1) {
                if (i === last)
                    return { result: value }; // default case
                if (equals(value, ctx.special.case))
                    return 'continue';
                if (isValue(ast) && 'op' in ast && value === true)
                    return 'continue'; // operators can also check for true
                if (isValue(value)) {
                    const v = evalValue(ctx, value);
                    if (equals(v, ctx.special.case))
                        return 'continue';
                    if (v === true)
                        return 'continue';
                }
                return { skip: 1 };
            }
            else
                return { result: value }; // odd branch
        },
        apply() { },
        extend: true,
    }, {
        type: 'checked',
        names: ['each'],
        checkArg(_name, i, last, value) {
            if (i === 0) {
                if (Array.isArray(value) && value.length || value && typeof value === 'object' && Object.keys(value).length)
                    return 'continue';
                else
                    return { skip: 1 };
            }
            else if (i === 1)
                return { skip: last - i, value };
            else if (i === last)
                return { result: value };
            else if (i % 2 === 0) { // condition
                if (value)
                    return 'continue';
                else
                    return { skip: 1 };
            }
            else
                return { result: value };
        },
        apply(_name, [value, body], opts, ctx) {
            if (Array.isArray(value)) {
                const last = value.length - 1;
                return value.map((v, i) => evalApply(extend$2(ctx, { value: v, special: { last, index: i, key: i, 'last-key': last } }), body, [v, i])).join((opts === null || opts === void 0 ? void 0 : opts.join) || '');
            }
            else if (typeof value === 'object' && value) {
                const entries = Object.entries(value);
                const lastKey = entries[entries.length - 1][0];
                const last = entries.length - 1;
                return Object.entries(value).map(([k, v], i) => evalApply(extend$2(ctx, { value: v, special: { last, 'last-key': lastKey, index: i, key: k } }), body, [v, k])).join('');
            }
            else {
                return '';
            }
        }
    }, {
        type: 'checked',
        names: ['with'],
        checkArg(_name, i, last, value) {
            if (i === 0 && value && typeof value === 'object')
                return 'continue';
            else if (i === 1)
                return { skip: last - i, value };
            else if (i === last)
                return { result: value };
            else if (i % 2 === 0) {
                if (value)
                    return 'continue';
                else
                    return { skip: 1 };
            }
            else
                return { result: value };
        },
        apply(_name, [value, body], _opts, ctx) {
            return evalApply(extend$2(ctx, { value }), body, [value]);
        }
    }, {
        type: 'checked',
        names: ['coalesce', 'coalesce-truth'],
        checkArg(name, _i, _last, value) {
            if (name === 'coalesce' && value !== undefined && value !== null)
                return { result: value };
            else if (value)
                return { result: value };
            else
                return 'continue';
        },
        apply() { }
    });
    // aggregates
    registerOperator({
        type: 'aggregate',
        names: ['avg'],
        apply(_name, arr, args, _opts, ctx) {
            var _a;
            if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.round)
                return +round(arr.reduce((a, c) => +round(a + num(args[0] ? evalApply(ctx, args[0], [c]) : c)), 0) / arr.length);
            else
                return arr.reduce((a, c) => a + num(args[0] ? evalApply(ctx, args[0], [c]) : c), 0) / arr.length;
        },
    }, {
        type: 'aggregate',
        names: ['sum'],
        apply(_name, arr, args, _opts, ctx) {
            var _a;
            if ((_a = ctx.special) === null || _a === void 0 ? void 0 : _a.round)
                return arr.reduce((a, c) => +round(a + num(args[0] ? evalApply(ctx, args[0], [c]) : c)), 0);
            else
                return arr.reduce((a, c) => a + num(args[0] ? evalApply(ctx, args[0], [c]) : c), 0);
        }
    }, {
        type: 'aggregate',
        names: ['count'],
        apply(_name, arr, args, _opts, ctx) {
            if (args.length)
                return arr.filter((e, i) => evalApply(ctx, args[0], [e, i])).length;
            else
                return arr.length;
        }
    }, {
        type: 'aggregate',
        names: ['min', 'max'],
        apply(name, arr, args, _opts, ctx) {
            if (isApplication(args[0]))
                arr = arr.map(e => evalApply(ctx, args[0], [e]));
            else if (args.length && !arr.length)
                arr = args.map(a => evalParse(ctx, a));
            if (!arr.length)
                return 0;
            return Math[name].apply(Math, arr.filter(e => !isNaN(e)));
        }
    }, {
        type: 'aggregate',
        names: ['first', 'nth', 'last'],
        apply(name, arr, args, _opts, ctx) {
            let val;
            let apply = 0;
            if (name === 'first')
                val = arr[0];
            else if (name === 'last')
                val = arr[arr.length - 1];
            else if (args[0]) {
                const i = evalParse(ctx, args[0]);
                if (typeof i === 'number') {
                    val = i < 0 ? arr[arr.length + i] : arr[i - 1];
                    apply = 1;
                }
            }
            if (args[apply])
                val = evalParse(ctx, args[apply]);
            return val;
        }
    }, {
        type: 'aggregate',
        names: ['map'],
        apply(_name, arr, args, opts, ctx) {
            if (!args[0])
                return arr;
            let v;
            let app;
            if (isApplication(args[0]))
                v = arr, app = evalParse(ctx, args[0]);
            else if (isApplication(args[1]))
                v = evalParse(ctx, args[0]), app = evalParse(ctx, args[1]);
            if ((Array.isArray(v) || v && '0' in v) && isApplication(app)) {
                const res = Array.prototype.map.call(v, (e, i) => evalApply(ctx, app, [e, i], { index: i, key: i }));
                if (opts && opts.flat)
                    return flatten(res, opts.flat);
                return res;
            }
            else if (v && typeof v === 'object' && isApplication(app)) {
                if (opts && opts.array) {
                    const res = Object.entries(v).map((p, i) => evalApply(ctx, app, [p[1], i, p[0]], { index: i, key: p[0] }));
                    if (opts && opts.flat)
                        return flatten(res, opts.flat);
                    return res;
                }
                if (opts && opts.entries)
                    return Object.entries(v).reduce((a, p, i) => {
                        const r = evalApply(ctx, app, [p[1], i, p[0]], { index: i, key: p[0] });
                        if (r === null)
                            return a;
                        if (Array.isArray(r) && r.length === 2 && typeof r[0] === 'string')
                            a.push(r);
                        else
                            a.push([p[0], r]);
                        return a;
                    }, []);
                const res = {};
                Object.entries(v).forEach((e, i) => {
                    const r = evalApply(ctx, app, [e[1], i, e[0]], { index: i, key: e[0] });
                    if (Array.isArray(r) && r.length === 2 && typeof r[0] === 'string')
                        res[r[0]] = r[1];
                    else if (r == null)
                        return;
                    else
                        res[e[0]] = r;
                });
                return res;
            }
        }
    }, {
        type: 'aggregate',
        names: ['index'],
        apply(_name, arr, args, opts, ctx) {
            if (!args[0])
                return {};
            const many = opts && opts.many;
            return arr.reduce((a, c, i) => _indexPair(a, evalApply(ctx, args[0], [c, i], { index: i, all: a }), c, many), {});
        },
    }, {
        type: 'aggregate',
        names: ['reduce'],
        apply(_name, arr, args, _opts, ctx) {
            if (!args[0])
                return arr;
            return arr.reduce((a, c, i) => evalApply(ctx, args[0], [a, c, i]), evalParse(ctx, args[1]));
        }
    }, {
        type: 'aggregate',
        names: ['unique', 'unique-map'],
        apply(name, arr, args, _opts, ctx) {
            const seen = [];
            const res = [];
            for (const e of arr) {
                const f = args[0] ? evalApply(ctx, args[0], [e]) : e;
                if (!~seen.indexOf(f)) {
                    seen.push(f);
                    res.push(e);
                }
            }
            return name === 'unique' ? res : seen;
        }
    }, {
        type: 'aggregate',
        names: ['join'],
        apply(_name, arr, args, _opts, ctx) {
            if (isApplication(args[0])) {
                arr = arr.map(e => evalApply(ctx, args[0], [e]));
                args = args.slice(1);
            }
            if (args.length > 1 && arr.length > 2)
                return [arr.slice(0, -1).join(evalParse(ctx, args[0])), arr[arr.length - 1]].join(evalParse(ctx, args[1]));
            else if (args.length > 2 && arr.length === 2)
                return arr.join(evalParse(ctx, args[2]));
            return arr.join(evalParse(ctx, args[0]));
        }
    }, {
        type: 'aggregate',
        names: ['find'],
        apply(_name, arr, args, _opts, ctx) {
            if (!args[0])
                return;
            else if (isApplication(args[0]))
                return arr.find((e, i) => evalApply(ctx, args[0], [e, i], { index: i, key: i }));
            else if (isApplication(args[1])) {
                const v = evalParse(ctx, args[0]);
                if (Array.isArray(v))
                    return v.find((e, i) => evalApply(ctx, args[1], [e, i], { index: i, key: i }));
                else if (typeof v === 'object' && v) {
                    const e = Object.entries(v).find((e, i) => evalApply(ctx, args[1], [e[1], i, e[0]], { index: i, key: e[0] }));
                    if (e)
                        return e[1];
                }
            }
            else {
                const v = evalParse(ctx, args[0]);
                return arr.find(e => e == v);
            }
        }
    }, {
        type: 'aggregate',
        names: ['flatten'],
        apply(_name, arr, args, opts, ctx) {
            return flatten(arr, (args.length > 0 ? evalParse(ctx, args[0]) : 0) || (opts === null || opts === void 0 ? void 0 : opts.flat));
        }
    }, {
        type: 'aggregate',
        names: ['block'],
        apply(_name, _arr, args, opts, ctx) {
            const last = args.length - 1;
            if (last < 0)
                return;
            const c = extend$2(ctx, { locals: opts && opts.implicit ? ctx.locals || {} : {}, fork: !ctx.locals });
            for (let i = 0; i < last; i++)
                evalParse(c, args[i]);
            const res = evalParse(c, args[last]);
            if (opts && opts.implicit)
                ctx.locals = c.locals;
            return res;
        },
        value: true,
    });
    function flatten(n, levels = 1) {
        let res = n || [];
        const count = typeof levels !== 'number' ? 1 : levels;
        for (let i = 0; i < count; i++) {
            if (res.find(v => Array.isArray(v)))
                res = [].concat(...res);
            else
                return res;
        }
        return res;
    }
    function fmtDate(n, fmt) {
        if (typeof n === 'string') {
            const d = parseDate(n);
            if (d)
                n = d;
        }
        return date$1(isDateRel(n) ? dateRelToExactRange(n) : n, fmt);
    }
    function _parseRange(ctx, range$1) {
        const map = ctx.root._ranges || (ctx.root._ranges = {});
        if (range$1 in map)
            return map[range$1];
        return (map[range$1] = range(range$1));
    }
    function _indexPair(res, value, current, many) {
        if (Array.isArray(value)) {
            if (value.length === 0)
                return res;
            else if (value.length === 2) {
                const [k, v] = value;
                if (Array.isArray(k)) {
                    for (const kk of k) {
                        if (many) {
                            if (kk in res)
                                res[kk].push(v);
                            else
                                res[kk] = [v];
                        }
                        else
                            res[kk] = v;
                    }
                }
                else {
                    if (many) {
                        if (k in res)
                            res[k].push(v);
                        else
                            res[k] = [v];
                    }
                    else
                        res[k] = v;
                }
            }
        }
        else if (typeof value === 'object') {
            const v = value;
            if ('many' in v && Array.isArray(v.many))
                for (const i of v.many)
                    _indexPair(res, i, current, many);
            else if ('key' in v || 'keys' in v)
                _indexPair(res, [v.key || v.keys, v.value || current], current, many);
        }
        else {
            if (many) {
                if (value in res)
                    res[value].push(current);
                else
                    res[value] = [current];
            }
            else
                res[value] = current;
        }
        return res;
    }
    // basic formats
    registerFormat('dollar', function (n, [dec, group, sign, neg], opts) {
        var _a, _b, _c, _d;
        return dollar(n, undefined, (_a = dec !== null && dec !== void 0 ? dec : opts === null || opts === void 0 ? void 0 : opts.dec) !== null && _a !== void 0 ? _a : this.defaults.dec, (_b = group !== null && group !== void 0 ? group : opts === null || opts === void 0 ? void 0 : opts.group) !== null && _b !== void 0 ? _b : this.defaults.group, (_c = sign !== null && sign !== void 0 ? sign : opts === null || opts === void 0 ? void 0 : opts.sign) !== null && _c !== void 0 ? _c : this.defaults.sign, (_d = neg !== null && neg !== void 0 ? neg : opts === null || opts === void 0 ? void 0 : opts.neg) !== null && _d !== void 0 ? _d : this.defaults.neg);
    }, { dec: 2, group: ',', sign: '$', neg: 'sign' });
    registerFormat('date', function (n, [fmt], opts) {
        var _a;
        return fmtDate(n, (_a = fmt !== null && fmt !== void 0 ? fmt : opts === null || opts === void 0 ? void 0 : opts.format) !== null && _a !== void 0 ? _a : this.defaults.format);
    }, { format: 'yyyy-MM-dd' });
    registerFormat('time', function (n, [fmt], opts) {
        var _a;
        return fmtDate(n, (_a = fmt !== null && fmt !== void 0 ? fmt : opts === null || opts === void 0 ? void 0 : opts.format) !== null && _a !== void 0 ? _a : this.defaults.format);
    }, { format: 'HH:mm:ss' });
    registerFormat('timestamp', function (n, [fmt], opts) {
        var _a;
        return fmtDate(n, (_a = fmt !== null && fmt !== void 0 ? fmt : opts === null || opts === void 0 ? void 0 : opts.format) !== null && _a !== void 0 ? _a : this.defaults.format);
    }, { format: 'yyyy-MM-dd HH:mm:ss' });
    registerFormat('timestamptz', function (n, [fmt], opts) {
        var _a;
        return fmtDate(n, (_a = fmt !== null && fmt !== void 0 ? fmt : opts === null || opts === void 0 ? void 0 : opts.format) !== null && _a !== void 0 ? _a : this.defaults.format);
    }, { format: 'yyyy-MM-dd HH:mm:sszzz' });
    registerFormat('iso8601', n => {
        return fmtDate(n, 'yyyy-MM-ddTHH:mm:sszzz');
    });
    registerFormat(['integer', 'int'], function (n, [group, neg], opts) {
        var _a, _b;
        return number(n, 0, (_a = group !== null && group !== void 0 ? group : opts === null || opts === void 0 ? void 0 : opts.group) !== null && _a !== void 0 ? _a : this.defaults.group, (_b = neg !== null && neg !== void 0 ? neg : opts === null || opts === void 0 ? void 0 : opts.neg) !== null && _b !== void 0 ? _b : this.defaults.neg);
    }, { group: ',', neg: 'sign' });
    registerFormat(['number', 'num'], function (n, [dec, group, neg], opts) {
        var _a, _b, _c;
        return number(n, (_a = dec !== null && dec !== void 0 ? dec : opts === null || opts === void 0 ? void 0 : opts.dec) !== null && _a !== void 0 ? _a : this.defaults.dev, (_b = group !== null && group !== void 0 ? group : opts === null || opts === void 0 ? void 0 : opts.group) !== null && _b !== void 0 ? _b : this.defaults.group, (_c = neg !== null && neg !== void 0 ? neg : opts === null || opts === void 0 ? void 0 : opts.neg) !== null && _c !== void 0 ? _c : this.defaults.neg);
    }, { dec: 2, group: ',', neg: 'sign' });
    registerFormat('ordinal', function (n, [group], opts) {
        var _a;
        return ordinal(n, (_a = group !== null && group !== void 0 ? group : opts === null || opts === void 0 ? void 0 : opts.group) !== null && _a !== void 0 ? _a : this.defaults.group);
    }, { group: ',' });
    registerFormat('phone', n => {
        return phone(n);
    });
    registerFormat('styled', n => {
        return style$1(n);
    });
    {
        const space = /\s+/g;
        const br = /[\s;,.:"]\w/g;
        const alphaNum = /[^a-zA-Z0-9]+([a-zA-Z0-9])/g;
        const alphaNumSpace = /[^\sa-zA-Z0-9]/g;
        const camelBreak = /([a-z])([A-Z])/g;
        const spaceChar = /\s([^\s])/g;
        function normalize(s) {
            return s.replace(alphaNum, (_m, c) => c ? ` ${c}` : '').replace(alphaNumSpace, '').replace(camelBreak, (_m, c1, c2) => `${c1} ${c2}`).trim();
        }
        registerFormat('case', (n, whiches) => {
            let str = `${n || ''}`.trim();
            for (const which of whiches) {
                if (which === 'upper' || which === 'up')
                    str = str.toUpperCase();
                else if (which === 'lower' || which === 'down')
                    str = str.toLowerCase();
                else if (which === 'snake')
                    str = normalize(str).toLowerCase().replace(space, '_');
                else if (which === 'kebab')
                    str = normalize(str).toLowerCase().replace(space, '-');
                else if (which === 'pascal') {
                    const s = normalize(str);
                    str = s[0].toUpperCase() + s.toLowerCase().substr(1).replace(spaceChar, (_m, c) => (c || '').toUpperCase());
                }
                else if (which === 'camel') {
                    const s = normalize(str);
                    str = s[0].toLowerCase() + s.toLowerCase().substr(1).replace(spaceChar, (_m, c) => (c || '').toUpperCase());
                }
                else if (which === 'proper') {
                    if (/[a-z]/.test(str))
                        str = str.trim().replace(br, m => m.toUpperCase());
                    else
                        str = str.toLowerCase().trim().replace(br, m => m.toUpperCase());
                    str = (str[0] || '').toUpperCase() + str.substr(1);
                }
            }
            return str;
        });
    }
    registerFormat('hex', val => {
        if (typeof val === 'number')
            return val.toString(16);
        else {
            const str = `${val}`;
            const te = new TextEncoder();
            return Array.from(te.encode(str)).map(c => c.toString(16).padStart(2, '0')).join('');
        }
    });
    registerFormat('base', (val, [n]) => {
        try {
            return val.toString(n);
        }
        catch (_a) {
            return val;
        }
    });
    registerFormat('noxml', val => escapeHTML(`${val}`));
    registerFormat('xml', (val, [n]) => {
        if (val && typeof val === 'object')
            return objectToXML(val, n);
        else
            return val;
    });
    function objectToXML(object, indent = undefined) {
        if (Array.isArray(object))
            return _objectToXML({ values: { value: object } }, 0, indent);
        const keys = Object.keys(object);
        if (keys.length > 1)
            return _objectToXML({ root: object }, 0, indent);
        if (keys.length < 1)
            return '<root />';
        if (Array.isArray(object[keys[0]]))
            return _objectToXML({ root: object }, 0, indent);
        return _objectToXML(object, 0, indent);
    }
    function _objectToXML(val, depth, indent, propname = undefined) {
        if (Array.isArray(val)) {
            return val.reduce((xml, entry) => {
                const val = _objectToXML(entry, depth + 1, indent, propname);
                const tag = val === '' || val === undefined ? `<${propname} />` : `<${propname}>${val}${indent && /\n/.test(val) ? '\n' + pad('l', '', depth * indent, ' ') : ''}</${propname}>`;
                return `${xml}${indent && depth ? '\n' + pad('l', '', depth * indent, ' ') : ''}${tag}`;
            }, '');
        }
        if (val && typeof val === 'object') {
            return Object.entries(val).reduce((xml, [name, value]) => {
                const val = _objectToXML(value, depth + (Array.isArray(value) ? 0 : 1), indent, name);
                const tag = val === '' ? `${indent && depth ? '\n' + pad('l', '', depth * indent, ' ') : ''}<${name} />` : Array.isArray(value) ? val : `${indent && depth ? '\n' + pad('l', '', depth * indent, ' ') : ''}<${name}>${val}${indent && /\n/.test(val) ? '\n' + pad('l', '', depth * indent, ' ') : ''}</${name}>`;
                return `${xml}${tag}`;
            }, '');
        }
        return escapeHTML(val);
    }
    registerFormat('base64', val => {
        return btoa(`${val}`);
    });

    const template$1 = {v:4,t:[{t:7,e:"div",m:[{t:13,n:"class",f:"raport-wrapper",g:1},{n:"trackfocus",t:71},{n:"class-proppop",t:13,f:[{t:2,r:"~/show.proppop"}]}],f:[{t:8,r:"left"}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"top-bar",g:1},{n:"class-shrinkleft",t:13,f:[{t:2,r:"~/show.shrinkleft"}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"design actions",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Run report (CTRL+Shift+Enter)",t:13,g:1},{n:"disabled",f:[{t:2,x:{r:["report.type","report.sources.length"],s:"_0===\"delimited\"&&_1<1"}}],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.run()&&_0.set(\"tab\",\"result\")]"}}],f:[{t:8,r:"play"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Design report: modify layout and widgets",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"tab\",\"design\")]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["tab"],s:"_0!==\"result\"&&_0!==\"context\"&&_0!==\"definition\"&&_0!==\"import\"&&_0!==\"project\""}}]}],f:["Designer"]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"tab output-tab",g:1},{n:"title",f:"View report output",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"tab\",\"result\")]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"result\""}}]}],f:["Output"]}],n:50,r:"result"}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Set up initial report data",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"tab\",\"context\")]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"context\""}}]}],f:["Context"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Import/export report definition as plain text",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"tab\",\"definition\")]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"definition\""}}]}],f:["Definition"]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:["Manage data for the ",{t:2,r:"data.name"}," provided source"],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"tab\",\"import\")]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"import\""}}]}],f:["Source Data"]}],n:50,x:{r:["data","@this"],s:"_0&&_1.readLink(\"data\")"}}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"which",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.checkLink(\"import\")]"}}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1}],f:[{t:8,r:"times"}]}," Close ",{t:2,r:"data.name"}," Source Data"]}],n:50,x:{r:["data","tab"],s:"_0&&_1===\"import\""}}," ",{t:4,f:[{t:7,e:"label",m:[{t:13,n:"style",f:"margin: 0 1em;",g:1},{n:"title",f:"Display report output in a table rather than as plain delimited text.",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"~/settings.delimitedTable"}],t:13},{n:["change"],t:70,f:{r:["@this"],s:"[_0.run()]"}}]}," Table view?"]}],n:50,x:{r:["~/report.type"],s:"_0===\"delimited\""}}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@this","~/report.name","~/result","~/report.type"],s:"[_0.download((_1||\"report\")+(_3===\"delimited\"?\".csv\":\".html\"),_2,_3===\"delimited\"?\"text/csv\":\"text/html\")]"}},{n:"title",f:"Save output to a file",t:13,g:1}],f:["Save Output"]}],n:50,x:{r:["tab","~/report.type","~/settings.delimitedTable"],s:"_0===\"result\"&&(_1!==\"delimited\"||!_2)"}}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"center",g:1}],f:[{t:7,e:"a",m:[{t:13,n:"style",f:"margin-left: 1rem;",g:1},{n:"href",f:"https://github.com/evs-chris/raport",t:13,g:1},{n:"target",f:"_blank",t:13,g:1}],f:["Raport v0.24.2"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"right",g:1}],f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"style",f:"display: inline-block; margin: 0 1em; font-size: 0.8em; height: 1rem; vertical-align: middle;",g:1}],f:[{t:2,r:"~/project.name"}]}],n:50,x:{r:["~/showProjects","~/project.name"],s:"_0&&_1"}}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"ico error",g:1},{n:"title",f:["There are unsaved changes to this project (",{t:2,r:"~/project.name"},")"],t:13}],f:[{t:8,r:"warning"}]}],n:50,r:"~/projectChanged"}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Manage projects and designer settings",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"tab\",\"project\")]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"project\""}}]}],f:[{t:2,x:{r:["~/showProjects"],s:"_0?\"Project\":\"Settings\""}}]}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"raport-report center-pane",g:1},{n:"class-shrinkleft",t:13,f:[{t:2,r:"~/show.shrinkleft"}]},{n:"class-shrinkbottom",t:13,f:[{t:2,r:"~/show.shrinkbottom"}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"layout",g:1},{n:["keys"],t:70,a:{r:[],s:"[\"z\",{ctrl:true}]"},f:{r:["@this"],s:"[_0.undo(),true]"}},{n:["keys"],t:70,a:{r:[],s:"[\"Z\",{ctrl:true,shift:true}]"},f:{r:["@this"],s:"[_0.redo(),true]"}},{n:"class-pad-me",t:13,f:[{t:2,r:"~/show.pad"}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"tab designer",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["tab"],s:"_0!==\"result\"&&_0!==\"context\"&&_0!==\"definition\"&&_0!==\"import\"&&_0!==\"project\""}}]}],f:[{t:8,r:"design"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab report-context",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"context\""}}]}],f:[{t:8,r:"context"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab report-definition",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"definition\""}}]}],f:[{t:8,r:"definition"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab data-import",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"import\""}}]}],f:[{t:8,r:"data-import"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"result tab",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"result\""}}]}],f:[{t:7,e:"iframe",m:[{n:"id",f:"result",t:13,g:1},{n:"srcdoc",f:[{t:2,x:{r:["~/report.type","@style.out.fg","@style.fg","@style.out.bg","@style.bg","@this","result"],s:"_0===\"delimited\"?(\"<style>pre { padding: 0.5rem; } code { display: block; color: \"+(_1||_2)+\"; background-color: \"+(_3||_4)+\"; }</style><code><pre>\")+_6+\"</pre></code>\"+_5.frameExtra():_6"}}],t:13}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"project tab",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["tab"],s:"_0===\"project\""}}]}],f:[{t:8,r:"project"}]}]}]}," ",{t:8,r:"bottom"}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"position: absolute; left: -1000px; width: 1rem; height: 1rem;",g:1},{n:"id",f:"sizer",t:13,g:1}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"position: absolute; left: -1000px; width: 5rem; height: 5rem; overflow: auto;",g:1}],f:[{t:7,e:"textarea",m:[{n:"id",f:"text-helper",t:13},{n:"style",f:"padding: 0.5em;",t:13}]}]}]}],e:{"0":function (){return(0);},"1":function (){return(1);},"2":function (){return(2);},"3":function (){return(3);},"4":function (){return(4);},"5":function (){return(5);},"6":function (){return(6);},"7":function (){return(7);},"400":function (){return(400);},"500":function (){return(500);},"600":function (){return(600);},"700":function (){return(700);},"_0===\"delimited\"&&_1<1":function (_0,_1){return(_0==="delimited"&&_1<1);},"[_0.run()&&_0.set(\"tab\",\"result\")]":function (_0){return([_0.run()&&_0.set("tab","result")]);},"[_0.set(\"tab\",\"design\")]":function (_0){return([_0.set("tab","design")]);},"_0!==\"result\"&&_0!==\"context\"&&_0!==\"definition\"&&_0!==\"import\"&&_0!==\"project\"":function (_0){return(_0!=="result"&&_0!=="context"&&_0!=="definition"&&_0!=="import"&&_0!=="project");},"[_0.set(\"tab\",\"result\")]":function (_0){return([_0.set("tab","result")]);},"_0===\"result\"":function (_0){return(_0==="result");},"[_0.set(\"tab\",\"context\")]":function (_0){return([_0.set("tab","context")]);},"_0===\"context\"":function (_0){return(_0==="context");},"[_0.set(\"tab\",\"definition\")]":function (_0){return([_0.set("tab","definition")]);},"_0===\"definition\"":function (_0){return(_0==="definition");},"[_0.set(\"tab\",\"import\")]":function (_0){return([_0.set("tab","import")]);},"_0===\"import\"":function (_0){return(_0==="import");},"_0&&_1.readLink(\"data\")":function (_0,_1){return(_0&&_1.readLink("data"));},"[_0.checkLink(\"import\")]":function (_0){return([_0.checkLink("import")]);},"_0&&_1===\"import\"":function (_0,_1){return(_0&&_1==="import");},"[_0.run()]":function (_0){return([_0.run()]);},"_0===\"delimited\"":function (_0){return(_0==="delimited");},"[_0.download((_1||\"report\")+(_3===\"delimited\"?\".csv\":\".html\"),_2,_3===\"delimited\"?\"text/csv\":\"text/html\")]":function (_0,_1,_2,_3){return([_0.download((_1||"report")+(_3==="delimited"?".csv":".html"),_2,_3==="delimited"?"text/csv":"text/html")]);},"_0===\"result\"&&(_1!==\"delimited\"||!_2)":function (_0,_1,_2){return(_0==="result"&&(_1!=="delimited"||!_2));},"_0&&_1":function (_0,_1){return(_0&&_1);},"[_0.set(\"tab\",\"project\")]":function (_0){return([_0.set("tab","project")]);},"_0===\"project\"":function (_0){return(_0==="project");},"_0?\"Project\":\"Settings\"":function (_0){return(_0?"Project":"Settings");},"[\"z\",{ctrl:true}]":function (){return(["z",{ctrl:true}]);},"[_0.undo(),true]":function (_0){return([_0.undo(),true]);},"[\"Z\",{ctrl:true,shift:true}]":function (){return(["Z",{ctrl:true,shift:true}]);},"[_0.redo(),true]":function (_0){return([_0.redo(),true]);},"_0===\"delimited\"?(\"<style>pre { padding: 0.5rem; } code { display: block; color: \"+(_1||_2)+\"; background-color: \"+(_3||_4)+\"; }</style><code><pre>\")+_6+\"</pre></code>\"+_5.frameExtra():_6":function (_0,_1,_2,_3,_4,_5,_6){return(_0==="delimited"?("<style>pre { padding: 0.5rem; } code { display: block; color: "+(_1||_2)+"; background-color: "+(_3||_4)+"; }</style><code><pre>")+_6+"</pre></code>"+_5.frameExtra():_6);},"[_0.loadImportFile()]":function (_0){return([_0.loadImportFile()]);},"_0===\"fetch\"":function (_0){return(_0==="fetch");},"[_0.set(\"data.type\",_1?\"fetch\":undefined)]":function (_0,_1){return([_0.set("data.type",_1?"fetch":undefined)]);},"[_1.set(\"data.header\",_0?1:undefined),_1.tryImport(_1.getImportText())]":function (_0,_1){return([_1.set("data.header",_0?1:undefined),_1.tryImport(_1.getImportText())]);},"undefined":function (){return(undefined);},"[_0.editExpr(_1+\".url\",{template:true}),false]":function (_0,_1){return([_0.editExpr(_1+".url",{template:true}),false]);},"[(_0).push(\".headers\",[])]":function (_0){return([(_0).push(".headers",[])]);},"[_0.fetchData()]":function (_0){return([_0.fetchData()]);},"[(_0).splice(\"../\",_1,1)]":function (_0,_1){return([(_0).splice("../",_1,1)]);},"[_0.editExpr(_1+\".1\",{template:true}),false]":function (_0,_1){return([_0.editExpr(_1+".1",{template:true}),false]);},"[_0.editExpr(_1+\".body\",{template:true}),false]":function (_0,_1){return([_0.editExpr(_1+".body",{template:true}),false]);},"_0!==\"GET\"":function (_0){return(_0!=="GET");},"[_0.autosize(_1)]":function (_0,_1){return([_0.autosize(_1)]);},"[\"_importText\"]":function (){return(["_importText"]);},"[_0.set(\"_importdirty\",true),console.log(\"change\",_1)]":function (_0,_1){return([_0.set("_importdirty",true),console.log("change",_1)]);},"[_0.tryImport(_0.getImportText()),_0.set(\"_importdirty\",false)]":function (_0){return([_0.tryImport(_0.getImportText()),_0.set("_importdirty",false)]);},"[_0.saveProjects()]":function (_0){return([_0.saveProjects()]);},"[_1.download(_0+\".raport-proj\",_1.stringifyProject())]":function (_0,_1){return([_1.download(_0+".raport-proj",_1.stringifyProject())]);},"[_0.cloneProject()]":function (_0){return([_0.cloneProject()]);},"[_0.importProject(true)]":function (_0){return([_0.importProject(true)]);},"[_0.makeProject(true)]":function (_0){return([_0.makeProject(true)]);},"[_0.removeProject()]":function (_0){return([_0.removeProject()]);},"[_0.resetProject()]":function (_0){return([_0.resetProject()]);},"[_0.unlinkProject()]":function (_0){return([_0.unlinkProject()]);},"[_0.set(\"projectText\",_0.stringifyProject())]":function (_0){return([_0.set("projectText",_0.stringifyProject())]);},"[_0.importProject(true,_1)]":function (_0,_1){return([_0.importProject(true,_1)]);},"_0!=null":function (_0){return(_0!=null);},"[_0.makeProject()]":function (_0){return([_0.makeProject()]);},"_0===_1":function (_0,_1){return(_0===_1);},"[_0.linkProject(_1)]":function (_0,_1){return([_0.linkProject(_1)]);},"[_0.download(\"Raport Projects.json\",_0.stringifyProjects())]":function (_0){return([_0.download("Raport Projects.json",_0.stringifyProjects())]);},"[_0.importProject()]":function (_0){return([_0.importProject()]);},"[_0.loadReportFile()]":function (_0){return([_0.loadReportFile()]);},"[_1.download((_0||\"report\")+\".raport\",_1.reportToString(true,_2,_3))]":function (_0,_1,_2,_3){return([_1.download((_0||"report")+".raport",_1.reportToString(true,_2,_3))]);},"[_0.fmtAll()]":function (_0){return([_0.fmtAll()]);},"[_0.copyToClipboard(_0.reportToString(_1,_2,_3))]":function (_0,_1,_2,_3){return([_0.copyToClipboard(_0.reportToString(_1,_2,_3))]);},"_0.reportToString(_1,_2,_3)":function (_0,_1,_2,_3){return(_0.reportToString(_1,_2,_3));},"[_1.loadReportString(_0),_1.update(\"temp\")]":function (_0,_1){return([_1.loadReportString(_0),_1.update("temp")]);},"[_0.loadContextFile()]":function (_0){return([_0.loadContextFile()]);},"[_0.tryContext(_1)]":function (_0,_1){return([_0.tryContext(_1)]);},"[\"_contextText\"]":function (){return(["_contextText"]);},"[_0.addHeader()]":function (_0){return([_0.addHeader()]);},"!_0":function (_0){return(!_0);},"[_0.set(\"report.headers\",undefined)]":function (_0){return([_0.set("report.headers",undefined)]);},"[_0.push(\"report.headers\",\"\"),_0.push(\"report.fields\",\"\")]":function (_0){return([_0.push("report.headers",""),_0.push("report.fields","")]);},"[_0.fillBlankDelimitedHeaders()]":function (_0){return([_0.fillBlankDelimitedHeaders()]);},"[_0.editExpr((_1),{template:true})]":function (_0,_1){return([_0.editExpr((_1),{template:true})]);},"[true]":function (){return([true]);},"[_0.removeWidget((_1)),false]":function (_0,_1){return([_0.removeWidget((_1)),false]);},"!!_0":function (_0){return(!!_0);},"[_1.push(\"report.fields\",\"\"),_0&&_1.push(\"report.headers\",\"\")]":function (_0,_1){return([_1.push("report.fields",""),_0&&_1.push("report.headers","")]);},"[_0.editExpr((_1))]":function (_0,_1){return([_0.editExpr((_1))]);},"_0.paperSize()":function (_0){return(_0.paperSize());},"[_0===_1?_2.selectWidget(_3?\"report.overlay\":_4?\"report.watermark\":\"report\"):true]":function (_0,_1,_2,_3,_4){return([_0===_1?_2.selectWidget(_3?"report.overlay":_4?"report.watermark":"report"):true]);},"[_0.set(\"temp.hover\",\"\"),false]":function (_0){return([_0.set("temp.hover",""),false]);},"[_2!==_0?_1.set(\"shiftKey\",_2):\"\"]":function (_0,_1,_2){return([_2!==_0?_1.set("shiftKey",_2):""]);},"[_0.unlink(\"widget\"),_0.unlink(\"expr\"),_0.set(\"temp\",{name:\"report \",widget:_1?\"report.overlay\":_2?\"report.watermark\":\"report\",tree:_3})]":function (_0,_1,_2,_3){return([_0.unlink("widget"),_0.unlink("expr"),_0.set("temp",{name:"report ",widget:_1?"report.overlay":_2?"report.watermark":"report",tree:_3})]);},"_0===\"report\"||_0===\"report.watermark\"||_0===\"report.overlay\"":function (_0){return(_0==="report"||_0==="report.watermark"||_0==="report.overlay");},"[_0.set(\"temp.hover\",_1?\"report.watermark\":_2?\"report.overlay\":\"report\"),false]":function (_0,_1,_2){return([_0.set("temp.hover",_1?"report.watermark":_2?"report.overlay":"report"),false]);},"[_0.set(\"report.header\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]":function (_0){return([_0.set("report.header",undefined),_0.unlink("widget"),_0.set("temp.widget","")]);},"[_0.set(\"report.header\",{type:\"container\"})]":function (_0){return([_0.set("report.header",{type:"container"})]);},"[_0.set(\"report.footer\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]":function (_0){return([_0.set("report.footer",undefined),_0.unlink("widget"),_0.set("temp.widget","")]);},"[_0.set(\"report.footer\",{type:\"container\"})]":function (_0){return([_0.set("report.footer",{type:"container"})]);},"!_0||!/^report.(water|overlay)/.test(_0)":function (_0){return(!_0||!/^report.(water|overlay)/.test(_0));},"_0===\"page\"":function (_0){return(_0==="page");},"[_0.set(\"report.watermark\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]":function (_0){return([_0.set("report.watermark",undefined),_0.unlink("widget"),_0.set("temp.widget","")]);},"[_0.link(\"report.watermark\",\"widget\"),_0.set(\"temp.widget\",\"report.watermark\"),false]":function (_0){return([_0.link("report.watermark","widget"),_0.set("temp.widget","report.watermark"),false]);},"[_0.set(\"report.watermark\",{type:\"container\"}),_0.link(\"report.watermark\",\"widget\"),_0.set(\"temp.widget\",\"report.watermark\"),false]":function (_0){return([_0.set("report.watermark",{type:"container"}),_0.link("report.watermark","widget"),_0.set("temp.widget","report.watermark"),false]);},"[_0.set(\"report.overlay\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]":function (_0){return([_0.set("report.overlay",undefined),_0.unlink("widget"),_0.set("temp.widget","")]);},"[_0.link(\"report.overlay\",\"widget\"),_0.set(\"temp.widget\",\"report.overlay\"),false]":function (_0){return([_0.link("report.overlay","widget"),_0.set("temp.widget","report.overlay"),false]);},"[_0.set(\"report.overlay\",{type:\"container\"}),_0.link(\"report.overlay\",\"widget\"),_0.set(\"temp.widget\",\"report.overlay\"),false]":function (_0){return([_0.set("report.overlay",{type:"container"}),_0.link("report.overlay","widget"),_0.set("temp.widget","report.overlay"),false]);},"[_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]":function (_0){return([_0.unlink("widget"),_0.set("temp.widget","")]);},"/^report.(water|overlay)/.test(_0)":function (_0){return(/^report.(water|overlay)/.test(_0));},"Array.isArray(_0)":function (_0){return(Array.isArray(_0));},"/^report.water/.test(_0)":function (_0){return(/^report.water/.test(_0));},"/^report.overlay/.test(_0)":function (_0){return(/^report.overlay/.test(_0));},"\"Page Header\"":function (){return("Page Header");},"_0===\"page\"&&_1":function (_0,_1){return(_0==="page"&&_1);},"\"Page Footer\"":function (){return("Page Footer");},"[(_0).set(\".width\",typeof _1===\"number\"||_1===undefined?{percent:_1}:typeof _1===\"object\"&&\"percent\" in _1?{x:\"\"}:typeof _1===\"object\"&&\"x\" in _1?\"grow\":_2)]":function (_0,_1,_2){return([(_0).set(".width",typeof _1==="number"||_1===undefined?{percent:_1}:typeof _1==="object"&&"percent" in _1?{x:""}:typeof _1==="object"&&"x" in _1?"grow":_2)]);},"typeof _0===\"number\"||_0===undefined?\"Change to percent\":typeof _0===\"object\"&&\"percent\" in _0?\"Change to Expression\":typeof _0===\"object\"&&\"x\" in _0?\"Change to Fill/Grow\":\"Change to REM\"":function (_0){return(typeof _0==="number"||_0===undefined?"Change to percent":typeof _0==="object"&&"percent" in _0?"Change to Expression":typeof _0==="object"&&"x" in _0?"Change to Fill/Grow":"Change to REM");},"[_0.editExpr(\".width.x\"),false]":function (_0){return([_0.editExpr(".width.x"),false]);},"typeof _0===\"object\"&&\"x\" in _0":function (_0){return(typeof _0==="object"&&"x" in _0);},"typeof _0===\"number\"||_0===undefined":function (_0){return(typeof _0==="number"||_0===undefined);},"typeof _0===\"object\"&&\"percent\" in _0":function (_0){return(typeof _0==="object"&&"percent" in _0);},"_0===\"grow\"":function (_0){return(_0==="grow");},"typeof _0===\"object\"":function (_0){return(typeof _0==="object");},"_0===\"label\"":function (_0){return(_0==="label");},"_0===\"container\"":function (_0){return(_0==="container");},"[(_0).set(\".height\",typeof _1===\"number\"||_1===undefined?{percent:_1}:typeof _1===\"object\"&&\"percent\" in _1?{x:\"\"}:typeof _1===\"object\"&&\"x\" in _1?\"grow\":_1===\"grow\"&&_2===\"container\"?\"auto\":_3)]":function (_0,_1,_2,_3){return([(_0).set(".height",typeof _1==="number"||_1===undefined?{percent:_1}:typeof _1==="object"&&"percent" in _1?{x:""}:typeof _1==="object"&&"x" in _1?"grow":_1==="grow"&&_2==="container"?"auto":_3)]);},"typeof _0===\"number\"||_0===undefined?\"Change to percent\":typeof _0===\"object\"&&\"percent\" in _0?\"Change to Expression\":typeof _0===\"object\"&&\"x\" in _0?\"Change to Fill/Grow\":_0===\"grow\"&&_1===\"container\"?\"Change to Auto\":\"Change to REM\"":function (_0,_1){return(typeof _0==="number"||_0===undefined?"Change to percent":typeof _0==="object"&&"percent" in _0?"Change to Expression":typeof _0==="object"&&"x" in _0?"Change to Fill/Grow":_0==="grow"&&_1==="container"?"Change to Auto":"Change to REM");},"[_0.editExpr(\".height.x\"),false]":function (_0){return([_0.editExpr(".height.x"),false]);},"_0===\"auto\"":function (_0){return(_0==="auto");},"_0.lastKey(_1)":function (_0,_1){return(_0.lastKey(_1));},"[(_0).set(\"^^/br\",typeof _1===\"object\"?false:{x:\"\"})]":function (_0,_1){return([(_0).set("^^/br",typeof _1==="object"?false:{x:""})]);},"typeof _0===\"object\"?\"Change to Boolean\":\"Change to Expression\"":function (_0){return(typeof _0==="object"?"Change to Boolean":"Change to Expression");},"[_0.editExpr(\"^^/br.x\"),false]":function (_0){return([_0.editExpr("^^/br.x"),false]);},"typeof _0!==\"object\"":function (_0){return(typeof _0!=="object");},"_0.split(_1,2)":function (_0,_1){return(_0.split(_1,2));},"[_0.editExpr(\".border\")]":function (_0){return([_0.editExpr(".border")]);},"typeof _0===\"string\"":function (_0){return(typeof _0==="string");},"typeof _0===\"undefined\"":function (_0){return(typeof _0==="undefined");},"[(_0).set(\".border\",undefined)]":function (_0){return([(_0).set(".border",undefined)]);},"typeof _0!==\"undefined\"":function (_0){return(typeof _0!=="undefined");},"typeof _0===\"number\"":function (_0){return(typeof _0==="number");},"[(_0).set(\".border\",1)]":function (_0){return([(_0).set(".border",1)]);},"typeof _0!==\"number\"":function (_0){return(typeof _0!=="number");},"_0===1":function (_0){return(_0===1);},"[(_0).set(\".border\",[1])]":function (_0){return([(_0).set(".border",[1])]);},"_0!==1":function (_0){return(_0!==1);},"_0===2":function (_0){return(_0===2);},"[(_0).set(\".border\",[1,1])]":function (_0){return([(_0).set(".border",[1,1])]);},"_0!==2":function (_0){return(_0!==2);},"_0===4":function (_0){return(_0===4);},"[(_0).set(\".border\",[1,1,1,1])]":function (_0){return([(_0).set(".border",[1,1,1,1])]);},"[(_0).set(\".border\",\"\")]":function (_0){return([(_0).set(".border","")]);},"typeof _0!==\"string\"":function (_0){return(typeof _0!=="string");},"[(_0).set(\".font.align\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.align",typeof _1==="object"?undefined:{x:""})]);},"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\"":function (_0){return(typeof _0==="object"?"Change to value":"Change to Expression");},"[_0.editExpr(\".font.align.x\")]":function (_0){return([_0.editExpr(".font.align.x")]);},"_0!==\"image\"":function (_0){return(_0!=="image");},"[(_0).set(\".font.pre\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.pre",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.pre.x\")]":function (_0){return([_0.editExpr(".font.pre.x")]);},"[(_0).set(\".font.pre\",_1?true:undefined)]":function (_0,_1){return([(_0).set(".font.pre",_1?true:undefined)]);},"_0===\"measured\"||_0===\"image\"":function (_0){return(_0==="measured"||_0==="image");},"[(_0).set(\".font.clamp\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.clamp",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.clamp.x\")]":function (_0){return([_0.editExpr(".font.clamp.x")]);},"[(_0).set(\".font.clamp\",_1?true:undefined)]":function (_0,_1){return([(_0).set(".font.clamp",_1?true:undefined)]);},"[(_0).set(\".font.size\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.size",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.size.x\")]":function (_0){return([_0.editExpr(".font.size.x")]);},"[(_0).set(\".font.line\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.line",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.line.x\")]":function (_0){return([_0.editExpr(".font.line.x")]);},"_0===\"image\"":function (_0){return(_0==="image");},"[(_0).set(\".font.family\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.family",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.family.x\")]":function (_0){return([_0.editExpr(".font.family.x")]);},"[(_0).set(\".font.color\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.color",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.color.x\")]":function (_0){return([_0.editExpr(".font.color.x")]);},"[(_0).set(\".font.weight\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.weight",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.weight.x\")]":function (_0){return([_0.editExpr(".font.weight.x")]);},"[(_0).set(\".bg\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".bg",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".bg.x\")]":function (_0){return([_0.editExpr(".bg.x")]);},"[(_0).set(\".radius\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".radius",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".radius.x\")]":function (_0){return([_0.editExpr(".radius.x")]);},"[_0.editExpr(\".url\")]":function (_0){return([_0.editExpr(".url")]);},"[(_0).set(\".fit\",!_1||typeof _1===\"string\"?{x:\"\"}:undefined)]":function (_0,_1){return([(_0).set(".fit",!_1||typeof _1==="string"?{x:""}:undefined)]);},"_0&&typeof _0!==\"object\"?\"Expression\":\"Value\"":function (_0){return(_0&&typeof _0!=="object"?"Expression":"Value");},"[_0.editExpr(\".fit.x\"),false]":function (_0){return([_0.editExpr(".fit.x"),false]);},"!_0||typeof _0===\"string\"":function (_0){return(!_0||typeof _0==="string");},"[typeof _0===\"string\"?_2.editExpr(_1+\".source\"):_2.editReportSrc((_3),\".source\")]":function (_0,_1,_2,_3){return([typeof _0==="string"?_2.editExpr(_1+".source"):_2.editReportSrc((_3),".source")]);},"[(_0).set(\".source\",\"\")]":function (_0){return([(_0).set(".source","")]);},"[(_0).set(\".source\",{source:\"\"})]":function (_0){return([(_0).set(".source",{source:""})]);},"_0||_1":function (_0,_1){return(_0||_1);},"_0||_1||_2":function (_0,_1,_2){return(_0||_1||_2);},"[(_0).toggle(\".headerPerPage\")]":function (_0){return([(_0).toggle(".headerPerPage")]);},"_0!==false":function (_0){return(_0!==false);},"_0&&_1===\"page\"":function (_0,_1){return(_0&&_1==="page");},"_0.split(_1)":function (_0,_1){return(_0.split(_1));},"[_0.editExpr(\".text\")]":function (_0){return([_0.editExpr(".text")]);},"[(_0).set(\".font.metric\",typeof _1===\"object\"?undefined:{x:\"\"})]":function (_0,_1){return([(_0).set(".font.metric",typeof _1==="object"?undefined:{x:""})]);},"[_0.editExpr(\".font.metric.x\")]":function (_0){return([_0.editExpr(".font.metric.x")]);},"[_0.editExpr(\".macro\")]":function (_0){return([_0.editExpr(".macro")]);},"_0-1-_1":function (_0,_1){return(_0-1-_1);},"_0&&_2&&_2[_1]":function (_0,_1,_2){return(_0&&_2&&_2[_1]);},"[(_0).set(\".elide\",typeof _1===\"object\"?false:{x:\"\"})]":function (_0,_1){return([(_0).set(".elide",typeof _1==="object"?false:{x:""})]);},"[_0.editExpr(\".elide.x\"),false]":function (_0){return([_0.editExpr(".elide.x"),false]);},"_0&&_1===\"row\"":function (_0,_1){return(_0&&_1==="row");},"_0===\"page\"&&(_1===\"report.header\"||_1===\"report.footer\")&&_2":function (_0,_1,_2){return(_0==="page"&&(_1==="report.header"||_1==="report.footer")&&_2);},"Array.isArray(_0)?\"manual\":\"auto\"":function (_0){return(Array.isArray(_0)?"manual":"auto");},"[(_0).set(\".layout\",_1===\"manual\"?_2.fillArray(_3):undefined)]":function (_0,_1,_2,_3){return([(_0).set(".layout",_1==="manual"?_2.fillArray(_3):undefined)]);},"[_0.editExpr(\".context\")]":function (_0){return([_0.editExpr(".context")]);},"[_0.editExpr(\".html\",{html:true})]":function (_0){return([_0.editExpr(".html",{html:true})]);},"[_0.editExpr(\".text\",{label:true})]":function (_0){return([_0.editExpr(".text",{label:true})]);},"[(_0).set(\".text\",_2.getPartStrings(_1)),_2.editExpr(\".text\",{label:true})]":function (_0,_1,_2){return([(_0).set(".text",_2.getPartStrings(_1)),_2.editExpr(".text",{label:true})]);},"[(_0).set(\".id\",undefined)]":function (_0){return([(_0).set(".id",undefined)]);},"[(_0).set(\".id\",\"\")]":function (_0){return([(_0).set(".id","")]);},"_0.inRepeater(_1)":function (_0,_1){return(_0.inRepeater(_1));},"[(_0).set(\".format\",undefined)]":function (_0){return([(_0).set(".format",undefined)]);},"[(_0).set(\".format\",{})]":function (_0){return([(_0).set(".format",{})]);},"[(_0).push(\".format.args\",\"\")]":function (_0){return([(_0).push(".format.args","")]);},"[_0.editExpr(\".hide\")]":function (_0){return([_0.editExpr(".hide")]);},"[_0.editExpr(\".margin.x\"),false]":function (_0){return([_0.editExpr(".margin.x"),false]);},"[(_0).set(\".margin\",undefined)]":function (_0){return([(_0).set(".margin",undefined)]);},"[(_0).set(\".margin\",1)]":function (_0){return([(_0).set(".margin",1)]);},"[(_0).set(\".margin\",[1,1])]":function (_0){return([(_0).set(".margin",[1,1])]);},"[(_0).set(\".margin\",[1,1,1,1])]":function (_0){return([(_0).set(".margin",[1,1,1,1])]);},"_0!==4":function (_0){return(_0!==4);},"[(_0).set(\".margin\",{x:\"\"})]":function (_0){return([(_0).set(".margin",{x:""})]);},"!_0||_1===undefined":function (_0,_1){return(!_0||_1===undefined);},"_0!==undefined":function (_0){return(_0!==undefined);},"_0===\"params\"":function (_0){return(_0==="params");},"[_0.set(\"temp.bottom.tab\",\"params\"),_0.set(\"show.bottom\",true)]":function (_0){return([_0.set("temp.bottom.tab","params"),_0.set("show.bottom",true)]);},"!_0||_0===\"expr\"":function (_0){return(!_0||_0==="expr");},"[_0.set(\"temp.bottom.tab\",\"expr\"),_0.set(\"show.bottom\",true)]":function (_0){return([_0.set("temp.bottom.tab","expr"),_0.set("show.bottom",true)]);},"_0===\"langref\"":function (_0){return(_0==="langref");},"[_0.set(\"temp.bottom.tab\",\"langref\"),_0.set(\"show.bottom\",true)]":function (_0){return([_0.set("temp.bottom.tab","langref"),_0.set("show.bottom",true)]);},"_0===\"opref\"":function (_0){return(_0==="opref");},"[_0.set(\"temp.bottom.tab\",\"opref\"),_0.set(\"show.bottom\",true)]":function (_0){return([_0.set("temp.bottom.tab","opref"),_0.set("show.bottom",true)]);},"_0===\"param\"":function (_0){return(_0==="param");},"[_0.set(\"temp.bottom.tab\",\"param\"),_0.set(\"show.bottom\",true)]":function (_0){return([_0.set("temp.bottom.tab","param"),_0.set("show.bottom",true)]);},"_0===\"source\"":function (_0){return(_0==="source");},"[_0.set(\"temp.bottom.tab\",\"source\"),_0.set(\"show.bottom\",true)]":function (_0){return([_0.set("temp.bottom.tab","source"),_0.set("show.bottom",true)]);},"[_0.checkLink(\"expr\")]":function (_0){return([_0.checkLink("expr")]);},"_0.replace(/\\./g,\" 〉 \")":function (_0){return(_0.replace(/\./g," 〉 "));},"_0&&(!_1||_1===\"expr\")":function (_0,_1){return(_0&&(!_1||_1==="expr"));},"[_0.checkLink(\"param\")]":function (_0){return([_0.checkLink("param")]);},"+_0.lastKey(_1)+1":function (_0,_1){return(+_0.lastKey(_1)+1);},"_0&&_1===\"param\"":function (_0,_1){return(_0&&_1==="param");},"[_0.checkLink(\"source\")]":function (_0){return([_0.checkLink("source")]);},"_0&&_1===\"source\"":function (_0,_1){return(_0&&_1==="source");},"[_0.toggle(\"max.bottom\")]":function (_0){return([_0.toggle("max.bottom")]);},"[_0.toggle(\"show.bottom\")]":function (_0){return([_0.toggle("show.bottom")]);},"_0.langref(_1,_2)":function (_0,_1,_2){return(_0.langref(_1,_2));},"_0===\"#\"?\"Format \"+_1.slice(1):_1":function (_0,_1){return(_0==="#"?"Format "+_1.slice(1):_1);},"Array.isArray(_0)?_0.join(\" or \"):_0":function (_0){return(Array.isArray(_0)?_0.join(" or "):_0);},"(!_1||_0.includes(_1))&&(!_3||JSON.stringify(_2).toLowerCase().includes(_3.toLowerCase()))":function (_0,_1,_2,_3){return((!_1||_0.includes(_1))&&(!_3||JSON.stringify(_2).toLowerCase().includes(_3.toLowerCase())));},"[_0.eval()]":function (_0){return([_0.eval()]);},"_0===\"text\"":function (_0){return(_0==="text");},"[_0.set(\"temp.expr.tab\",\"text\")]":function (_0){return([_0.set("temp.expr.tab","text")]);},"[_0.fmt()]":function (_0){return([_0.fmt()]);},"_0===\"text\"&&!_1":function (_0,_1){return(_0==="text"&&!_1);},"!_0||_0===\"json\"":function (_0){return(!_0||_0==="json");},"[_0.set(\"temp.expr.parsedtype\",\"json\")]":function (_0){return([_0.set("temp.expr.parsedtype","json")]);},"_0&&_0!==\"json\"":function (_0){return(_0&&_0!=="json");},"[_0.copyToClipboard(JSON.stringify(_1))]":function (_0,_1){return([_0.copyToClipboard(JSON.stringify(_1))]);},"_0===\"raport\"":function (_0){return(_0==="raport");},"[_0.set(\"temp.expr.parsedtype\",\"raport\")]":function (_0){return([_0.set("temp.expr.parsedtype","raport")]);},"_0!==\"raport\"":function (_0){return(_0!=="raport");},"_0===\"json\"||!_0":function (_0){return(_0==="json"||!_0);},"_0===\"parsed\"":function (_0){return(_0==="parsed");},"_0?\"\":\"none\"":function (_0){return(_0?"":"none");},"_0===\"html\"":function (_0){return(_0==="html");},"[_0.set(\"temp.expr.tab\",\"html\")]":function (_0){return([_0.set("temp.expr.tab","html")]);},"[_0.set(\"temp.expr.tab\",\"result\")]":function (_0){return([_0.set("temp.expr.tab","result")]);},"[_0.set(\"temp.expr.tab\",\"parsed\")]":function (_0){return([_0.set("temp.expr.tab","parsed")]);},"!_0||_0===\"text\"":function (_0){return(!_0||_0==="text");},"[(_0).set(\".str\",_1.getPartStrings(_2))]":function (_0,_1,_2){return([(_0).set(".str",_1.getPartStrings(_2))]);},"[(_0).push(\".str\",\"\")]":function (_0){return([(_0).push(".str","")]);},"_0===0":function (_0){return(_0===0);},"[_0.moveUp((_1))]":function (_0,_1){return([_0.moveUp((_1))]);},"[_0.moveDown((_1))]":function (_0,_1){return([_0.moveDown((_1))]);},"[(_0).set(\".\",{text:_1})]":function (_0,_1){return([(_0).set(".",{text:_1})]);},"[(_0).set(\".\",_1)]":function (_0,_1){return([(_0).set(".",_1)]);},"_0==null?1:_0":function (_0){return(_0==null?1:_0);},"[_0===\"result\"?_1.set(\"temp.expr.tab\",\"text\"):_1.eval()]":function (_0,_1){return([_0==="result"?_1.set("temp.expr.tab","text"):_1.eval()]);},"[_0.command(\"bold\")]":function (_0){return([_0.command("bold")]);},"[_0.command(\"italic\")]":function (_0){return([_0.command("italic")]);},"[_0.command(\"underline\")]":function (_0){return([_0.command("underline")]);},"[_0.command(\"strikeThrough\")]":function (_0){return([_0.command("strikeThrough")]);},"[_0.setHTMLFontSize()]":function (_0){return([_0.setHTMLFontSize()]);},"!_0||_0===\"plain\"":function (_0){return(!_0||_0==="plain");},"[_0.set(\"temp.expr.resulttype\",\"plain\")]":function (_0){return([_0.set("temp.expr.resulttype","plain")]);},"_0&&_0!==\"plain\"":function (_0){return(_0&&_0!=="plain");},"[_0.copyToClipboard(_1)]":function (_0,_1){return([_0.copyToClipboard(_1)]);},"_0===\"json\"":function (_0){return(_0==="json");},"[_0.set(\"temp.expr.resulttype\",\"json\")]":function (_0){return([_0.set("temp.expr.resulttype","json")]);},"_0!==\"json\"":function (_0){return(_0!=="json");},"[_0.set(\"temp.expr.resulttype\",\"raport\")]":function (_0){return([_0.set("temp.expr.resulttype","raport")]);},"[_0.set(\"temp.expr.resulttype\",\"html\")]":function (_0){return([_0.set("temp.expr.resulttype","html")]);},"_0!==\"html\"":function (_0){return(_0!=="html");},"_0===undefined":function (_0){return(_0===undefined);},"JSON.stringify(_0,null,_1?undefined:\"  \")":function (_0,_1){return(JSON.stringify(_0,null,_1?undefined:"  "));},"_0.unparse(_1)":function (_0,_1){return(_0.unparse(_1));},"JSON.stringify(_0,null,_1?\"\":\"  \")":function (_0,_1){return(JSON.stringify(_0,null,_1?"":"  "));},"_0===\"ast\"||_0===\"text\"||_0===\"html\"?\"\":\"none\"":function (_0){return(_0==="ast"||_0==="text"||_0==="html"?"":"none");},"_0===\"string\"":function (_0){return(_0==="string");},"[(_0).set(\".init\",\"\")]":function (_0){return([(_0).set(".init","")]);},"[(_0).set(\".init\",undefined)]":function (_0){return([(_0).set(".init",undefined)]);},"[(_0).set(\".options\",Array.isArray(_1)?undefined:[])]":function (_0,_1){return([(_0).set(".options",Array.isArray(_1)?undefined:[])]);},"[(_2).push(\".options\",!_0?_1:{label:_0,value:_1}),(_2).set({\"ctx.label\":\"\",\"ctx.value\":\"\"})]":function (_0,_1,_2){return([(_2).push(".options",!_0?_1:{label:_0,value:_1}),(_2).set({"ctx.label":"","ctx.value":""})]);},"~_0.indexOf(\"widget\")":function (_0){return(~_0.indexOf("widget"));},"[_0.editExpr(_1+\".base\")]":function (_0,_1){return([_0.editExpr(_1+".base")]);},"[_0.editExpr(_1+\".filter\")]":function (_0,_1){return([_0.editExpr(_1+".filter")]);},"[_0.editExpr(_1+\".sort\")]":function (_0,_1){return([_0.editExpr(_1+".sort")]);},"[(_0).push(\".group\",\"\")]":function (_0){return([(_0).push(".group","")]);},"[(_0).set(\".group\",undefined)]":function (_0){return([(_0).set(".group",undefined)]);},"_0+1":function (_0){return(_0+1);},"[_0.editExpr(\"~/\"+_1)]":function (_0,_1){return([_0.editExpr("~/"+_1)]);},"[(_0).set(\".group\",[\"\"])]":function (_0){return([(_0).set(".group",[""])]);},"[_0.exprToggle(_1)]":function (_0,_1){return([_0.exprToggle(_1)]);},"_1[_0]?\"-\":\"+\"":function (_0,_1){return(_1[_0]?"-":"+");},"[_0.insertRef(_1)]":function (_0,_1){return([_0.insertRef(_1)]);},"!_2||_0||~_1.indexOf(_2)":function (_0,_1,_2){return(!_2||_0||~_1.indexOf(_2));},"[Array.isArray(_0)?(_2).splice(\"../\",_1,1):(_2).set(\".\",undefined)]":function (_0,_1,_2){return([Array.isArray(_0)?(_2).splice("../",_1,1):(_2).set(".",undefined)]);},"[(_0).set(\".source\",{r:\"\"})]":function (_0){return([(_0).set(".source",{r:""})]);},"[(_0).set(\".apply\",{r:\"\"})]":function (_0){return([(_0).set(".apply",{r:""})]);},"_1[_0]&&_1[_0].type===\"aggregate\"":function (_0,_1){return(_1[_0]&&_1[_0].type==="aggregate");},"[_0.retypeASTNode(_1,_2)]":function (_0,_1,_2){return([_0.retypeASTNode(_1,_2)]);},"_1&&\"op\" in _1?\"operator\":_1&&\"v\" in _1?(typeof _0===\"string\"?\"string\":typeof _0===\"number\"?\"number\":\"object\"):_1&&\"r\" in _1?\"reference\":\"undefined\"":function (_0,_1){return(_1&&"op" in _1?"operator":_1&&"v" in _1?(typeof _0==="string"?"string":typeof _0==="number"?"number":"object"):_1&&"r" in _1?"reference":"undefined");},"[_0!==_2&&[_1.link(_2,\"temp.expr.part\"),_1.set(\"temp.expr.partpath\",_2)],false]":function (_0,_1,_2){return([_0!==_2&&[_1.link(_2,"temp.expr.part"),_1.set("temp.expr.partpath",_2)],false]);},"(_0&&(\"op\" in _0?\"op\":\"v\" in _0?\"value\":\"r\" in _0?\"ref\":\"wat\"))||\"wat\"":function (_0){return((_0&&("op" in _0?"op":"v" in _0?"value":"r" in _0?"ref":"wat"))||"wat");},"[(_0).push(\".args\",{v:\"\"})]":function (_0){return([(_0).push(".args",{v:""})]);},"_0&&\"op\" in _0":function (_0){return(_0&&"op" in _0);},"_0&&\"v\" in _0":function (_0){return(_0&&"v" in _0);},"_0&&\"r\" in _0":function (_0){return(_0&&"r" in _0);},"\"+ \"":function (){return("+ ");},"\"=> \"":function (){return("=> ");},"[_0.set(\"report.defaultParams\",_1)]":function (_0,_1){return([_0.set("report.defaultParams",_1)]);},"[_0.initParams()]":function (_0){return([_0.initParams()]);},"_0===\"boolean\"":function (_0){return(_0==="boolean");},"_0===\"code\"":function (_0){return(_0==="code");},"_0===\"object\"||_0===\"array\"||_0.slice(-2)===\"[]\"":function (_0){return(_0==="object"||_0==="array"||_0.slice(-2)==="[]");},"_0===\"number\"":function (_0){return(_0==="number");},"_0?\"left\":\"right\"":function (_0){return(_0?"left":"right");},"[_0.toggle(\"show.props\")]":function (_0){return([_0.toggle("show.props")]);},"_0?\"off\":\"\"":function (_0){return(_0?"off":"");},"[_2.toggle(\"show.hidetree\"),!_0&&_1?_2.set(\"show.hideprops\",false):\"\"]":function (_0,_1,_2){return([_2.toggle("show.hidetree"),!_0&&_1?_2.set("show.hideprops",false):""]);},"[_0.toggle(\"show.props\"),_0.set(\"show.hidetree\",false),_0.set(\"show.hideprops\",true)]":function (_0){return([_0.toggle("show.props"),_0.set("show.hidetree",false),_0.set("show.hideprops",true)]);},"[_2.toggle(\"show.hideprops\"),!_0&&_1?_2.set(\"show.hidetree\",false):\"\"]":function (_0,_1,_2){return([_2.toggle("show.hideprops"),!_0&&_1?_2.set("show.hidetree",false):""]);},"[_0.toggle(\"show.props\"),_0.set(\"show.hidetree\",true),_0.set(\"show.hideprops\",false)]":function (_0){return([_0.toggle("show.props"),_0.set("show.hidetree",true),_0.set("show.hideprops",false)]);},"[_0.addWidget(_1)]":function (_0,_1){return([_0.addWidget(_1)]);},"_0!==\"delimited\"&&(_1===\"container\"||_2===\"report\")":function (_0,_1,_2){return(_0!=="delimited"&&(_1==="container"||_2==="report"));},"[_0.set(\"copy\",undefined)]":function (_0){return([_0.set("copy",undefined)]);},"true":function (){return(true);},"[_0.set(\"reparent\",undefined)]":function (_0){return([_0.set("reparent",undefined)]);},"[_0.treeScrollToActive()]":function (_0){return([_0.treeScrollToActive()]);},"_0===\"report\"":function (_0){return(_0==="report");},"[_0?_3.reparent((_2)):_1?_3.paste((_2)):_3.selectWidget(\"report\")]":function (_0,_1,_2,_3){return([_0?_3.reparent((_2)):_1?_3.paste((_2)):_3.selectWidget("report")]);},"[_0.set(\"temp.hover\",\"report\"),false]":function (_0){return([_0.set("temp.hover","report"),false]);},"[(_0).set(\".header\",{type:\"container\"}),false]":function (_0){return([(_0).set(".header",{type:"container"}),false]);},"[(_0).set(\".footer\",{type:\"container\"}),false]":function (_0){return([(_0).set(".footer",{type:"container"}),false]);},"[(_0).set(\".watermark\",{type:\"container\"}),false]":function (_0){return([(_0).set(".watermark",{type:"container"}),false]);},"[(_0).set(\".overlay\",{type:\"container\"}),false]":function (_0){return([(_0).set(".overlay",{type:"container"}),false]);},"_0!=\"delimited\"":function (_0){return(_0!="delimited");},"[_0.addHeader(),false]":function (_0){return([_0.addHeader(),false]);},"[_1.push(\"report.fields\",\"\"),_0&&_1.push(\"report.headers\",\"\"),false]":function (_0,_1){return([_1.push("report.fields",""),_0&&_1.push("report.headers",""),false]);},"_0.toUpperCase()":function (_0){return(_0.toUpperCase());},"_0.substr(1)":function (_0){return(_0.substr(1));},"[_0.editExpr(\"report.name\",{template:true}),false]":function (_0){return([_0.editExpr("report.name",{template:true}),false]);},"_0!==\"delimited\"":function (_0){return(_0!=="delimited");},"[_0.editExpr(\"report.rowContext\")]":function (_0){return([_0.editExpr("report.rowContext")]);},"[_0.push(\"report.parameters\",{})]":function (_0){return([_0.push("report.parameters",{})]);},"[_0.editParam((_1))]":function (_0,_1){return([_0.editParam((_1))]);},"[_0.checkLink(\"param\",_1),(_2).splice(\"../\",_3,1)]":function (_0,_1,_2,_3){return([_0.checkLink("param",_1),(_2).splice("../",_3,1)]);},"[_0.provideSource()]":function (_0){return([_0.provideSource()]);},"_0===false":function (_0){return(_0===false);},"[_0.editProvidedSource((_1))]":function (_0,_1){return([_0.editProvidedSource((_1))]);},"[_0.logData(_1)]":function (_0,_1){return([_0.logData(_1)]);},"\"console\"":function (){return("console");},"[_0.checkLink(\"import\",_1),(_2).splice(\"../\",_3,1)]":function (_0,_1,_2,_3){return([_0.checkLink("import",_1),(_2).splice("../",_3,1)]);},"[_0.push(\"report.sources\",{name:\"\",parameters:{}})]":function (_0){return([_0.push("report.sources",{name:"",parameters:{}})]);},"[_0.editReportSrc((_1))]":function (_0,_1){return([_0.editReportSrc((_1))]);},"[_0.checkLink(\"source\",_1),(_2).splice(\"../\",_3,1)]":function (_0,_1,_2,_3){return([_0.checkLink("source",_1),(_2).splice("../",_3,1)]);},"_0+\"-props\"":function (_0){return(_0+"-props");},"_0&&!_1":function (_0,_1){return(_0&&!_1);},"[_0.set(\"temp.expr.hover\",_1),false]":function (_0,_1){return([_0.set("temp.expr.hover",_1),false]);},"[_0.set(\"temp.expr.hover\",\"\"),false]":function (_0){return([_0.set("temp.expr.hover",""),false]);},"[_0.moveUp((_1),[\"../\",_2?\"~/report.headers\":undefined],_3,_4),false]":function (_0,_1,_2,_3,_4){return([_0.moveUp((_1),["../",_2?"~/report.headers":undefined],_3,_4),false]);},"[_0.moveDown((_1),[\"../\",_2?\"~/report.headers\":undefined],_3,_4),false]":function (_0,_1,_2,_3,_4){return([_0.moveDown((_1),["../",_2?"~/report.headers":undefined],_3,_4),false]);},"[_0.removeWidget((_1))]":function (_0,_1){return([_0.removeWidget((_1))]);},"[_0.clickWidget((_1))]":function (_0,_1){return([_0.clickWidget((_1))]);},"[_0.set(\"temp.hover\",_1),false]":function (_0,_1){return([_0.set("temp.hover",_1),false]);},"_0.getNestLevel(_1)":function (_0,_1){return(_0.getNestLevel(_1));},"[_0.set(\"temp.tree.\"+_1(_2),_3&&_3[_2]===false?true:false),false]":function (_0,_1,_2,_3){return([_0.set("temp.tree."+_1(_2),_3&&_3[_2]===false?true:false),false]);},"_1[_0]!==false":function (_0,_1){return(_1[_0]!==false);},"[_0.moveUp((_1),[\"../\",\"^^/groupEnds\"]),false]":function (_0,_1){return([_0.moveUp((_1),["../","^^/groupEnds"]),false]);},"[_0.moveDown((_1),[\"../\",\"^^/groupEnds\"]),false]":function (_0,_1){return([_0.moveDown((_1),["../","^^/groupEnds"]),false]);},"_0===\"repeater\"&&_1":function (_0,_1){return(_0==="repeater"&&_1);},"\"overlay\"":function (){return("overlay");},"\"header\"":function (){return("header");},"_0!==\"header\"&&_0!==\"footer\"&&_0!==\"alternate\"&&_0!==\"overlay\"&&_0!==\"watermark\"&&_1===\"container\"":function (_0,_1){return(_0!=="header"&&_0!=="footer"&&_0!=="alternate"&&_0!=="overlay"&&_0!=="watermark"&&_1==="container");},"\"alternate\"":function (){return("alternate");},"_0&&_1===_0.resolve()||_2&&_1===_2.resolve()":function (_0,_1,_2){return(_0&&_1===_0.resolve()||_2&&_1===_2.resolve());},"!!_0&&(!!_1||_2===\"container\")":function (_0,_1,_2){return(!!_0&&(!!_1||_2==="container"));},"_0||_1===\"repeater\"":function (_0,_1){return(_0||_1==="repeater");},"[_0?[(_1).push(\".group\",{type:\"container\"}),(_1).splice(\".groupEnds\",-1,0,true)]:(_1).set({\".group\":[{type:\"container\"}],\".groupEnds\":[true,true]}),false]":function (_0,_1){return([_0?[(_1).push(".group",{type:"container"}),(_1).splice(".groupEnds",-1,0,true)]:(_1).set({".group":[{type:"container"}],".groupEnds":[true,true]}),false]);},"[(_0).set(\".alternate\",{type:\"container\"}),false]":function (_0){return([(_0).set(".alternate",{type:"container"}),false]);},"_0===\"repeater\"":function (_0){return(_0==="repeater");},"_0||\"widget\"":function (_0){return(_0||"widget");},"[_0.set(\"copy\",(_1)),false]":function (_0,_1){return([_0.set("copy",(_1)),false]);},"[_0.set(\"reparent\",(_1)),false]":function (_0,_1){return([_0.set("reparent",(_1)),false]);},"[_0.moveUp((_1),[\"../\",!_2&&Array.isArray(_3)?\"^^/layout\":undefined],_4,_5),false]":function (_0,_1,_2,_3,_4,_5){return([_0.moveUp((_1),["../",!_2&&Array.isArray(_3)?"^^/layout":undefined],_4,_5),false]);},"[_0.moveDown((_1),[\"../\",!_2&&Array.isArray(_3)?\"^^/layout\":undefined],_4,_5),false]":function (_0,_1,_2,_3,_4,_5){return([_0.moveDown((_1),["../",!_2&&Array.isArray(_3)?"^^/layout":undefined],_4,_5),false]);},"!_0&&!_1":function (_0,_1){return(!_0&&!_1);},"\"footer\"":function (){return("footer");},"\"watermark\"":function (){return("watermark");},"_0||\"unknown\"":function (_0){return(_0||"unknown");},"_0!==\"row\"||_1!==\"repeater\"":function (_0,_1){return(_0!=="row"||_1!=="repeater");},"_0===\"label\"||_0===\"measured\"":function (_0){return(_0==="label"||_0==="measured");},"_1&&typeof _1===\"object\"&&\"x\" in _1?_0:typeof _1===\"string\"?_1:(_2||_3||\"(None)\")":function (_0,_1,_2,_3){return(_1&&typeof _1==="object"&&"x" in _1?_0:typeof _1==="string"?_1:(_2||_3||"(None)"));},"[(_0).set(\".group\",undefined),(_0).set(\".groupEnds\",[true]),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]":function (_0,_1){return([(_0).set(".group",undefined),(_0).set(".groupEnds",[true]),_1.unlink("widget"),_1.set("temp.widget",undefined)]);},"[(_0).push(\".group\",{type:\"container\"}),(_0).splice(\".groupEnds\",-1,0,true)]":function (_0){return([(_0).push(".group",{type:"container"}),(_0).splice(".groupEnds",-1,0,true)]);},"[(_0).set(\".group\",[{type:\"container\"}]),(_0).set(\".groupEnds\",[true,true])]":function (_0){return([(_0).set(".group",[{type:"container"}]),(_0).set(".groupEnds",[true,true])]);},"[(_0).set(\".header\",undefined),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]":function (_0,_1){return([(_0).set(".header",undefined),_1.unlink("widget"),_1.set("temp.widget",undefined)]);},"[(_0).set(\".header\",{type:\"container\"})]":function (_0){return([(_0).set(".header",{type:"container"})]);},"[(_0).set(\".alternate\",undefined),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]":function (_0,_1){return([(_0).set(".alternate",undefined),_1.unlink("widget"),_1.set("temp.widget",undefined)]);},"[(_0).set(\".alternate\",{type:\"container\"})]":function (_0){return([(_0).set(".alternate",{type:"container"})]);},"[(_0).set(\".footer\",undefined),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]":function (_0,_1){return([(_0).set(".footer",undefined),_1.unlink("widget"),_1.set("temp.widget",undefined)]);},"[(_0).set(\".footer\",{type:\"container\"})]":function (_0){return([(_0).set(".footer",{type:"container"})]);},"\"Group Header \"+(_0+1)":function (_0){return("Group Header "+(_0+1));},"\"Header\"":function (){return("Header");},"(_0).set(\".row\",{type:\"container\"})&&\"\"":function (_0){return((_0).set(".row",{type:"container"})&&"");},"\"Row\"":function (){return("Row");},"\"Alternate\"":function (){return("Alternate");},"\"Footer\"":function (){return("Footer");},"[(_0).toggle(\"ctx.preview\")]":function (_0){return([(_0).toggle("ctx.preview")]);},"[_0.autosizeHtml((_1))]":function (_0,_1){return([_0.autosizeHtml((_1))]);},"[_0.editExpr((_1).resolve(\".html\"),{html:true})]":function (_0,_1){return([_0.editExpr((_1).resolve(".html"),{html:true})]);},"_0||0.83":function (_0){return(_0||0.83);},"_0===0?\"initial\":(_0||_1||1)+\"rem\"":function (_0,_1){return(_0===0?"initial":(_0||_1||1)+"rem");},"_0<50":function (_0){return(_0<50);},"_0.evalExpr(_1)":function (_0,_1){return(_0.evalExpr(_1));},"!_0?\"contain\":_0===\"stretch\"?\"100% 100%\":\"cover\"":function (_0){return(!_0?"contain":_0==="stretch"?"100% 100%":"cover");},"_0.calcFont(_1)":function (_0,_1){return(_0.calcFont(_1));},"_0||\"container\"":function (_0){return(_0||"container");},"(_0).set(\"ctx.layout\",_1===\"row\"||!_1?\"auto\":\"manual\")&&\"\"":function (_0,_1){return((_0).set("ctx.layout",_1==="row"||!_1?"auto":"manual")&&"");},"[_0===\"auto\"?(_1).set(\".layout\",undefined):(_1).set(\".layout\",[])]":function (_0,_1){return([_0==="auto"?(_1).set(".layout",undefined):(_1).set(".layout",[])]);},"[_0.set(\"temp.hover\",_1)]":function (_0,_1){return([_0.set("temp.hover",_1)]);},"false":function (){return(false);},"_0===true":function (_0){return(_0===true);},"[_0]":function (_0){return([_0]);},"_0!==\"page footer\"":function (_0){return(_0!=="page footer");},"_0||0":function (_0){return(_0||0);},"_0===\"container\"?\"min-\":\"\"":function (_0){return(_0==="container"?"min-":"");},"(_0&&_0!==\"auth\")||_1!==\"container\"":function (_0,_1){return((_0&&_0!=="auth")||_1!=="container");},"_0.calcManualLayout(_2[_1],_3,_4)":function (_0,_1,_2,_3,_4){return(_0.calcManualLayout(_2[_1],_3,_4));},"_0.calcMargin(_1)":function (_0,_1){return(_0.calcMargin(_1));},"_0.calcBorder(_1)":function (_0,_1){return(_0.calcBorder(_1));},"[_0.removeWidget((_1),false)]":function (_0,_1){return([_0.removeWidget((_1),false)]);},"_0.calcWidthWithMargin(_1,(_2))":function (_0,_1,_2){return(_0.calcWidthWithMargin(_1,(_2)));},"_0.calcHeightWithMargin(_1)":function (_0,_1){return(_0.calcHeightWithMargin(_1));}},p:{types:[{t:7,e:"option",f:["any"]}," ",{t:7,e:"option",f:["string"]}," ",{t:7,e:"option",f:["number"]}," ",{t:7,e:"option",f:["boolean"]}," ",{t:7,e:"option",f:["date"]}," ",{t:7,e:"option",f:["array"]}," ",{t:7,e:"option",f:["object"]}," ",{t:7,e:"option",f:["string[]"]}," ",{t:7,e:"option",f:["number[]"]}," ",{t:7,e:"option",f:["boolean[]"]}," ",{t:7,e:"option",f:["date[]"]}," ",{t:7,e:"option",f:["object[]"]}],"data-import":[{t:7,e:"div",m:[{t:13,n:"class",f:"delimited import paper",g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"file",t:13},{n:"style",f:"display: none;",t:13},{n:"id",f:"import-file",t:13},{n:"accept",f:"*/*",t:13}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"definition",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text spacer",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.loadImportFile()]"}},{n:"title",f:"Import data from a file",t:13,g:1}],f:["Load"]}," ",{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"style",f:"vertical-align: middle;",t:13},{n:"checked",f:[{t:2,x:{r:["data.type"],s:"_0===\"fetch\""}}],t:13},{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@this","@node.checked"],s:"[_0.set(\"data.type\",_1?\"fetch\":undefined)]"}}]}," Fetch request?"]}," ",{t:7,e:"label",m:[{t:13,n:"style",f:"margin-left: 1em;",g:1},{n:"title",f:"If the data is delimited text, use the first record to convert the remaining records to objects with keys named the matching field offset header.",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"style",f:"vertical-align: middle;",t:13},{n:"checked",f:[{t:2,r:"data.header"}],t:13},{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@node.checked","@this"],s:"[_1.set(\"data.header\",_0?1:undefined),_1.tryImport(_1.getImportText())]"}}]}," Delimited header?"]}]}," ",{t:4,f:[{t:7,e:"div",f:[{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"radio",t:13},{n:"style",f:"vertical-align: middle;",t:13},{n:"name",f:[{t:2,r:"data.eval"}],t:13},{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}]}," JSON"]}," ",{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"radio",t:13},{n:"style",f:"vertical-align: middle;",t:13},{n:"name",f:[{t:2,r:"data.eval"}],t:13},{n:"value",f:"txt",t:13}]}," Plain text"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"fetch scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:4,f:[{t:7,e:"label",m:[{t:13,n:"style",f:"width: 26rem;",g:1},{t:13,n:"class",f:"input",g:1}],f:["URL ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.editExpr(_1+\".url\",{template:true}),false]"}}],f:[{t:8,r:"pencil"}]},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".url"}],t:13}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1}],f:["Method",{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".method"}],t:13}],f:[" ",{t:7,e:"option",f:["GET"]}," ",{t:7,e:"option",f:["POST"]}," ",{t:7,e:"option",f:["PUT"]}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"check",g:1},{n:"title",f:"Check if this source should be fetched before each run or leave unchecked if cached data can be used",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".fetch"}],t:13}]}," Fetch on each run?"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).push(\".headers\",[])]"}}],f:["Add Header"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.fetchData()]"}}],f:["Fetch Now"]}," ",{t:4,f:[{t:7,e:"h3",f:["Headers"]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"fetch-header",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove header",t:13,g:1},{n:["click"],t:70,f:{r:["@context","@index"],s:"[(_0).splice(\"../\",_1,1)]"}}],f:[{t:8,r:"times"}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1}],f:["Header",{t:7,e:"input",m:[{n:"value",f:[{t:2,rx:{r:".",m:[{r:[],s:"0"}]}}],t:13}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1}],f:["Value ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.editExpr(_1+\".1\",{template:true}),false]"}}],f:[{t:8,r:"pencil"}]},{t:7,e:"input",m:[{n:"value",f:[{t:2,rx:{r:".",m:[{r:[],s:"1"}]}}],t:13}]}]}]}],n:52,r:".headers"}],n:50,r:".headers"}," ",{t:4,f:[{t:7,e:"label",m:[{t:13,n:"class",f:"area",g:1}],f:["Body ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.editExpr(_1+\".body\",{template:true}),false]"}}],f:[{t:8,r:"pencil"}]},{t:7,e:"textarea",f:[{t:2,r:".body"}]}]}],n:50,x:{r:[".method"],s:"_0!==\"GET\""}}],n:54,r:"data"}]}]}],n:50,x:{r:["data.type"],s:"_0===\"fetch\""}}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"position: relative;",g:1},{t:13,n:"class",f:"json",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"textarea",m:[{n:"invalidated",t:71},{n:["change","input","invalidate","focus","blur"],t:70,f:{r:["@this","@node"],s:"[_0.autosize(_1)]"}},{n:"tracked",t:71,f:{r:[],s:"[\"_importText\"]"}},{n:["change","input"],t:70,f:{r:["@this","@event"],s:"[_0.set(\"_importdirty\",true),console.log(\"change\",_1)]"}}]}]}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"style",f:"position: absolute; top: 0.5em; right: 0.5em;",g:1},{t:13,n:"class",f:"plain",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.tryImport(_0.getImportText()),_0.set(\"_importdirty\",false)]"}}],f:["Apply Changes"]}],n:50,r:"~/_importdirty"}]}]}]}],project:[{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"delimited paper project",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"settings-pane",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"settings-pane-inner",g:1}],f:[{t:7,e:"h3",f:["Settings"]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1}],f:["Theme",{t:7,e:"br"},{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"~/settings.theme"}],t:13}],f:[" ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["Auto"]}," ",{t:7,e:"option",m:[{n:"value",f:"dark",t:13}],f:["Dark"]}," ",{t:7,e:"option",m:[{n:"value",f:"light",t:13}],f:["Light"]}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"Select a theme for the rendered report output",t:13,g:1}],f:["Output Theme",{t:7,e:"br"},{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"~/settings.outTheme"}],t:13}],f:[" ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["Follow Designer"]}," ",{t:7,e:"option",m:[{n:"value",f:"dark",t:13}],f:["Dark"]}," ",{t:7,e:"option",m:[{n:"value",f:"light",t:13}],f:["Light"]}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"Scale the UI to a percentage of the default indenpendently of browser zoom (default: 100)",t:13,g:1}],f:["UI Scaling",{t:7,e:"br"},{t:7,e:"div",m:[{t:13,n:"style",f:"float: right; line-height: 2.5em;",g:1}],f:["%"]},{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"step",f:"1",t:13},{n:"value",f:[{t:2,r:"~/settings.scale"}],t:13},{n:"style",f:"width: calc(100% - 1.5em)",t:13},{t:73,v:"l",f:"1000"}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The width in rem of the left pane (default 28)",t:13,g:1}],f:["Left Pane Width",{t:7,e:"br"},{t:7,e:"div",m:[{t:13,n:"style",f:"float: right; line-height: 2.5em;",g:1}]},{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"step",f:"1",t:13},{n:"value",f:[{t:2,r:"~/settings.leftwidth"}],t:13},{t:73,v:"l",f:"1000"}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The height in percent of the viewport of the bottom pane (default 33)",t:13,g:1}],f:["Bottom Pane Height",{t:7,e:"br"},{t:7,e:"div",m:[{t:13,n:"style",f:"float: right; line-height: 2.5em;",g:1}]},{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"step",f:"1",t:13},{n:"value",f:[{t:2,r:"~/settings.bottomheight"}],t:13},{t:73,v:"l",f:"1000"}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"check",g:1},{n:"title",f:"Automatically save an open project when leaving the page?",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"~/settings.autosave"}],t:13}]}," Auto save on leave?"]}," ",{t:7,e:"br"},{t:7,e:"br"}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The base wrap length for the code formatter (default 40)",t:13,g:1}],f:["Format Wrap",{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/settings.format.wrap"}],t:13}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The wrap length for the code formatter array literals",t:13,g:1}],f:["Array Wrap",{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/settings.format.wrap_array"}],t:13}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The wrap length for the code formatter for object literals",t:13,g:1}],f:["Object Wrap",{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/settings.format.wrap_keys"}],t:13}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The wrap length for the code formatter for operator arguments",t:13,g:1}],f:["Argument Wrap",{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/settings.format.wrap_args"}],t:13}]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"input",g:1},{n:"title",f:"The wrap length for the code formatter for schema unions",t:13,g:1}],f:["Union Wrap",{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/settings.format.wrap_union"}],t:13}]}]}]}]}," ",{t:7,e:"input",m:[{n:"type",f:"file",t:13},{n:"style",f:"display: none;",t:13},{n:"id",f:"project-file",t:13},{n:"accept",f:"application/json",t:13}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"project-pane",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"project-pane-left",g:1}],f:[{t:4,f:[{t:7,e:"div",f:[{t:7,e:"label",m:[{t:13,n:"style",f:"width: 20rem;",g:1},{t:13,n:"class",f:"input",g:1}],f:["Project Name",{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"~/project.name"}],t:13}]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Save all projects to browser storage",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.saveProjects()]"}}],f:["Save Projects"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Export this project to a raport/JSON file",t:13,g:1},{n:["click"],t:70,f:{r:["~/project.name","@this"],s:"[_1.download(_0+\".raport-proj\",_1.stringifyProject())]"}}],f:["Export Project"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Create a copy of this project",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.cloneProject()]"}}],f:["Clone Project"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Import this project definition from a raport/JSON file",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.importProject(true)]"}}],f:["Import Project"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Create a new empty project",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.makeProject(true)]"}}],f:["New Project"]}," ",{t:7,e:"br"},{t:7,e:"br"}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Delete this project from browser storage",t:13,g:1},{n:"style-background",f:[{t:2,r:"@style.error"}],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.removeProject()]"}}],f:["Delete Project"]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"style-background",f:[{t:2,r:"@style.error"}],t:13},{n:"title",f:"Discard changes to this project",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.resetProject()]"}}],f:["Discard Project Changes"]}],n:50,r:"~/projectChanged"},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"style-background",f:[{t:2,r:"@style.error"}],t:13},{n:"title",f:"Close this project",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.unlinkProject()]"}}],f:["Close Project"]}],n:51,l:1}," ",{t:7,e:"br"},{t:7,e:"br"}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Export this project as text to the below text field",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"projectText\",_0.stringifyProject())]"}}],f:["Refresh Text"]}]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"grow area",g:1}],f:["Project Definition",{t:7,e:"textarea",m:[{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@this","@node.value"],s:"[_0.importProject(true,_1)]"}}],f:[{t:2,r:"projectText"}]}]}],n:50,x:{r:["~/project"],s:"_0!=null"}},{t:4,f:[{t:7,e:"div",f:[{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Convert the current definition to a project",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.makeProject()]"}}],f:["Make Project"]}]}],n:51,l:1}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"project-pane-right",g:1},{n:"title",f:"Click a project to load it",t:13,g:1}],f:["Projects ",{t:7,e:"div",m:[{t:13,n:"class",f:"project-list",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"project-item",g:1},{t:4,f:[{n:"class",f:"active-project",t:13},{n:"title",f:["Project ",{t:2,r:".name"}," is already loaded"],t:13}],n:50,x:{r:[".","~/project"],s:"_0===_1"}},{t:4,f:[{n:"title",f:["Load ",{t:2,r:".name"},", discarding any unsaved changes in the current project or definitions"],t:13},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.linkProject(_1)]"}}],n:51,l:1}],f:[{t:2,r:".name"}]}],n:52,r:"~/projects"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.download(\"Raport Projects.json\",_0.stringifyProjects())]"}},{n:"title",f:"Export all projects to a JSON file",t:13,g:1}],f:["Export All Projects"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"style-background",f:[{t:2,r:"@style.error"}],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.importProject()]"}},{n:"title",f:"Import multiple projects from a JSON file. Existing projects with the same name as an import will be overwritten.",t:13,g:1}],f:["Import Projects"]}]}]}],n:50,r:"~/showProjects"}]}]}]}],definition:[{t:7,e:"div",m:[{t:13,n:"class",f:"delimited paper",g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"file",t:13},{n:"style",f:"display: none;",t:13},{n:"id",f:"definition-file",t:13},{n:"accept",f:".raport,.json",t:13}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"definition",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"flex-wrap: wrap;",g:1},{t:13,n:"class",f:"actions",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.loadReportFile()]"}},{n:"title",f:"Load report definition from a file",t:13,g:1}],f:["Load"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico text spacer",g:1},{n:["click"],t:70,f:{r:["~/report.name","@this","~/tmp.js","~/tmp.strings"],s:"[_1.download((_0||\"report\")+\".raport\",_1.reportToString(true,_2,_3))]"}},{n:"title",f:"Save report definition to a file",t:13,g:1}],f:["Save"]}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"spacer",g:1},{n:"title",f:"Render the report definition in a compact format",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"~/tmp.compact"}],t:13},{n:"style",f:"vertical-align: middle;",t:13}]}," Compact?"]}," ",{t:4,f:[{t:7,e:"label",m:[{t:13,n:"class",f:"spacer",g:1},{n:"title",f:"Render the report definition as JS rather than JSON",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"~/tmp.js"}],t:13},{n:"style",f:"vertical-align: middle;",t:13}]}," JS?"]}],n:50,r:"~/tmp.compact"}," ",{t:4,f:[{t:7,e:"label",m:[{t:13,n:"class",f:"spacer",g:1},{n:"title",f:"Render report definition strings as JSON strings or template literals",t:13,g:1}],f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"~/tmp.strings"}],t:13}],f:[{t:7,e:"option",f:["json"]},{t:7,e:"option",f:["template"]}]}]}],n:50,r:"~/tmp.js"}," ",{t:7,e:"label",m:[{t:13,n:"class",f:"spacer",g:1},{n:"title",f:"Switch the formatter into compact mode",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"~/tmp.nowrap"}],t:13}]}," Compact format?"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.fmtAll()]"}},{n:"title",f:"Reformat all expressions",t:13,g:1}],f:["Format All"]}," ",{t:7,e:"button",m:[{t:13,n:"style",f:"margin-left: 2em;",g:1},{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@this","~/tmp.compact","~/tmp.js","~/tmp.strings"],s:"[_0.copyToClipboard(_0.reportToString(_1,_2,_3))]"}},{n:"title",f:"Copy definition to clipboard",t:13,g:1}],f:["Copy Text"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"json",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"textarea",m:[{n:"invalidated",t:71},{n:["change","input","invalidate"],t:70,f:{r:["@this","@node"],s:"[_0.autosize(_1)]"}},{t:73,v:"t",f:"false"},{n:"value",f:[{t:2,x:{r:["@this","~/tmp.compact","~/tmp.js","~/tmp.strings"],s:"_0.reportToString(_1,_2,_3)"}}],t:13},{n:["change"],t:70,f:{r:["@node.value","@this"],s:"[_1.loadReportString(_0),_1.update(\"temp\")]"}}]}]}]}]}]}]}],context:[{t:7,e:"div",m:[{t:13,n:"class",f:"delimited paper",g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"file",t:13},{n:"style",f:"display: none;",t:13},{n:"id",f:"context-file",t:13},{n:"accept",f:"application/json",t:13}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"definition",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:7,e:"span",m:[{n:"title",f:"The root context to load for the report, which is available before sources are loaded. This must be JSON.",t:13,g:1}],f:["Base Context"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico text spacer",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.loadContextFile()]"}},{n:"title",f:"Import context from a file",t:13,g:1}],f:["Load"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"json",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"textarea",m:[{n:"invalidated",t:71},{n:["input","invalidate"],t:70,f:{r:["@this","@node"],s:"[_0.autosize(_1)]"}},{n:["change"],t:70,f:{r:["@this","@node.value"],s:"[_0.tryContext(_1)]"}},{n:"tracked",t:71,f:{r:[],s:"[\"_contextText\"]"}}]}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"margin-top: 2rem;",g:1},{n:"title",f:"An expreession that is evaluated in the root context before the report is run. This is a good place to run set operators to set up helper applications. Sources are loaded before this is evaluated.",t:13,g:1}],f:["Extra Context"]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"extra-context",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:"~/report.extraContext"}],t:13}]}]}]}]}]}]}],design:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 3rem; min-width: min-content;",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"delimited paper",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"widget active-widget",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"bar",g:1}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"name",g:1}],f:["Report"]}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.addHeader()]"}}],f:["Add Header"]}],n:50,x:{r:["report.headers"],s:"!_0"}},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.headers\",undefined)]"}}],f:["Remove Header"]}],n:51,l:1}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"children",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"widget hover-widget",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"bar",g:1}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"name",g:1}],f:["Header"]}," ",{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.push(\"report.headers\",\"\"),_0.push(\"report.fields\",\"\")]"}}],f:["Add Field"]}," ",{t:4,f:[{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.fillBlankDelimitedHeaders()]"}},{n:"title",f:"Fill any blank headers with the corresponding field expression",t:13,g:1}],f:["Fill Blanks"]}],n:50,r:"~/blankDelimitedHeaders"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"children fields",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"field",g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.editExpr((_1),{template:true})]"}},{n:"class-active-expr",t:13,f:[{t:2,x:{r:["~/temp.expr.path","@keypath"],s:"_0===_1"}}]},{n:"expr",t:71,f:{r:[],s:"[true]"}}],f:[{t:7,e:"span",f:[{t:2,r:"."}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove this field",t:13,g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1)),false]"}}],f:[{t:8,r:"times"}]}]}],n:52,r:"report.headers"}]}]}],n:50,x:{r:["~/report.headers"],s:"!!_0"}}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"widget hover-widget",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"bar",g:1}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"name",g:1}],f:["Row"]}," ",{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["~/report.headers","@this"],s:"[_1.push(\"report.fields\",\"\"),_0&&_1.push(\"report.headers\",\"\")]"}}],f:["Add Field"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"children fields",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"field",g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.editExpr((_1))]"}},{n:"class-active-expr",t:13,f:[{t:2,x:{r:["~/temp.expr.path","@keypath"],s:"_0===_1"}}]},{n:"expr",t:71}],f:[{t:7,e:"span",f:[{t:2,r:"."}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove this field",t:13,g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1)),false]"}}],f:[{t:8,r:"times"}]}]}],n:52,r:"report.fields"}]}]}]}]}]}]}]}]}],n:50,x:{r:["report.type"],s:"_0===\"delimited\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 3rem; min-width: min-content;",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"paper",g:1},{n:"style",f:[{t:2,x:{r:["@this"],s:"_0.paperSize()"}}],t:13},{n:["click"],t:70,f:{r:["@event.target","@node","@this","~/inOverlay","~/inWatermark"],s:"[_0===_1?_2.selectWidget(_3?\"report.overlay\":_4?\"report.watermark\":\"report\"):true]"}},{n:["mouseleave"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.hover\",\"\"),false]"}},{n:["mousemove"],t:70,f:{r:["~/shiftKey","@this","@event.shiftKey"],s:"[_2!==_0?_1.set(\"shiftKey\",_2):\"\"]"}},{n:"class-shiftKey",t:13,f:[{t:2,r:"~/shiftKey"}]}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"cursor: pointer; z-index: 9;",g:1},{t:13,n:"class",f:"bar report-paper",g:1},{n:["click"],t:70,f:{r:["@this","~/inOverlay","~/inWatermark","~/temp.tree"],s:"[_0.unlink(\"widget\"),_0.unlink(\"expr\"),_0.set(\"temp\",{name:\"report \",widget:_1?\"report.overlay\":_2?\"report.watermark\":\"report\",tree:_3})]"}},{n:"class-active",t:13,f:[{t:2,x:{r:["temp.widget"],s:"_0===\"report\"||_0===\"report.watermark\"||_0===\"report.overlay\""}}]},{n:"class-hover",t:13,f:[{t:2,x:{r:["temp.hover"],s:"_0===\"report\"||_0===\"report.watermark\"||_0===\"report.overlay\""}}]},{n:["mouseover"],t:70,f:{r:["@this","~/inWatermark","~/inOverlay"],s:"[_0.set(\"temp.hover\",_1?\"report.watermark\":_2?\"report.overlay\":\"report\"),false]"}},{n:["mouseleave"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.hover\",\"\"),false]"}}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"name",g:1}],f:[{t:4,f:["Watermark"],n:50,r:"~/inWatermark"},{t:4,f:["Overlay "],n:50,r:"~/inOverlay",l:1},{t:4,f:["Report"],n:51,l:1}]}," ",{t:4,f:[{t:4,f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.header\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]"}},{n:"title",f:"The page header takes a fixed amount of space at the top of every page",t:13,g:1}],f:["Remove page header"]}],n:50,r:"report.header"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.header\",{type:\"container\"})]"}},{n:"title",f:"The page header takes a fixed amount of space at the top of every page",t:13,g:1}],f:["Add page header"]}],n:51,l:1}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.footer\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]"}},{n:"title",f:"The page footer takes a fixed amount of space at the bottom of every page",t:13,g:1}],f:["Remove page footer"]}],n:50,r:"report.footer"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.footer\",{type:\"container\"})]"}},{n:"title",f:"The page footer takes a fixed amount of space at the bottom of every page",t:13,g:1}],f:["Add page footer"]}],n:51,l:1}],n:50,x:{r:["~/temp.widget"],s:"!_0||!/^report.(water|overlay)/.test(_0)"}}],n:50,x:{r:["report.type"],s:"_0===\"page\""}}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.watermark\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]"}},{n:"title",f:"The watermark content is layered beneath the contents of each page",t:13,g:1}],f:["Remove watermark"]}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.link(\"report.watermark\",\"widget\"),_0.set(\"temp.widget\",\"report.watermark\"),false]"}},{n:"title",f:"Switch the designer to the watermark view",t:13,g:1}],f:["Edit watermark"]}],n:51,r:"~/inWatermark"}],n:50,r:"report.watermark"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.watermark\",{type:\"container\"}),_0.link(\"report.watermark\",\"widget\"),_0.set(\"temp.widget\",\"report.watermark\"),false]"}},{n:"title",f:"The watermark content is layered beneath the contents of each page",t:13,g:1}],f:["Add watermark"]}],n:51,l:1}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.overlay\",undefined),_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]"}},{n:"title",f:"The overlay content is layered above the conents of each page",t:13,g:1}],f:["Remove overlay"]}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.link(\"report.overlay\",\"widget\"),_0.set(\"temp.widget\",\"report.overlay\"),false]"}},{n:"title",f:"Switch the designer to the overlay view",t:13,g:1}],f:["Edit overlay"]}],n:51,r:"~/inOverlay"}],n:50,r:"report.overlay"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"report.overlay\",{type:\"container\"}),_0.link(\"report.overlay\",\"widget\"),_0.set(\"temp.widget\",\"report.overlay\"),false]"}},{n:"title",f:"The overlay content is layered above the conents of each page",t:13,g:1}],f:["Add overlay"]}],n:51,l:1}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.unlink(\"widget\"),_0.set(\"temp.widget\",\"\")]"}}],f:["Edit report"]}],n:50,x:{r:["~/temp.widget"],s:"/^report.(water|overlay)/.test(_0)"}}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"widgets",g:1},{n:"class-manual",t:13,f:[{t:2,x:{r:["~/report.watermark.layout"],s:"Array.isArray(_0)"}}]}],f:[{t:4,f:[{t:4,f:[{t:8,r:"widget"}],n:52,r:".widgets"}],n:54,r:"~/report.watermark"}]}],n:50,x:{r:["~/temp.widget"],s:"/^report.water/.test(_0)"}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"widgets",g:1},{n:"class-manual",t:13,f:[{t:2,x:{r:["~/report.overlay.layout"],s:"Array.isArray(_0)"}}]}],f:[{t:4,f:[{t:4,f:[{t:8,r:"widget"}],n:52,r:".widgets"}],n:54,r:"~/report.overlay"}]}," "],n:50,x:{r:["~/temp.widget"],s:"/^report.overlay/.test(_0)"},l:1},{t:4,f:[" ",{t:4,f:[{t:8,r:"widget",c:{r:"~/report.header"},z:[{n:"label",x:{x:{r:[],s:"\"Page Header\""}}}]}],n:50,x:{r:["~/report.type","~/report.header"],s:"_0===\"page\"&&_1"}}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"widgets",g:1},{n:"class-manual",t:13,f:[{t:2,x:{r:["~/report.layout"],s:"Array.isArray(_0)"}}]}],f:[{t:4,f:[{t:4,f:[{t:8,r:"widget"}],n:52,r:".widgets"}],n:54,r:"~/report"}]}," ",{t:4,f:[{t:8,r:"widget",c:{r:"~/report.footer"},z:[{n:"label",x:{x:{r:[],s:"\"Page Footer\""}}}]}],n:50,x:{r:["~/report.type","~/report.footer"],s:"_0===\"page\"&&_1"}}],n:51,l:1}]}]}]}]}],n:51,l:1}],"widget-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Width of the ",{t:2,r:".type"}," in rem, if a number, a percentage of the parent, grow/fill, or an expression, defaulting to 100%"],t:13}],f:["Width ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".width",".width.percent"],s:"[(_0).set(\".width\",typeof _1===\"number\"||_1===undefined?{percent:_1}:typeof _1===\"object\"&&\"percent\" in _1?{x:\"\"}:typeof _1===\"object\"&&\"x\" in _1?\"grow\":_2)]"}},{n:"title",f:[{t:2,x:{r:[".width"],s:"typeof _0===\"number\"||_0===undefined?\"Change to percent\":typeof _0===\"object\"&&\"percent\" in _0?\"Change to Expression\":typeof _0===\"object\"&&\"x\" in _0?\"Change to Fill/Grow\":\"Change to REM\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".width.x\"),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".width"],s:"typeof _0===\"object\"&&\"x\" in _0"}}]}," ",{t:7,e:"span",f:[{t:4,f:[{t:7,e:"div",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".width"}],t:13},{n:"style-width",f:"calc(100% - 2rem)",t:13}]},{t:7,e:"span",m:[{t:13,n:"class",f:"unit",g:1}],f:["rem"]}]}],n:50,x:{r:[".width"],s:"typeof _0===\"number\"||_0===undefined"}},{t:4,f:[{t:7,e:"div",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".width.percent"}],t:13},{n:"style-width",f:"calc(100% - 2rem)",t:13}]},{t:7,e:"span",m:[{t:13,n:"class",f:"unit",g:1}],f:["%"]}]}," "],n:50,x:{r:[".width"],s:"typeof _0===\"object\"&&\"percent\" in _0"},l:1},{t:4,f:[" ",{t:7,e:"div",f:["Fill/Grow"]}," "],n:50,x:{r:[".width"],s:"_0===\"grow\""},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".width.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".width"],s:"typeof _0===\"object\""},l:1}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Height of the ",{t:2,r:".type"}," in rem, if a number, a percentage of the parent, or an expression, fill/grow, defaults to ",{t:4,f:["the largest font size or 1"],n:50,x:{r:["type"],s:"_0===\"label\""}},{t:4,f:["auto"],n:50,x:{r:[".type"],s:"_0===\"container\""},l:1},{t:4,f:["1"],n:51,l:1}],t:13}],f:["Height ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".height",".type",".height.percent"],s:"[(_0).set(\".height\",typeof _1===\"number\"||_1===undefined?{percent:_1}:typeof _1===\"object\"&&\"percent\" in _1?{x:\"\"}:typeof _1===\"object\"&&\"x\" in _1?\"grow\":_1===\"grow\"&&_2===\"container\"?\"auto\":_3)]"}},{n:"title",f:[{t:2,x:{r:[".height",".type"],s:"typeof _0===\"number\"||_0===undefined?\"Change to percent\":typeof _0===\"object\"&&\"percent\" in _0?\"Change to Expression\":typeof _0===\"object\"&&\"x\" in _0?\"Change to Fill/Grow\":_0===\"grow\"&&_1===\"container\"?\"Change to Auto\":\"Change to REM\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"switch"}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".height.x\"),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".height"],s:"typeof _0===\"object\"&&\"x\" in _0"}}]}," ",{t:7,e:"span",f:[{t:4,f:[{t:7,e:"div",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".height"}],t:13},{n:"style-width",f:"calc(100% - 2rem)",t:13}]},{t:7,e:"span",m:[{t:13,n:"class",f:"unit",g:1}],f:["rem"]}]}],n:50,x:{r:[".height"],s:"typeof _0===\"number\"||_0===undefined"}},{t:4,f:[{t:7,e:"div",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".height.percent"}],t:13},{n:"style-width",f:"calc(100% - 2rem)",t:13}]},{t:7,e:"span",m:[{t:13,n:"class",f:"unit",g:1}],f:["%"]}]}," "],n:50,x:{r:[".height"],s:"typeof _0===\"object\"&&\"percent\" in _0"},l:1},{t:4,f:[" ",{t:7,e:"div",f:["Fill/Grow"]}," "],n:50,x:{r:[".height"],s:"_0===\"grow\""},l:1},{t:4,f:[" ",{t:7,e:"div",f:["Auto"]}," "],n:50,x:{r:[".height"],s:"_0===\"auto\""},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".height.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".height"],s:"typeof _0===\"object\""},l:1}]}]}," ",{t:4,f:[{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Offset from the sides of the container. Positive values are the offset from the left, and negative values are the offset from the right, where -1 will be touching the right side.",t:13,g:1}],f:["X"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,rx:{r:".layout",m:[{r:["@this","~/temp.widget"],s:"_0.lastKey(_1)"},{r:[],s:"0"}]}}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Offset from the top or bottom of the container. Positive values are the offset from the top, and negative values are the offset from the bottom, where -1 will be touching the bottom.",t:13,g:1}],f:["Y"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,rx:{r:".layout",m:[{r:["@this","~/temp.widget"],s:"_0.lastKey(_1)"},{r:[],s:"1"}]}}],t:13}]}]}]}],n:50,x:{r:[".layout"],s:"Array.isArray(_0)"}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Cause the widget to start on the next line in an automatic layout",t:13,g:1}],f:["Break? ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context","^^/br"],s:"[(_0).set(\"^^/br\",typeof _1===\"object\"?false:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:["^^/br"],s:"typeof _0===\"object\"?\"Change to Boolean\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\"^^/br.x\"),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:["^^/br"],s:"typeof _0===\"object\"&&\"x\" in _0"}}," "]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"^^/br"}],t:13}]}],n:50,x:{r:["^^/br"],s:"typeof _0!==\"object\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:"^^/br.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:["^^/br"],s:"typeof _0===\"object\""},l:1}]}]}],n:51,l:1}],n:54,rx:{r:"~/",m:[{r:["@this","~/temp.widget"],s:"_0.split(_1,2)"}]}},{t:8,r:"margin-prop"}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Setting box to contain will make the margins fit within the designated size. Setting box to expand will expand the width to include the margin. The default depends on the type of sizing, with contain for percentages and expand for others.",t:13,g:1}],f:["Box"]},{t:7,e:"span",f:[" ",{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".box"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["Default"]}," ",{t:7,e:"option",m:[{n:"value",f:"contain",t:13}],f:["Contain"]}," ",{t:7,e:"option",m:[{n:"value",f:"expand",t:13}],f:["Expand"]}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The size in px for the border of this ",{t:2,r:".type"},". The base value for this property is a four number tuple with values for the top, right, bottom, and left. A two number tuple is converted to top/bottom and left/right. A single number tuple spcifies the same number for all sides. A single number specifies only the bottom border."],t:13}],f:["Border ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".border\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".border"],s:"typeof _0===\"string\""}}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"toggles",g:1}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".border"],s:"typeof _0===\"undefined\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".border\",undefined)]"}}],n:50,x:{r:[".border"],s:"typeof _0!==\"undefined\""}}],f:["None"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".border"],s:"typeof _0===\"number\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".border\",1)]"}}],n:50,x:{r:[".border"],s:"typeof _0!==\"number\""}}],f:["Bottom"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".border.length"],s:"_0===1"}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".border\",[1])]"}}],n:50,x:{r:[".border.length"],s:"_0!==1"}}],f:["All"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".border.length"],s:"_0===2"}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".border\",[1,1])]"}}],n:50,x:{r:[".border.length"],s:"_0!==2"}}],f:["Paired"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".border.length"],s:"_0===4"}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".border\",[1,1,1,1])]"}}],n:50,x:{r:[".border.length"],s:"_0!==2"}}],f:["Individual"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".border"],s:"typeof _0===\"string\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".border\",\"\")]"}}],n:50,x:{r:[".border"],s:"typeof _0!==\"string\""}}],f:["Expression"]}]}," ",{t:4,f:[{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border"}],t:13}]}],n:50,x:{r:[".border"],s:"typeof _0===\"number\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".border"}],t:13},{n:"tabout",f:0,t:13}]}]}," "],n:50,x:{r:[".border"],s:"typeof _0===\"string\""},l:1},{t:4,f:[" ",{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.0"}],t:13}]}," "],n:50,x:{r:[".border.length"],s:"_0===1"},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"sides",g:1}],f:[{t:7,e:"span"},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.0"}],t:13}]},{t:7,e:"span"}," ",{t:7,e:"span"},{t:7,e:"div",m:[{t:13,n:"class",f:"square",g:1}]},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.1"}],t:13}]}," ",{t:7,e:"span"},{t:7,e:"span"},{t:7,e:"span"}]}," "],n:50,x:{r:[".border.length"],s:"_0===2"},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"sides",g:1}],f:[{t:7,e:"span"},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.0"}],t:13}]},{t:7,e:"span"}," ",{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.3"}],t:13}]},{t:7,e:"div",m:[{t:13,n:"class",f:"square",g:1}]},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.1"}],t:13}]}," ",{t:7,e:"span"},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".border.2"}],t:13}]},{t:7,e:"span"}]}],n:50,x:{r:[".border.length"],s:"_0===4"},l:1}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Horizontal alignment of text within this ",{t:2,r:".type"},"."],t:13}],f:["Alignment ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.align"],s:"[(_0).set(\".font.align\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.align"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.align.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.align"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.align.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.align"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".font.align"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["(default)"]}," ",{t:7,e:"option",f:["left"]}," ",{t:7,e:"option",f:["center"]}," ",{t:7,e:"option",f:["right"]}," ",{t:7,e:"option",f:["justify"]}]}],n:51,l:1}]}]}],n:50,x:{r:[".type"],s:"_0!==\"image\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Display all whitespace, including newlines, within the content of the ",{t:2,r:".type"},"?"],t:13}],f:["Significant Space? ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.pre"],s:"[(_0).set(\".font.pre\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.pre"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.pre.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.pre"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.pre.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.pre"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{t:73,v:"t",f:"false"},{n:"checked",f:[{t:2,r:".font.pre"}],t:13},{n:["change"],t:70,f:{r:["@context","@node.checked"],s:"[(_0).set(\".font.pre\",_1?true:undefined)]"}}]}],n:51,l:1}]}]}],n:51,x:{r:[".type"],s:"_0===\"measured\"||_0===\"image\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, content that would exceed the specified boundaries of the component will be clipped rather than overflowing.",t:13,g:1}],f:["Prevent Overflow? ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.clamp"],s:"[(_0).set(\".font.clamp\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.clamp"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.clamp.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.clamp"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.clamp.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.clamp"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{t:73,v:"t",f:"false"},{n:"checked",f:[{t:2,r:".font.clamp"}],t:13},{n:["change"],t:70,f:{r:["@context","@node.checked"],s:"[(_0).set(\".font.clamp\",_1?true:undefined)]"}}]}],n:51,l:1}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Size of the text within this ",{t:2,r:".type"}," in rem."],t:13}],f:["Text Size ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.size"],s:"[(_0).set(\".font.size\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.size"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.size.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.size"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.size.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.size"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".font.size"}],t:13}]}],n:51,l:1}]}]}],n:50,x:{r:[".type"],s:"_0!==\"image\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The height of lines within this ",{t:2,r:".type"}," in rem. This defaults to the text size if it is set and a line height is not supplied."],t:13}],f:["Line Height ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.line"],s:"[(_0).set(\".font.line\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.line"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.line.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.line"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.line.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.line"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".font.line"}],t:13}]}],n:51,l:1}]}]}],n:51,x:{r:[".type"],s:"_0===\"image\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The font family for text appearing within this ",{t:2,r:".type"},". Browser safe fonts are recommended e.g. serif, sans-serif, monospace."],t:13}],f:["Font Family ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.family"],s:"[(_0).set(\".font.family\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.family"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.family.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.family"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.family.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.family"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".font.family"}],t:13}]}],n:51,l:1}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The color of text appearing within this ",{t:2,r:".type"},"."],t:13}],f:["Text Color ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.color"],s:"[(_0).set(\".font.color\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.color"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.color.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.color"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.color.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.color"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".font.color"}],t:13}]}],n:51,l:1}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The weight of text appearing within this ",{t:2,r:".type"},"."],t:13}],f:["Weight ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.weight"],s:"[(_0).set(\".font.weight\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.weight"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.weight.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.weight"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.weight.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.weight"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".font.weight"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["(default)"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"400"}}],t:13}],f:["light"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"500"}}],t:13}],f:["normal"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"600"}}],t:13}],f:["bold"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"700"}}],t:13}],f:["bolder"]}]}],n:51,l:1}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The background color of this ",{t:2,r:".type"},"."],t:13}],f:["Background Color ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".bg"],s:"[(_0).set(\".bg\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".bg"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".bg.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".bg"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".bg.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".bg"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".bg"}],t:13}]}],n:51,l:1}]}]}],n:50,x:{r:[".type"],s:"_0!==\"image\""}},{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["The radius, including CSS unit, to apply to the corners of this ",{t:2,r:".type"}," if it has a border."],t:13}],f:["Radius ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".radius"],s:"[(_0).set(\".radius\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".radius"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".radius.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".radius"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".radius.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".radius"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".radius"}],t:13}]}],n:51,l:1}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Padding to add to the right side of the ",{t:2,r:".type"},", which is useful for right-aligned text"],t:13}],f:["Right Pad"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".font.right"}],t:13}]}]}]}],n:50,x:{r:[".margin"],s:"!_0"}}],"image-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The URL of the picture to load into this image. This can be a data url.",t:13,g:1}],f:["URL ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".url\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".url"}],t:13},{n:"tabout",f:0,t:13}]}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"This property specifies how the image should be rendered if its aspect ratio and dimensions do not match the size of this image widget.",t:13,g:1}],f:["Fit ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".fit"],s:"[(_0).set(\".fit\",!_1||typeof _1===\"string\"?{x:\"\"}:undefined)]"}},{n:"title",f:["Switch to ",{t:2,x:{r:[".fit"],s:"_0&&typeof _0!==\"object\"?\"Expression\":\"Value\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"switch"}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".fit.x\"),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".fit"],s:"typeof _0===\"object\"&&\"x\" in _0"}}," "]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".fit"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["Contain"]}," ",{t:7,e:"option",m:[{n:"value",f:"cover",t:13}],f:["Cover"]}," ",{t:7,e:"option",m:[{n:"value",f:"stretch",t:13}],f:["Stretch"]}]}],n:50,x:{r:[".fit"],s:"!_0||typeof _0===\"string\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".fit.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:51,l:1}]}]}],"repeater-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The source of the data that this repeater should iterate over. Report sources can be further grouped, filtered, and sorted here before being rendered by the repeater.",t:13,g:1}],f:["Source ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:[".source","@keypath","@this","@context"],s:"[typeof _0===\"string\"?_2.editExpr(_1+\".source\"):_2.editReportSrc((_3),\".source\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"toggles",g:1}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".source"],s:"typeof _0===\"string\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".source\",\"\")]"}}],n:50,x:{r:[".source"],s:"typeof _0!==\"string\""}}],f:["Expression"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".source"],s:"typeof _0!==\"string\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".source\",{source:\"\"})]"}}],n:50,x:{r:[".source"],s:"typeof _0===\"string\""}}],f:["Source"]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".source"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".source"],s:"typeof _0===\"string\""}}," ",{t:4,f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".source.source"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:"",t:13}],f:["(None)"]},{t:4,f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[".name",".source"],s:"_0||_1"}}],t:13}],f:[{t:2,x:{r:[".label",".name",".source"],s:"_0||_1||_2"}}]}],n:52,r:"~/report.sources"}]}],n:50,x:{r:[".source"],s:"typeof _0!==\"string\""}}]}]}," ",{t:19,f:[{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, the header will be rerendered at the beginning of each new page.",t:13,g:1}],f:["Header Per Page?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@context"],s:"[(_0).toggle(\".headerPerPage\")]"}},{n:"checked",f:[{t:2,x:{r:[".headerPerPage"],s:"_0!==false"}}],t:13}]}]}]}],n:50,x:{r:["repeater.header","~/report.type"],s:"_0&&_1===\"page\""}}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, the header will be rendered before all of the groups.",t:13,g:1}],f:["Show Header?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,rx:{r:"repeater.groupHeaders",m:[{t:30,n:"repeater.group.length"}]}}],t:13}]}]}]}],n:50,x:{r:["repeater.header","repeater.group.length"],s:"_0&&_1"}}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, the footer will be rendered again after all of the groups. You can use the @level reference to render different footers for different group levels within the repeater.",t:13,g:1}],f:["Show Footer?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,rx:{r:"repeater.groupEnds",m:[{t:30,n:"repeater.group.length"}]}}],t:13}]}]}]}],n:50,x:{r:["repeater.footer","repeater.group.length"],s:"_0&&_1"}}],n:54,z:[{n:"repeater",x:{rx:{r:"~/",m:[{r:["@this","~/temp.widget"],s:"_0.split(_1)"}]}}}]}],"measured-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The text to appear in this label. This is an expression, so literal text will need to be specified as a string expression.",t:13,g:1}],f:["Text ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".text\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".text"}],t:13},{n:"tabout",f:0,t:13}]}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The font metric to use when computing the height that the text will require based on the number of characters in the Text. This is the average width of the font character in em. Some fonts have automatic metric applied based on their name, such as browser-safe fonts and those with names containing things like 'narrow' or 'mono'.",t:13,g:1}],f:["Metric ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".font.metric"],s:"[(_0).set(\".font.metric\",typeof _1===\"object\"?undefined:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".font.metric"],s:"typeof _0===\"object\"?\"Change to value\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".font.metric.x\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".font.metric"],s:"typeof _0===\"object\""}}]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".font.metric.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".font.metric"],s:"typeof _0===\"object\""}},{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".font.metric"}],t:13}]}],n:51,l:1}]}]}],"container-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Render this container as a macro with its properties and/or children supplied at render time.",t:13,g:1}],f:["Macro ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".macro\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".macro"}],t:13},{n:"tabout",f:0,t:13}]}]}]}]}," ",{t:19,f:[{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, show the repeater header for this grouping of rows. You can use the @level reference to modify the header for different levels within the repeater.",t:13,g:1}],f:["Show Header?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,rx:{r:"repeater.groupHeaders",m:[{r:["repeater.group.length","index"],s:"_0-1-_1"}]}}],t:13}]}]}]}],n:50,x:{r:["repeater.header","index","repeater.group"],s:"_0&&_2&&_2[_1]"}}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, show the repeater footer for this grouping of rows. You can use the @level reference to modify the footer for different levels within the repeater.",t:13,g:1}],f:["Show Footer?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,rx:{r:"repeater.groupEnds",m:[{r:["repeater.group.length","index"],s:"_0-1-_1"}]}}],t:13}]}]}]}],n:50,x:{r:["repeater.footer","index","repeater.group"],s:"_0&&_2&&_2[_1]"}}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If enabled, the row will be rendered internally to update data gathered labels as rows render, but the row will not be added to the report.",t:13,g:1}],f:["Elide? ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context",".elide"],s:"[(_0).set(\".elide\",typeof _1===\"object\"?false:{x:\"\"})]"}},{n:"title",f:[{t:2,x:{r:[".elide"],s:"typeof _0===\"object\"?\"Change to Boolean\":\"Change to Expression\""}}],t:13},{n:"tabindex",f:"-1",t:13,g:1}],f:[" ",{t:8,r:"switch"}," "]},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".elide.x\"),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".elide"],s:"typeof _0===\"object\"&&\"x\" in _0"}}," "]},{t:7,e:"span",f:[" ",{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".elide"}],t:13}]}],n:50,x:{r:[".elide"],s:"typeof _0!==\"object\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".elide.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".elide"],s:"typeof _0===\"object\""},l:1}]}]}],n:50,x:{r:["repeater","index"],s:"_0&&_1===\"row\""}}],n:54,z:[{n:"repeater",x:{rx:{r:"~/",m:[{r:["@this","~/temp.widget"],s:"_0.split(_1,2)"}]}}},{n:"index",x:{x:{r:["@this","~/temp.widget"],s:"_0.lastKey(_1)"}}}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["If enabled, render the ",{t:2,x:{r:["@this","~/temp.widget"],s:"_0.lastKey(_1)"}}," at the outer edge of the page margin rather than within the inner boundaries of the page margin."],t:13}],f:["Render in margin?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".outer"}],t:13}]}]}]}],n:50,x:{r:["~/report.type","~/temp.widget","~/report.margin"],s:"_0===\"page\"&&(_1===\"report.header\"||_1===\"report.footer\")&&_2"}}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Auto layout containers position their children from top to bottom, left to right, along the x axis, with children wrapping below the tallest child on the line above. Manual layout containers must have x and y coordinates specified for each child, allowing overlap and defaulting to 0, 0.",t:13,g:1}],f:["Layout"]},{t:7,e:"span",f:[" ",{t:7,e:"select",m:[{t:73,v:"t",f:"false"},{n:"value",f:[{t:2,x:{r:[".layout"],s:"Array.isArray(_0)?\"manual\":\"auto\""}}],t:13},{n:["change"],t:70,f:{r:["@context","@node.value","@this",".widgets.length"],s:"[(_0).set(\".layout\",_1===\"manual\"?_2.fillArray(_3):undefined)]"}}],f:[{t:7,e:"option",m:[{n:"value",f:"auto",t:13}],f:["Auto"]}," ",{t:7,e:"option",m:[{n:"value",f:"manual",t:13}],f:["Manual"]}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If bridging is enabled, the container can span multiple pages.",t:13,g:1}],f:["Bridge Breaks?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".bridge"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If supplied, this expression is evaluated and the result is added to the context stack in which the container and its children are rendered. If the initial value should be used as the context while side-effecting expressions are evaluated, the last expression in the context source should be _, @value, or a false-y value.",t:13,g:1}],f:["Context ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".context\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".context"}],t:13},{n:"tabout",f:0,t:13}]}]}]}]}],"html-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The html to appear in this HTML widget.",t:13,g:1}],f:["HTML ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".html\",{html:true})]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".html"}],t:13},{n:"tabout",f:0,t:13},{n:"template",f:0,t:13}]}]}]}]}],"label-props":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The text to appear in this label. This is an expression, so literal text will need to be specified as a string expression.",t:13,g:1}],f:["Text ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".text\",{label:true})]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:["click"],t:70,f:{r:["@context",".text","@this"],s:"[(_0).set(\".text\",_2.getPartStrings(_1)),_2.editExpr(\".text\",{label:true})]"}}],f:["Convert to Text"]}],n:50,x:{r:[".text"],s:"Array.isArray(_0)"}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".text"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:51,l:1}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The name to use to collect values that are computed in this label in each row. It is often useful to use the Format property to modify the display for this computed value, so that the raw value can be used for computations in the footer.",t:13,g:1}],f:["ID ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove aggregate id",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".id\",undefined)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"times"}]}],n:50,x:{r:[".id"],s:"_0!=null"}},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Add aggregate id",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".id\",\"\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:["+"]}],n:51,l:1}," "]},{t:7,e:"span",f:[{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".id"}],t:13}]}],n:50,x:{r:[".id"],s:"_0!=null"}}]}]}],n:50,x:{r:["@this","~/temp.widget"],s:"_0.inRepeater(_1)"}}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Process the text of the label for inline styles.",t:13,g:1}],f:["Styled?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".styled"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The name of a formatter to apply to the computed Text value of this label.",t:13,g:1}],f:["Format ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:4,f:[" ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove format",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".format\",undefined)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"times"}]}],n:50,x:{r:[".format"],s:"_0!=null"}},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Add format",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".format\",{})]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:["+"]}],n:51,l:1}," "]},{t:7,e:"span",f:[{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".format.name"}],t:13},{n:"style-width",f:"80%",t:13}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Add parameter",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).push(\".format.args\",\"\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:["+"]}," ",{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"."}],t:13},{n:"style-width",f:"80%",t:13}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove parameter",t:13,g:1},{n:["click"],t:70,f:{r:["@context","@index"],s:"[(_0).splice(\"../\",_1,1)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"times"}]}],n:52,r:".format.args"}],n:50,x:{r:[".format"],s:"_0!=null"}}]}]}],"margin-prop":[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["If this evaluates to true, the ",{t:2,r:".type"}," will be hidden and not affect automatic layouts"],t:13}],f:["Hidden ",{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".hide\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".hide"}],t:13},{n:"tabout",f:0,t:13}]}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:["Additional padding within the borders of the ",{t:2,r:".type"},". The base value for this property is a four number tuple with values for the top, right, bottom, and left. A two number tuple is converted to top/bottom and left/right. A single number specifies the same number for all sides."],t:13}],f:["Margin ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"hide",g:1},{n:"tabindex",f:"-1",t:13,g:1}]},{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\".margin.x\"),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}],n:50,x:{r:[".margin"],s:"typeof _0===\"object\"&&\"x\" in _0"}}," "]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"toggles",g:1}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".margin"],s:"typeof _0===\"undefined\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".margin\",undefined)]"}}],n:50,x:{r:[".margin"],s:"typeof _0!==\"undefined\""}}],f:["None"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".margin"],s:"typeof _0===\"number\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".margin\",1)]"}}],n:50,x:{r:[".margin"],s:"typeof _0!==\"number\""}}],f:["All"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".margin.length"],s:"_0===2"}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".margin\",[1,1])]"}}],n:50,x:{r:[".margin.length"],s:"_0!==2"}}],f:["Paired"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".margin.length"],s:"_0===4"}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".margin\",[1,1,1,1])]"}}],n:50,x:{r:[".margin.length"],s:"_0!==4"}}],f:["Individual"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:[".margin"],s:"typeof _0===\"object\"&&\"x\" in _0"}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".margin\",{x:\"\"})]"}}],n:50,x:{r:[".margin",".margin.x"],s:"!_0||_1===undefined"}}],f:["Expression"]}]}," ",{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{t:73,v:"l"},{n:"value",f:[{t:2,r:".margin"}],t:13}]}],n:50,x:{r:[".margin"],s:"typeof _0===\"number\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"sides",g:1}],f:[{t:7,e:"span"},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".margin.0"}],t:13}]},{t:7,e:"span"}," ",{t:7,e:"span"},{t:7,e:"div",m:[{t:13,n:"class",f:"square",g:1}]},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".margin.1"}],t:13}]}," ",{t:7,e:"span"},{t:7,e:"span"},{t:7,e:"span"}]}," "],n:50,x:{r:[".margin.length"],s:"_0===2"},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"sides",g:1}],f:[{t:7,e:"span"},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".margin.0"}],t:13}]},{t:7,e:"span"}," ",{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".margin.3"}],t:13}]},{t:7,e:"div",m:[{t:13,n:"class",f:"square",g:1}]},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".margin.1"}],t:13}]}," ",{t:7,e:"span"},{t:7,e:"input",m:[{t:73,v:"l"},{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:".margin.2"}],t:13}]},{t:7,e:"span"}]}," "],n:50,x:{r:[".margin.length"],s:"_0===4"},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".margin.x"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:50,x:{r:[".margin.x"],s:"_0!==undefined"},l:1}]}]}],"page-props":[],sure:[],bottom:[{t:7,e:"div",m:[{t:13,n:"class",f:"bottom-bar",g:1},{n:"class-shrinkleft",t:13,f:[{t:2,r:"~/show.shrinkleft"}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Set values for report parameters",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"params\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.bottom.tab\",\"params\"),_0.set(\"show.bottom\",true)]"}}],f:["Parameters"]}],n:50,r:"~/report.parameters.length"}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Evaluate expressions",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"!_0||_0===\"expr\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.bottom.tab\",\"expr\"),_0.set(\"show.bottom\",true)]"}}],f:[{t:4,f:["Expression"],n:50,r:"~/temp.expr.path"},{t:4,f:["Evaluate"],n:51,l:1}]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Expression language reference",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"langref\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.bottom.tab\",\"langref\"),_0.set(\"show.bottom\",true)]"}}],f:["Language"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Operator reference",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"opref\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.bottom.tab\",\"opref\"),_0.set(\"show.bottom\",true)]"}}],f:["Operators"]}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:["Modify report parameter ",{t:2,r:"~/param.name"}],t:13},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"param\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.bottom.tab\",\"param\"),_0.set(\"show.bottom\",true)]"}}],f:["Parameter"]}],n:50,r:"~/temp.bottom.param"}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:["Modify data source ",{t:2,x:{r:["~/source.name","~/source.source"],s:"_0||_1"}}],t:13},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"source\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.bottom.tab\",\"source\"),_0.set(\"show.bottom\",true)]"}}],f:["Source"]}],n:50,r:"~/temp.bottom.source"}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"which",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.checkLink(\"expr\")]"}},{n:"title",f:["Close expression for ",{t:2,r:"~/temp.expr.path"}],t:13}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1}],f:[{t:8,r:"times"}]}," ",{t:2,x:{r:["~/temp.expr.path"],s:"_0.replace(/\\./g,\" 〉 \")"}}]}],n:50,x:{r:["~/temp.expr.path","~/temp.bottom.tab"],s:"_0&&(!_1||_1===\"expr\")"}}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"which",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.checkLink(\"param\")]"}},{n:"title",f:["Close parameter editor for ",{t:2,r:"~/param.name"}],t:13}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1}],f:[{t:8,r:"times"}]}," Parameter ",{t:2,x:{r:["@this","~/temp.bottom.param"],s:"+_0.lastKey(_1)+1"}}]}],n:50,x:{r:["~/temp.bottom.param","~/temp.bottom.tab"],s:"_0&&_1===\"param\""}}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"which",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.checkLink(\"source\")]"}},{n:"title",f:["Close source editor for ",{t:2,r:"~/temp.bottom.source"}],t:13}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1}],f:[{t:8,r:"times"}]}," Source ",{t:2,x:{r:["@this","~/temp.bottom.source"],s:"+_0.lastKey(_1)+1"}}]}],n:50,x:{r:["~/temp.bottom.source","~/temp.bottom.tab"],s:"_0&&_1===\"source\""}}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1}]}," ",{t:7,e:"button",m:[{t:13,n:"style",f:"margin-left: 1rem;",g:1},{t:13,n:"class",f:"ico",g:1},{n:"title",f:[{t:4,f:["Shrink"],n:50,r:"~/max.bottom"},{t:4,f:["Embiggen"],n:51,l:1}," the bottom pane"],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.toggle(\"max.bottom\")]"}},{n:"class",f:[{t:4,f:["off"],n:50,x:{r:["~/max.bottom"],s:"!_0"}}],t:13}],f:[{t:8,r:"max"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:[{t:4,f:["Hide"],n:50,r:"~/show.bottom"},{t:4,f:["Show"],n:51,l:1}," the bottom pane"],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.toggle(\"show.bottom\")]"}},{n:"class",f:[{t:4,f:["down"],n:50,r:"~/show.bottom"},{t:4,f:["up"],n:51,l:1},"-arrow"],t:13}],f:[{t:8,r:"arrow"}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"bottom-pane",g:1},{n:"class-active",t:13,f:[{t:2,r:"~/show.bottom"}]},{n:"class-max",t:13,f:[{t:2,r:"~/max.bottom"}]},{n:"class-shrinkleft",t:13,f:[{t:2,r:"~/show.shrinkleft"}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"bottom",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"tab",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"langref\""}}]}],f:[{t:7,e:"iframe",m:[{n:"srcdoc",f:[{t:2,x:{r:["@this","~/settings.scale","@style.theme"],s:"_0.langref(_1,_2)"}}],t:13},{n:"id",f:"langref",t:13,g:1}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"opref\""}}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ops-search",g:1}],f:[{t:7,e:"input",m:[{t:73,v:"l",f:"500"},{n:"placeholder",f:"Search...",t:13},{n:"value",f:[{t:2,r:"opDocSearch"}],t:13},{n:"style",f:"width: 10em; margin: 0.5em;",t:13},{n:"title",f:"Find any operators with docs containing the string entered here.",t:13}]}," ",{t:7,e:"input",m:[{t:73,v:"l",f:"500"},{n:"placeholder",f:"Operator...",t:13},{n:"value",f:[{t:2,r:"opDoc"}],t:13},{n:"style",f:"width: 10em; margin: 0.5em;",t:13},{n:"title",f:"Find any operators with a name containing the string entered here.",t:13}]}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0.5rem; height: 100%; width: 100%; overflow: auto; box-sizing: border-box;",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"max-width: 60em; margin: auto;",g:1}],f:[{t:7,e:"h2",m:[{t:13,n:"style",f:"text-align: center;",g:1}],f:["Raport Operators"]}," ",{t:7,e:"dl",f:[{t:4,f:[{t:4,f:[{t:7,e:"dt",m:[{t:13,n:"style",f:"border-bottom: 1px dotted; margin-bottom: 0.25rem; margin-top: 2rem;",g:1}],f:[{t:7,e:"h3",f:[{t:2,x:{r:["op.0.0","op.0"],s:"_0===\"#\"?\"Format \"+_1.slice(1):_1"}},{t:4,f:[" ",{t:7,e:"em",m:[{t:13,n:"style",f:"font-size: 0.8em;",g:1}],f:["- (alias for ",{t:7,e:"strong",f:[{t:2,r:"op.1.alias"}]},")"]}],n:50,r:"op.1.alias"}]}]}," ",{t:7,e:"dd",f:[{t:7,e:"dl",f:[{t:4,f:[{t:7,e:"dt",f:[{t:7,e:"strong",f:[{t:2,r:".proto"}]},{t:4,f:[" ",{t:7,e:"em",f:["or"]}," ",{t:7,e:"strong",f:["arg1 ",{t:2,r:"op.0"}," arg2"]}],n:50,r:".bin"},{t:4,f:[" or ",{t:7,e:"strong",f:[{t:2,r:"op.0"},"arg1"]}],n:50,r:".un"}," ",{t:4,f:[{t:7,e:"br"},{t:7,e:"em",f:["arg1 can implicitly be ",{t:7,e:"code",f:["@source"]}]}],n:50,r:".agg"}]}," ",{t:7,e:"dd",f:[{t:2,r:".desc"}]}],n:52,r:"op.1.sig"}]}," ",{t:4,f:[{t:7,e:"h4",f:["Options"]}," ",{t:7,e:"dl",f:[{t:4,f:[{t:7,e:"dt",f:[{t:7,e:"strong",f:[{t:2,x:{r:[".name"],s:"Array.isArray(_0)?_0.join(\" or \"):_0"}},{t:4,f:[" - ",{t:7,e:"em",f:[{t:2,r:".type"}]}],n:50,r:".type"}]}]}," ",{t:7,e:"dd",f:[{t:2,r:".desc"}]}],n:52,r:"op.1.opts"}]}],n:50,r:"op.1.opts.length"}]}],n:50,x:{r:["op.0","~/opDoc","op.1","~/opDocSearch"],s:"(!_1||_0.includes(_1))&&(!_3||JSON.stringify(_2).toLowerCase().includes(_3.toLowerCase()))"}}],n:52,z:[{n:"op",x:{r:"."}}],r:"~/operators"}]}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"!_0||_0===\"expr\""}}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"editor",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Evaluate the current expression (CTRL+Enter)",t:13,g:1},{n:"disabled",f:[{t:2,x:{r:["~/temp.expr.str"],s:"!_0"}}],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.eval()]"}},{n:"class-error",t:13,f:[{t:2,r:"~/temp.expr.error"}]}],f:[{t:8,r:"play"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Modify the current expression",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"text\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.tab\",\"text\")]"}}],f:[{t:4,f:["Template"],n:50,r:"~/temp.expr.template"},{t:4,f:["Text"],n:51,l:1}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:"title",f:"Format the current expression",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.fmt()]"}}],f:["Format"]}],n:50,x:{r:["~/temp.expr.tab","~/temp.expr.template"],s:"_0===\"text\"&&!_1"}}," ",{t:4,f:[{t:7,e:"label",m:[{t:13,n:"style",f:"margin-left: 1em;",g:1},{n:"title",f:"Enable to treat the current expression as a template",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"~/temp.expr.template"}],t:13}]}," Template?"]}],n:50,x:{r:["~/temp.expr.tab","~/temp.expr.path"],s:"_0===\"text\"&&!_1"}}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"editor-buttons",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"toggles",g:1}],f:[{t:19,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["t"],s:"!_0||_0===\"json\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.parsedtype\",\"json\")]"}}],n:50,x:{r:["t"],s:"_0&&_0!==\"json\""}},{n:"title",f:"Show the AST as JSON. Double click to copy the JSON to the clipboard.",t:13,g:1},{n:["dblclick"],t:70,f:{r:["@this","~/temp.expr.ast"],s:"[_0.copyToClipboard(JSON.stringify(_1))]"}}],f:["JSON"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["t"],s:"_0===\"raport\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.parsedtype\",\"raport\")]"}}],n:50,x:{r:["t"],s:"_0!==\"raport\""}},{n:"title",f:"Show the AST as a Raport expression.",t:13,g:1}],f:["Raport"]}],n:54,z:[{n:"t",x:{r:"~/temp.expr.parsedtype"}}]}]}]}," ",{t:4,f:[{t:7,e:"label",m:[{t:13,n:"style",f:"margin-left: 2em;",g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",t:13,f:[{t:2,r:"~/temp.expr.jsonsquash"}]},{n:"title",f:"Enable to display JSON with no additional whitespace",t:13}]}," Compact?"]}],n:50,x:{r:["~/temp.expr.parsedtype"],s:"_0===\"json\"||!_0"}}],n:50,x:{r:["~/temp.expr.tab"],s:"_0===\"parsed\""}}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"Modify the current HTML template",t:13,g:1},{n:"style-display",f:[{t:2,x:{r:["~/temp.expr.html"],s:"_0?\"\":\"none\""}}],t:13},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"html\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.tab\",\"html\")]"}}],f:["HTML"]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 2;",g:1}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"View the result of the current expression's execution",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"result\""}}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.tab\",\"result\")]"}}],f:["Result"]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"tab",g:1},{n:"title",f:"View the parse tree of the current expression",t:13,g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"parsed\""}}]},{n:"class-error",t:13,f:[{t:2,r:"~/temp.expr.error"}]},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.tab\",\"parsed\")]"}}],f:["Parsed"]}],n:50,r:"~/temp.expr.parsed"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab text",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"!_0||_0===\"text\""}}]}],f:[{t:4,f:[{t:4,f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"display: flex; justify-content: space-between;",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:"title",f:"Convert multipart label text into a single expression",t:13,g:1},{n:["click"],t:70,f:{r:["@context","@this",".str"],s:"[(_0).set(\".str\",_1.getPartStrings(_2))]"}}],f:["Convert to Text"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Add another part to this multipart label text",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).push(\".str\",\"\")]"}}],f:["+"]}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"label-part",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico spacer",g:1},{n:["click"],t:70,f:{r:["@context","@index"],s:"[(_0).splice(\"../\",_1,1)]"}},{n:"title",f:"Remove part",t:13,g:1}],f:[{t:8,r:"times"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico up-arrow",g:1},{n:"disabled",f:[{t:2,x:{r:["@index"],s:"_0===0"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.moveUp((_1))]"}},{n:"title",f:"Move up",t:13,g:1}],f:[{t:8,r:"arrow"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico spacer down-arrow",g:1},{n:"disabled",f:[{t:2,x:{r:["@index","@last"],s:"_0===_1"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.moveDown((_1))]"}},{n:"title",f:"Move down",t:13,g:1}],f:[{t:8,r:"arrow"}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context","."],s:"[(_0).set(\".\",{text:_1})]"}},{n:"title",f:"Format part",t:13,g:1}],f:["F"]}," ",{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:"."}],t:13},{n:"primary",f:[{t:2,x:{r:["@index"],s:"_0===0"}}],t:13}]}],n:50,x:{r:["."],s:"typeof _0===\"string\""}},{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico spacer",g:1},{n:["click"],t:70,f:{r:["@context",".text"],s:"[(_0).set(\".\",_1)]"}},{n:"title",f:"Convert to a plain text part with no formatting",t:13,g:1}],f:["T"]}," ",{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".id"}],t:13},{n:"placeholder",f:"Tracking ID",t:13},{n:"title",f:"Track this value by assigning it a unique ID",t:13}]}," ",{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".text"}],t:13},{n:"primary",f:[{t:2,x:{r:["@index"],s:"_0===0"}}],t:13}]}," ",{t:7,e:"input",m:[{n:"title",f:"Font Family",t:13},{n:"placeholder",f:"Font Family",t:13},{n:"value",f:[{t:2,r:".font.family"}],t:13}]}," ",{t:7,e:"input",m:[{n:"title",f:"Color",t:13},{n:"placeholder",f:"Color",t:13},{n:"value",f:[{t:2,r:".font.color"}],t:13}]}," ",{t:7,e:"input",m:[{n:"title",f:"Size",t:13},{n:"placeholder",f:"Size (1)",t:13},{n:"value",f:[{t:2,r:".font.size"}],t:13},{n:"type",f:"number",t:13}]}," ",{t:7,e:"input",m:[{n:"title",f:"Line Height",t:13},{n:"placeholder",f:["Line Height (",{t:2,x:{r:[".font.size"],s:"_0==null?1:_0"}},")"],t:13},{n:"value",f:[{t:2,r:".font.line"}],t:13},{n:"type",f:"number",t:13}]}," ",{t:7,e:"select",m:[{n:"title",f:"Font Weight",t:13},{n:"value",f:[{t:2,r:".font.weight"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["Font Weight"]}," ",{t:7,e:"option",m:[{n:"value",f:"400",t:13}],f:["light"]}," ",{t:7,e:"option",m:[{n:"value",f:"500",t:13}],f:["normal"]}," ",{t:7,e:"option",m:[{n:"value",f:"600",t:13}],f:["bold"]}," ",{t:7,e:"option",m:[{n:"value",f:"700",t:13}],f:["bolder"]}]}," ",{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".font.pre"}],t:13}]}," Significant whitespace?"]}," ",{t:7,e:"input",m:[{n:"title",f:"Background Color",t:13},{n:"placeholder",f:"Background",t:13},{n:"value",f:[{t:2,r:".bg"}],t:13}]}," ",{t:7,e:"input",m:[{n:"title",f:"Border Radius",t:13},{n:"placeholder",f:"Radius",t:13},{n:"value",f:[{t:2,r:".radius"}],t:13}]}],n:51,l:1}]}],n:52,r:".str"}]}]}],n:50,x:{r:[".str"],s:"Array.isArray(_0)"}},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".str"}],t:13},{n:"template",f:[{t:2,x:{r:[".html",".template"],s:"_0||_1"}}],t:13},{n:["run"],t:70,f:{r:["~/temp.expr.tab","@this"],s:"[_0===\"result\"?_1.set(\"temp.expr.tab\",\"text\"):_1.eval()]"}},{n:"primary",f:0,t:13}]}]}]}],n:51,l:1}],n:50,r:".label"},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".str"}],t:13},{n:"template",f:[{t:2,x:{r:[".html",".template"],s:"_0||_1"}}],t:13},{n:["run"],t:70,f:{r:["~/temp.expr.tab","@this"],s:"[_0===\"result\"?_1.set(\"temp.expr.tab\",\"text\"):_1.eval()]"}},{n:"primary",f:0,t:13}]}]}]}],n:51,l:1}],n:54,r:"~/temp.expr"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab html",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"html\""}}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"editor-buttons",g:1}],f:[{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.command(\"bold\")]"}},{n:"title",f:"Bold",t:13,g:1}],f:[{t:7,e:"strong",f:["B"]}]}," ",{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.command(\"italic\")]"}},{n:"title",f:"Italic",t:13,g:1}],f:[{t:7,e:"em",f:["I"]}]}," ",{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.command(\"underline\")]"}},{n:"title",f:"Underline",t:13,g:1}],f:[{t:7,e:"span",m:[{t:13,n:"style",f:"text-decoration: underline;",g:1}],f:["U"]}]}," ",{t:7,e:"button",m:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.command(\"strikeThrough\")]"}},{n:"title",f:"Strike Through",t:13,g:1}],f:[{t:7,e:"span",m:[{t:13,n:"style",f:"text-decoration: line-through;",g:1}],f:["S"]}]}," ",{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"~/temp.fontSize"}],t:13},{n:["change"],t:70,f:{r:["@this"],s:"[_0.setHTMLFontSize()]"}},{n:"title",f:"Change Font Size",t:13}],f:[{t:7,e:"option",m:[{n:"value",f:"",t:13}],f:["(font size)"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"1"}}],t:13}],f:["smallest"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"2"}}],t:13}],f:["smaller"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"3"}}],t:13}],f:["small"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"4"}}],t:13}],f:["regular"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"5"}}],t:13}],f:["large"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"6"}}],t:13}],f:["larger"]}," ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"7"}}],t:13}],f:["largest"]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"html-editor",g:1},{n:"contenteditable",f:"true",t:13},{n:"value",f:[{t:2,r:"~/temp.expr.htmlstr"}],t:13},{n:"id",f:"expr-html",t:13,g:1}]}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab result",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"result\""}}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"editor-buttons",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"toggles",g:1}],f:[{t:19,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["t"],s:"!_0||_0===\"plain\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.resulttype\",\"plain\")]"}}],n:50,x:{r:["t"],s:"_0&&_0!==\"plain\""}},{n:"title",f:"Show result as a plain string. Double click to copy the text to the clipboard.",t:13,g:1},{n:["dblclick"],t:70,f:{r:["@this","~/temp.expr.result"],s:"[_0.copyToClipboard(_1)]"}}],f:["Plain"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["t"],s:"_0===\"json\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.resulttype\",\"json\")]"}}],n:50,x:{r:["t"],s:"_0!==\"json\""}},{n:"title",f:"Show result as JSON",t:13,g:1}],f:["JSON"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["t"],s:"_0===\"raport\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.resulttype\",\"raport\")]"}}],n:50,x:{r:["t"],s:"_0!==\"raport\""}},{n:"title",f:"Show result as a Raport expression",t:13,g:1}],f:["Raport"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"toggle",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["t"],s:"_0===\"html\""}}]},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.resulttype\",\"html\")]"}}],n:50,x:{r:["t"],s:"_0!==\"html\""}},{n:"title",f:"Show result as HTML",t:13,g:1}],f:["HTML"]}],n:54,z:[{n:"t",x:{r:"~/temp.expr.resulttype"}}]}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"margin-left: 2em;",g:1}],f:[{t:4,f:[{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",t:13,f:[{t:2,r:"~/temp.expr.jsonsquash"}]},{n:"title",f:"Enable to display JSON with no additional whitespace",t:13}]}," Compact?"]}],n:50,x:{r:["~/temp.expr.resulttype"],s:"_0===\"json\""}}]}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:4,f:[{t:7,e:"span",m:[{n:"style",f:["color: ",{t:2,r:"@style.code.c12"},";"],t:13}],f:["undefined"]}],n:50,x:{r:["~/temp.expr.result"],s:"_0===undefined"}},{t:4,f:[{t:4,f:[{t:3,r:"~/temp.expr.result"}],n:50,x:{r:["~/temp.expr.resulttype"],s:"_0===\"html\""}},{t:4,f:[{t:7,e:"code",f:[{t:7,e:"pre",f:[{t:2,x:{r:["~/temp.expr.result","~/temp.expr.jsonsquash"],s:"JSON.stringify(_0,null,_1?undefined:\"  \")"}}]}]}," "],n:50,x:{r:["~/temp.expr.resulttype"],s:"_0===\"json\""},l:1},{t:4,f:[" ",{t:7,e:"code",f:[{t:7,e:"pre",f:[{t:2,x:{r:["@this","~/temp.expr.result"],s:"_0.unparse(_1)"}}]}]}," "],n:50,x:{r:["~/temp.expr.resulttype"],s:"_0===\"raport\""},l:1},{t:4,f:[" ",{t:7,e:"code",f:[{t:7,e:"pre",f:[{t:2,r:"~/temp.expr.result"}]}]}],n:51,l:1}],n:51,l:1}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab parsed",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"parsed\""}}]}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"flex-grow: 1;",g:1},{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"code",f:[{t:7,e:"pre",m:[{t:13,n:"style",f:"margin: 1em;",g:1}],f:[{t:4,f:[{t:2,r:"~/temp.expr.errormsg"}],n:50,r:"~/temp.expr.errormsg"},{t:4,f:[{t:4,f:[{t:2,x:{r:["@this","~/temp.expr.ast"],s:"_0.unparse(_1)"}}],n:50,x:{r:["~/temp.expr.parsedtype"],s:"_0===\"raport\""}},{t:4,f:[{t:2,x:{r:["~/temp.expr.ast","~/temp.expr.jsonsquash"],s:"JSON.stringify(_0,null,_1?\"\":\"  \")"}}],n:51,l:1}],n:51,l:1}]}]}]}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"context",g:1},{n:"style-display",f:[{t:2,x:{r:["~/temp.expr.tab"],s:"_0===\"ast\"||_0===\"text\"||_0===\"html\"?\"\":\"none\""}}],t:13}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"header",g:1},{n:"title",f:"The approximate data that should be available in this expression's context",t:13,g:1}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"margin-right: 0.5em;",g:1}],f:["Context"]},{t:7,e:"div",f:[{t:7,e:"input",m:[{n:"placeholder",f:"Filter...",t:13},{n:"value",f:[{t:2,r:"~/ctxsearch"}],t:13},{t:73,v:"l",f:"500"},{n:"style",f:"width: 100%;",t:13}]}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"panel scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:4,f:[{t:8,r:"expr-context",c:{r:"~/temp.expr.ctx"}}],n:50,r:"~/temp.expr.ctx"}]}]}]}," "]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab properties",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"param\""}}]}],f:[{t:4,f:[{t:7,e:"label",m:[{n:"title",f:"The name used to reference this parameter e.g. !name",t:13,g:1}],f:[{t:7,e:"span",f:["Name"]},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".name"}],t:13}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",f:["Type"]},{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".type"}],t:13}],f:[{t:8,r:"types"}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",f:["Refine"]},{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".refine"}],t:13}],f:[" ",{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["(none)"]}," ",{t:7,e:"option",m:[{n:"value",f:"text",t:13}],f:["Multiline Text"]}," ",{t:7,e:"option",m:[{n:"value",f:"code",t:13}],f:["Expression"]}]}]}],n:50,x:{r:[".type"],s:"_0===\"string\""}}," ",{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".required"}],t:13}]}," Require?"]}," ",{t:7,e:"label",m:[{n:"title",f:"An alternative to the name to show in the parameter fill interface",t:13,g:1}],f:[{t:7,e:"span",f:["Label"]},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".label"}],t:13}]}]}," ",{t:4,f:[{t:7,e:"label",m:[{n:"title",f:"Add an Initialization expression to provide a default for the parameter",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@context"],s:"[(_0).set(\".init\",\"\")]"}}]}," Initialization expression?"]}],n:50,x:{r:[".init"],s:"_0===undefined"}},{t:4,f:[{t:7,e:"label",m:[{n:"title",f:"Add an Initialization expression to provide a default for the parameter",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{t:73,v:"t",f:"false"},{n:"checked",f:0,t:13},{n:["change"],t:70,f:{r:["@context"],s:"[(_0).set(\".init\",undefined)]"}}]}," Initialization expression?"]}," ",{t:7,e:"div",m:[{n:"style",f:["height: 5em; border: 1px solid ",{t:2,r:"@style.border"},"; overflow: auto; margin: 0 0.5em;"],t:13}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".init"}],t:13},{n:"tabout",f:0,t:13}]}]}],n:51,l:1}," ",{t:7,e:"label",m:[{n:"title",f:"Set up options to render the parameter as a select",t:13,g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{t:73,v:"t",f:"false"},{n:"checked",f:[{t:2,x:{r:[".options"],s:"Array.isArray(_0)"}}],t:13},{n:["change"],t:70,f:{r:["@context",".options"],s:"[(_0).set(\".options\",Array.isArray(_1)?undefined:[])]"}}]}," Options?"]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"height: 100%; width: 30rem;",g:1},{t:13,n:"class",f:"options",g:1}],f:[{t:7,e:"h3",f:["Options"]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"option-entry",g:1}],f:[{t:19,f:[{t:7,e:"label",f:[{t:7,e:"span",f:["Label"]},{t:7,e:"br"},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"ctx.label"}],t:13}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",f:["Value"]},{t:7,e:"br"},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"ctx.value"}],t:13}]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"disabled",f:[{t:2,x:{r:["ctx.value"],s:"!_0"}}],t:13},{n:["click"],t:70,f:{r:["ctx.label","ctx.value","@context"],s:"[(_2).push(\".options\",!_0?_1:{label:_0,value:_1}),(_2).set({\"ctx.label\":\"\",\"ctx.value\":\"\"})]"}}],f:["+"]}],n:54,z:[{n:"ctx",x:{r:"@local"}}]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:4,f:[{t:7,e:"div",f:[{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"."}],t:13}]}],n:50,x:{r:["."],s:"typeof _0===\"string\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".label"}],t:13}]}," ",{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".value"}],t:13}]}],n:51,l:1}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context","@index"],s:"[(_0).splice(\"../\",_1,1)]"}}],f:[{t:8,r:"times"}]}]}],n:52,r:".options"}]}]}],n:50,r:".options"}]}],n:50,x:{r:[".options"],s:"Array.isArray(_0)"}}],n:54,r:"~/param"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab properties",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"params\""}}]}],f:[{t:8,r:"bottom-parameters"}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"tab properties",g:1},{n:"class-active-tab",t:13,f:[{t:2,x:{r:["~/temp.bottom.tab"],s:"_0===\"source\""}}]}],f:[{t:4,f:[{t:7,e:"label",m:[{n:"title",f:"Expose this source to the report context with this name. If none is provided, this source will be named based on its upstream source.",t:13,g:1}],f:[{t:7,e:"span",f:["Name"]},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".name"}],t:13}]}]}," ",{t:4,f:[{t:7,e:"label",m:[{n:"title",f:"The upstream source that this source should be based on.",t:13,g:1}],f:[{t:7,e:"span",f:["Source"]},{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".source"}],t:13}],f:[{t:4,f:[{t:7,e:"option",f:[{t:2,r:".name"}]}],n:52,r:"~/report.sources"}]}]}],n:50,x:{r:["~/temp.bottom.source"],s:"~_0.indexOf(\"widget\")"}},{t:4,f:[{t:7,e:"label",m:[{n:"title",f:"The upstream source that this source should be based on.",t:13,g:1}],f:[{t:7,e:"span",f:["Source"]},{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".source"}],t:13}],f:[{t:4,f:[{t:7,e:"option",f:[{t:2,r:".name"}]}],n:52,r:"~/sources"}]}]}],n:51,l:1}," ",{t:7,e:"label",m:[{n:"title",f:"An expression providing the base data for this source. This will override the upstream source, which is available in this expression as @source.",t:13,g:1}],f:[{t:7,e:"span",f:["Base ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","~/temp.bottom.source"],s:"[_0.editExpr(_1+\".base\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"div",m:[{n:"style",f:["height: 5em; border: 1px solid ",{t:2,r:"@style.border"},"; overflow: auto; margin: 0;"],t:13}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".base"}],t:13},{n:"tabout",f:0,t:13}]}]}]}," ",{t:7,e:"label",m:[{n:"title",f:"A filter expression to apply to the source before it is used.",t:13,g:1}],f:[{t:7,e:"span",f:["Filter ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","~/temp.bottom.source"],s:"[_0.editExpr(_1+\".filter\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"div",m:[{n:"style",f:["height: 5em; border: 1px solid ",{t:2,r:"@style.border"},"; overflow: auto; margin: 0;"],t:13}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".filter"}],t:13},{n:"tabout",f:0,t:13}]}]}]}," ",{t:7,e:"label",m:[{n:"title",f:"A sort expression to apply to the source before it is used. This should be an array of applications or config objects with by keys having application values.",t:13,g:1}],f:[{t:7,e:"span",f:["Sort ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","~/temp.bottom.source"],s:"[_0.editExpr(_1+\".sort\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"div",m:[{n:"style",f:["height: 5em; border: 1px solid ",{t:2,r:"@style.border"},"; overflow: auto; margin: 0;"],t:13}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:".sort"}],t:13},{n:"tabout",f:0,t:13}]}]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"height: 100%; width: 20rem;",g:1},{t:13,n:"class",f:"options",g:1}],f:[{t:7,e:"h3",f:[{t:7,e:"button",m:[{t:13,n:"style",f:"float: right;",g:1},{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Add group expression",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).push(\".group\",\"\")]"}}],f:["+"]}," ",{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".group"}],t:13},{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@context"],s:"[(_0).set(\".group\",undefined)]"}}]}," Groups"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"group-edit",g:1}],f:[{t:7,e:"span",f:[{t:2,x:{r:["@index"],s:"_0+1"}}]}," ",{t:7,e:"div",m:[{n:"style",f:["height: 5em; border: 1px solid ",{t:2,r:"@style.border"},"; overflow: auto; margin: 0.5em; flex-grow: 1;"],t:13}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:"."}],t:13},{n:"tabout",f:0,t:13}]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit group expression",t:13,g:1},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.editExpr(\"~/\"+_1)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Remove group expression",t:13,g:1},{n:["click"],t:70,f:{r:["@context","@index"],s:"[(_0).splice(\"../\",_1,1)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"times"}]}]}],n:52,r:".group"}]}]}]}],n:50,x:{r:[".group"],s:"Array.isArray(_0)"}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"input",m:[{n:"title",f:"Group the rows in this source by one or more expression? This should be coordinated with the sort expression, as groups are produced by sequentially processing the source data.",t:13},{n:"type",f:"checkbox",t:13},{n:["change"],t:70,f:{r:["@context"],s:"[(_0).set(\".group\",[\"\"])]"}}]}," Group?"]}],n:51,l:1}],n:54,r:"~/source"}]}]}]}," ",{t:7,e:"datalist",m:[{n:"id",f:"operators",t:13,g:1}],f:[{t:4,f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,r:"./0"}],t:13}]}],n:52,r:"~/operators"}]}],"expr-context":[{t:4,f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"context-entry",g:1},{n:"class-entry-local",t:13,f:[{t:2,r:".meta.local"}]},{n:"class-expanded",t:13,f:[{t:2,rx:{r:"~/exprExpand",m:[{t:30,n:"@keypath"}]}}]}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"entry-details",g:1}],f:[{t:7,e:"div",f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"expand",g:1},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.exprToggle(_1)]"}}],f:[{t:2,x:{r:["@keypath","~/exprExpand"],s:"_1[_0]?\"-\":\"+\""}}]}],n:50,r:".fields"}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"entry-name",g:1},{n:["click"],t:70,f:{r:["@this","@keypath"],s:"[_0.insertRef(_1)]"}}],f:[{t:2,r:".name"}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"entry-type",g:1}],f:[{t:2,r:".type"}]}]}," ",{t:4,f:[{t:8,r:"expr-context"}],n:50,r:".fields"}]}],n:50,x:{r:[".fields",".name","~/ctxsearch"],s:"!_2||_0||~_1.indexOf(_2)"}}],n:52,r:".fields"}],"ast-dim-actions":[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-actions",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["../","@index","@context"],s:"[Array.isArray(_0)?(_2).splice(\"../\",_1,1):(_2).set(\".\",undefined)]"}}],f:[{t:8,r:"times"}]}]}],"ast-actions":[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-actions",g:1}],f:[{t:4,f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".source\",{r:\"\"})]"}}],f:["+ Source"]}],n:51,r:".source"}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".apply\",{r:\"\"})]"}}],f:["+ Application"]}],n:51,r:".apply"}],n:50,x:{r:[".op","~/operators"],s:"_1[_0]&&_1[_0].type===\"aggregate\""}}," ",{t:7,e:"select",m:[{t:73,v:"t",f:"false"},{n:["change"],t:70,f:{r:["@this","@keypath","@node.value"],s:"[_0.retypeASTNode(_1,_2)]"}},{n:"value",f:[{t:2,x:{r:[".v","."],s:"_1&&\"op\" in _1?\"operator\":_1&&\"v\" in _1?(typeof _0===\"string\"?\"string\":typeof _0===\"number\"?\"number\":\"object\"):_1&&\"r\" in _1?\"reference\":\"undefined\""}}],t:13}],f:[{t:7,e:"option",f:["operator"]}," ",{t:7,e:"option",f:["string"]}," ",{t:7,e:"option",f:["number"]}," ",{t:7,e:"option",f:["reference"]}," ",{t:7,e:"option",f:["undefined"]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["../","@index","@context"],s:"[Array.isArray(_0)?(_2).splice(\"../\",_1,1):(_2).set(\".\",undefined)]"}}],f:[{t:8,r:"times"}]}]}],"ast-node":[{t:7,e:"div",m:[{n:["click"],t:70,f:{r:["~/temp.expr.partpath","@this","@keypath"],s:"[_0!==_2&&[_1.link(_2,\"temp.expr.part\"),_1.set(\"temp.expr.partpath\",_2)],false]"}},{n:"class",f:["ast-node ast-",{t:2,x:{r:["."],s:"(_0&&(\"op\" in _0?\"op\":\"v\" in _0?\"value\":\"r\" in _0?\"ref\":\"wat\"))||\"wat\""}}],t:13},{n:"class-ast-active-node",t:13,f:[{t:2,x:{r:["~/temp.expr.partpath","@keypath"],s:"_0===_1"}}]}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-content",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-op-name",g:1}],f:[{t:7,e:"div",f:[{t:2,r:"prefix"},"(",{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".op"}],t:13},{n:"list",f:"operators",t:13}]}]},{t:8,r:"ast-actions"}]}," ",{t:4,f:[{t:8,r:"ast-node"}],n:52,r:".args"}," ",{t:7,e:"div",f:[") ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).push(\".args\",{v:\"\"})]"}}],f:["+"]}]}],n:50,x:{r:["."],s:"_0&&\"op\" in _0"}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-content-value",g:1}],f:[{t:7,e:"div",f:[{t:2,r:"prefix"}," ",{t:4,f:[{t:7,e:"textarea",m:[{n:"rows",f:"1",t:13},{n:"cols",f:"30",t:13}],f:[{t:2,r:".v"}]}],n:50,x:{r:[".v"],s:"typeof _0===\"string\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".v"}],t:13},{n:"type",f:"number",t:13}]}],n:50,x:{r:[".v"],s:"typeof _0===\"number\""},l:1}]}," ",{t:8,r:"ast-actions"}]}," "],n:50,x:{r:["."],s:"_0&&\"v\" in _0"},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"ast-content-ref",g:1}],f:[{t:7,e:"div",f:[{t:2,r:"prefix"},{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".r"}],t:13}]}]}," ",{t:8,r:"ast-actions"}]}],n:50,x:{r:["."],s:"_0&&\"r\" in _0"},l:1}]}],n:50,x:{r:["~/temp.expr.partpath","@keypath"],s:"_0===_1"}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-content",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-op-name",g:1}],f:[{t:7,e:"div",f:[{t:2,r:"prefix"},"(",{t:2,r:".op"}]},{t:8,r:"ast-dim-actions"}]}," ",{t:4,f:[{t:4,f:[{t:8,r:"ast-node",c:{r:".source"},z:[{n:"prefix",x:{x:{r:[],s:"\"+ \""}}}]}],n:50,r:".source"}," ",{t:4,f:[{t:8,r:"ast-node",c:{r:".apply"},z:[{n:"prefix",x:{x:{r:[],s:"\"=> \""}}}]}],n:50,r:".apply"}],n:50,x:{r:[".op","~/operators"],s:"_1[_0]&&_1[_0].type===\"aggregate\""}}," ",{t:4,f:[{t:8,r:"ast-node"}],n:52,r:".args"}," )"],n:50,x:{r:["."],s:"_0&&\"op\" in _0"}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"ast-content-value",g:1}],f:[{t:7,e:"div",m:[{n:"class-ast-string",t:13,f:[{t:2,x:{r:[".v"],s:"typeof _0===\"string\""}}]},{n:"class-ast-number",t:13,f:[{t:2,x:{r:[".v"],s:"typeof _0===\"number\""}}]}],f:[{t:2,r:"prefix"},{t:2,r:".v"}]},{t:8,r:"ast-dim-actions"}]}," "],n:50,x:{r:["."],s:"_0&&\"v\" in _0"},l:1},{t:4,f:[" ",{t:7,e:"div",m:[{t:13,n:"class",f:"ast-content-ref",g:1}],f:[{t:7,e:"div",f:[{t:2,r:"prefix"},{t:2,r:".r"}," (ref)"]},{t:8,r:"ast-dim-actions"}]}],n:50,x:{r:["."],s:"_0&&\"r\" in _0"},l:1}]}],n:51,l:1}]}],"bottom-parameters":[{t:7,e:"div",m:[{t:13,n:"class",f:"parameters",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"display: flex; justify-content: space-around;",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@this","params"],s:"[_0.set(\"report.defaultParams\",_1)]"}},{n:"title",f:"Save these values as the report defaults",t:13,g:1}],f:["Save as Defaults"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico text",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.initParams()]"}},{n:"title",f:"Re-initialize all parameters",t:13,g:1}],f:["Re-init Params"]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"param-editor",g:1}],f:[{t:4,f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"param",g:1}],f:[{t:4,f:[{t:7,e:"label",m:[{t:13,n:"class",f:"check",g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}],t:13}]}," ",{t:2,x:{r:[".label",".name"],s:"_0||_1"}},"?"]}],n:50,x:{r:[".type"],s:"_0===\"boolean\""}},{t:4,f:[{t:7,e:"label",m:[{t:13,n:"class",f:"pick",g:1}],f:[{t:2,x:{r:[".label",".name"],s:"_0||_1"}},{t:7,e:"select",m:[{n:"value",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}],t:13}],f:[" ",{t:4,f:[{t:4,f:[{t:7,e:"option",f:[{t:2,r:"."}]}],n:50,x:{r:["."],s:"typeof _0===\"string\""}},{t:4,f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,r:".value"}],t:13}],f:[{t:2,r:".label"}]}],n:51,l:1}],n:52,r:".options"}]}]}," "],n:50,r:".options.length",l:1},{t:4,f:[" ",{t:4,f:[{t:7,e:"div",f:[{t:2,x:{r:[".label",".name"],s:"_0||_1"}}]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"height: 5em; border: 1px solid #ccc; overflow: auto;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}],t:13}]}]}],n:50,x:{r:[".refine"],s:"_0===\"code\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"div",f:[{t:2,x:{r:[".label",".name"],s:"_0||_1"}}]}," ",{t:7,e:"textarea",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}]}]}," "],n:50,x:{r:[".refine"],s:"_0===\"text\""},l:1},{t:4,f:[" ",{t:7,e:"label",m:[{t:13,n:"class",f:"string",g:1}],f:[{t:2,x:{r:[".label",".name"],s:"_0||_1"}}," ",{t:7,e:"input",m:[{n:"value",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}],t:13}]}]}],n:51,l:1}," "],n:50,x:{r:[".type"],s:"_0===\"string\""},l:1},{t:4,f:[" ",{t:7,e:"label",m:[{t:13,n:"class",f:"string",g:1}],f:[{t:2,x:{r:[".label",".name"],s:"_0||_1"}}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"height: 1em; border: 1px solid #ccc; padding: 0.25em; text-align: center;",g:1}],f:[{t:2,r:".type"}," Parameter"]}]}," "],n:50,x:{r:[".type"],s:"_0===\"object\"||_0===\"array\"||_0.slice(-2)===\"[]\""},l:1},{t:4,f:[" ",{t:7,e:"label",m:[{t:13,n:"class",f:"string",g:1}],f:[{t:2,x:{r:[".label",".name"],s:"_0||_1"}}," ",{t:4,f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}],t:13}]}],n:50,x:{r:[".type"],s:"_0===\"number\""}},{t:4,f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,rx:{r:"~/params",m:[{t:30,n:".name"}]}}],t:13}]}],n:51,l:1}]}],n:51,l:1}]}],n:50,r:".name"}],n:52,r:"~/report.parameters"}]}]}],left:[{t:7,e:"div",m:[{t:13,n:"class",f:"left-bar",g:1}],f:[{t:7,e:"button",m:[{n:"class",f:["large ico ",{t:2,x:{r:["~/show.props"],s:"_0?\"left\":\"right\""}},"-arrow"],t:13},{n:["click"],t:70,f:{r:["@this"],s:"[_0.toggle(\"show.props\")]"}},{n:"title",f:[{t:4,f:["Hide"],n:50,r:"~/show.props"},{t:4,f:["Show"],n:51,l:1}," the left pane"],t:13}],f:[{t:8,r:"arrow"}]}," ",{t:7,e:"button",m:[{n:"class",f:["large ico ",{t:2,x:{r:["~/show.hidetree"],s:"_0?\"off\":\"\""}}],t:13},{t:4,f:[{n:["click"],t:70,f:{r:["~/show.hidetree","~/show.hideprops","@this"],s:"[_2.toggle(\"show.hidetree\"),!_0&&_1?_2.set(\"show.hideprops\",false):\"\"]"}},{n:"title",f:[{t:4,f:["Show"],n:50,r:"~/show.hidetree"},{t:4,f:["Hide"],n:51,l:1}," widget tree"],t:13}],n:50,r:"~/show.props"},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.toggle(\"show.props\"),_0.set(\"show.hidetree\",false),_0.set(\"show.hideprops\",true)]"}},{n:"title",f:"Show the left pane with only the widget tree",t:13}],n:51,l:1}],f:[{t:8,r:"tree"}]}," ",{t:7,e:"button",m:[{n:"class",f:["large ico ",{t:2,x:{r:["~/show.hideprops"],s:"_0?\"off\":\"\""}}],t:13},{t:4,f:[{n:["click"],t:70,f:{r:["~/show.hideprops","~/show.hidetree","@this"],s:"[_2.toggle(\"show.hideprops\"),!_0&&_1?_2.set(\"show.hidetree\",false):\"\"]"}},{n:"title",f:[{t:4,f:["Show"],n:50,r:"~/show.hideprops"},{t:4,f:["Hide"],n:51,l:1}," widget properties"],t:13}],n:50,r:"~/show.props"},{t:4,f:[{n:["click"],t:70,f:{r:["@this"],s:"[_0.toggle(\"show.props\"),_0.set(\"show.hidetree\",true),_0.set(\"show.hideprops\",false)]"}},{n:"title",f:"Show the left pane with only widget properties",t:13}],n:51,l:1}],f:[{t:8,r:"cog"}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"left properties left-pop",g:1},{n:"class-popped",t:13,f:[{t:2,r:"~/show.props"}]}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"height: 3rem; margin-top: 0;",g:1},{t:13,n:"class",f:"header",g:1}],f:[{t:7,e:"h3",f:[{t:4,f:["Moving..."],n:50,r:"~/reparent"},{t:4,f:["Widgets"],n:51,l:1}]}," ",{t:4,f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"~/add"}],t:13},{n:["change"],t:70,f:{r:["@this","@node.value"],s:"[_0.addWidget(_1)]"}}],f:[{t:7,e:"option",f:["container"]}," ",{t:7,e:"option",f:["label"]}," ",{t:7,e:"option",f:["repeater"]}," ",{t:7,e:"option",f:["html"]}," ",{t:7,e:"option",f:["image"]}," ",{t:7,e:"option",f:["measured"]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"add",g:1},{n:"title",f:["Add ",{t:2,r:"~/add"}," to ",{t:2,r:"~/temp.widget"}],t:13},{n:["click"],t:70,f:{r:["@this","~/add"],s:"[_0.addWidget(_1)]"}}],f:["+"]}],n:50,x:{r:["~/report.type","~/widget.type","~/temp.widget"],s:"_0!==\"delimited\"&&(_1===\"container\"||_2===\"report\")"}}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"copy\",undefined)]"}},{n:"title",f:"Cancel copy [Esc]",t:13,g:1}],f:[{t:8,r:"copy",z:[{n:"cancel",x:{x:{r:[],s:"true"}}}]}]}],n:50,r:"~/copy"}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.set(\"reparent\",undefined)]"}},{n:"title",f:"Cancel move [Esc]",t:13,g:1}],f:[{t:8,r:"reparent",z:[{n:"cancel",x:{x:{r:[],s:"true"}}}]}]}],n:50,r:"~/reparent"}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.treeScrollToActive()]"}},{n:"title",f:"Scroll active widget into view",t:13,g:1}],f:[{t:8,r:"scrollto"}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper widget-tree",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"tree",g:1},{n:"scrolled",t:71},{n:["mouseout"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.hover\",\"\"),false]"}}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"node",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.widget"],s:"_0===\"report\""}}]},{n:"class-hover",t:13,f:[{t:2,x:{r:["~/temp.hover"],s:"_0===\"report\""}}]},{n:["click"],t:70,f:{r:["~/reparent","~/copy","@context","@this"],s:"[_0?_3.reparent((_2)):_1?_3.paste((_2)):_3.selectWidget(\"report\")]"}},{n:"title",f:[{t:4,f:["Click to move the widget to this container -"],n:50,r:"~/reparent"},{t:4,f:["Click to add a copy of the widget to this container -"],n:50,r:"~/copy",l:1}," Path: ",{t:2,r:"@keypath"}],t:13}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"line",g:1},{n:["mouseover"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.hover\",\"report\"),false]"}}],f:["Report ",{t:7,e:"span",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:4,f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add page header",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".header\",{type:\"container\"}),false]"}}],f:["+H"]}],n:50,x:{r:[".header"],s:"!_0"}}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add page footer",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".footer\",{type:\"container\"}),false]"}}],f:["+F"]}],n:50,x:{r:[".footer"],s:"!_0"}}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add page watermark",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".watermark\",{type:\"container\"}),false]"}}],f:["+W"]}],n:50,x:{r:[".watermark"],s:"!_0"}}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add page overlay",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".overlay\",{type:\"container\"}),false]"}}],f:["+O"]}],n:50,x:{r:[".overlay"],s:"!_0"}}],n:50,x:{r:[".type"],s:"_0!=\"delimited\""}},{t:4,f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add headers",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.addHeader(),false]"}}],f:["+H"]}],n:50,x:{r:[".headers"],s:"!_0"}}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add field",t:13,g:1},{n:["click"],t:70,f:{r:[".headers","@this"],s:"[_1.push(\"report.fields\",\"\"),_0&&_1.push(\"report.headers\",\"\"),false]"}}],f:["+F"]}],n:51,l:1}]}]}," ",{t:4,f:[{t:8,r:"delimited-fields"}],n:50,x:{r:["report.type"],s:"_0===\"delimited\""}},{t:4,f:[{t:8,r:"widget-tree"}],n:51,l:1}]}],n:54,r:"report"}]}]}],n:50,x:{r:["~/show.hidetree"],s:"!_0"}}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"header",g:1}],f:[{t:7,e:"h3",f:[{t:2,x:{r:["~/temp.name.0"],s:"_0.toUpperCase()"}},{t:2,x:{r:["~/temp.name"],s:"_0.substr(1)"}}," Properties"]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"growy",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"sheet",g:1}],f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The name of this report, which is used for naming files. This is a template, so it must use mustache interpolators for variables.",t:13,g:1}],f:["Name ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\"report.name\",{template:true}),false]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:"report.name"}],t:13},{n:"tabout",f:0,t:13},{n:"template",f:0,t:13}]}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"Paged reports are rendered in consectutive, fixed-size pages. Flowed reports are rendered in a continuous container, which does not allow height fit on immediate child widgets or negative offsets. Delimited reports render delimited text only e.g. CSV.",t:13,g:1}],f:["Type"]},{t:7,e:"span",f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"report.type"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:"page",t:13}],f:["Paged"]}," ",{t:7,e:"option",m:[{n:"value",f:"flow",t:13}],f:["Continuous"]}," ",{t:7,e:"option",m:[{n:"value",f:"delimited",t:13}],f:["Delimited"]}]}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"When enabled, widgets will have as few inline styles as possible with common style sets combined into classes. This can significantly reduce the resuling HTML from a report run.",t:13,g:1}],f:["Combine styles into classes?"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:"report.classifyStyles"}],t:13}]}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The size of the page for this report.",t:13,g:1}],f:["Paper size"]},{t:7,e:"span",f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"report.size"}],t:13}],f:[{t:4,f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,r:"."}],t:13}],f:[{t:2,r:"@key"}]}],n:52,r:"~/pageSizes"}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The orientation of the page for this report.",t:13,g:1}],f:["Orientation"]},{t:7,e:"span",f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"report.orientation"}],t:13}],f:[{t:7,e:"option",f:["landscape"]}," ",{t:7,e:"option",f:["portrait"]}]}]}]}," ",{t:8,r:"margin-prop",c:{r:"report"}}],n:50,x:{r:["report.type"],s:"_0===\"page\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"An optional width in rem for this report.",t:13,g:1}],f:["Width"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"report.width"}],t:13}]}]}]}," ",{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"An optional width for this report if not specified directly in rem.",t:13,g:1}],f:["Paper size"]},{t:7,e:"span",f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"report.size"}],t:13}],f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,x:{r:[],s:"undefined"}}],t:13}],f:["(None)"]},{t:4,f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,r:"."}],t:13}],f:[{t:2,r:"@key"}]}],n:52,r:"~/pageSizes"}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The orientation of the paper specifying the width for this report.",t:13,g:1}],f:["Orientation"]},{t:7,e:"span",f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"report.orientation"}],t:13}],f:[{t:7,e:"option",f:["landscape"]}," ",{t:7,e:"option",f:["portrait"]}]}]}]}],n:50,x:{r:["report.width"],s:"!_0"}}],n:51,l:1}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The base text size in rem for all widgets in this report.",t:13,g:1}],f:["Text Size"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/report.font.size"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The base line hieght in rem for all widgets in this report.",t:13,g:1}],f:["Line Height"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"type",f:"number",t:13},{n:"value",f:[{t:2,r:"~/report.font.line"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The base font family for all widgets in this report.",t:13,g:1}],f:["Font Family"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"~/report.font.family"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The base text color for all widgets in this report.",t:13,g:1}],f:["Text Color"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"~/report.font.color"}],t:13}]}]}]}],n:50,x:{r:["report.type"],s:"_0!==\"delimited\""}},{t:4,f:[{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The primary source used as the basis for the report.",t:13,g:1}],f:["Primary Source"]},{t:7,e:"span",f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"report.source"}],t:13}],f:[{t:4,f:[{t:7,e:"option",m:[{n:"value",f:[{t:2,r:".value"}],t:13}],f:[{t:2,r:".label"}]}],n:52,r:"~/sourceNames"}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The string to render between records, defaulting to '\\n'.",t:13,g:1}],f:["Record Delimiter"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"temp.record"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The string to render between fields, defaulting to ','.",t:13,g:1}],f:["Field Delimiter"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"temp.field"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"The quote character to render around field values, defaulting to none.",t:13,g:1}],f:["Quote"]},{t:7,e:"span",f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:"temp.quote"}],t:13}]}]}]}," ",{t:7,e:"label",f:[{t:7,e:"span",m:[{n:"title",f:"If supplied, this expression is evaluated and the result replaces the value in the context in which the fields in the record are evaluated. If the initial value should be used while side-effecting expressions are evaluated, the last expression in the context source should be, _, @value, or a false-y value .",t:13,g:1}],f:["Row Context ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Edit in Expression Editor",t:13,g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.editExpr(\"report.rowContext\")]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}]},{t:7,e:"span",f:[" ",{t:7,e:"div",m:[{t:13,n:"style",f:"padding: 0; overflow: auto; max-height: 5em;",g:1}],f:[{t:7,e:"Editor",m:[{n:"src",f:[{t:2,r:"report.rowContext"}],t:13},{n:"tabout",f:0,t:13}]}]}]}]}],n:51,l:1}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"header",g:1}],f:[{t:7,e:"h3",m:[{n:"title",f:"Define parameters that can be collected, passed into the report, and referenced as !name",t:13,g:1}],f:["Parameters"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"add",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.push(\"report.parameters\",{})]"}},{n:"title",f:"Add parameter",t:13,g:1}],f:["+"]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"parameter head",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"param-name",g:1}],f:["Name"]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"param-type",g:1}],f:["Type"]}," ",{t:7,e:"div",m:[{t:13,n:"style",f:"width: 30%;",g:1},{t:13,n:"class",f:"param-require",g:1}],f:["Require"]}]}],n:50,r:"report.parameters"}," ",{t:7,e:"div",f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"parameter",g:1},{n:["focusin"],t:70,f:{r:["@this","@context"],s:"[_0.editParam((_1))]"}}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"param-name",g:1}],f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".name"}],t:13}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"param-type",g:1}],f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".type"}],t:13}],f:[{t:8,r:"types"}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"param-require",g:1}],f:[{t:7,e:"input",m:[{n:"type",f:"checkbox",t:13},{n:"checked",f:[{t:2,r:".required"}],t:13}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"param-btn",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","@keypath","@context","@index"],s:"[_0.checkLink(\"param\",_1),(_2).splice(\"../\",_3,1)]"}}],f:[{t:8,r:"times"}]}]}]}],n:52,r:"report.parameters"}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"header",g:1}],f:[{t:7,e:"h3",m:[{n:"title",f:"Define data sources that are available in the designer",t:13,g:1}],f:["Provided Sources"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"add",g:1},{n:["click"],t:70,f:{r:["~/actions"],s:"[_0.provideSource()]"}},{n:"title",f:"Add provided source",t:13,g:1}],f:["+"]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"src head",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"src-name",g:1}],f:["Name"]}]}],n:50,r:"~/sources"}," ",{t:7,e:"div",f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"src",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"src-name",g:1}],f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".name"}],t:13},{n:"disabled",f:[{t:2,x:{r:["~/showProjects"],s:"_0===false"}}],t:13}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"src-btn",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Import data...",t:13,g:1},{n:["click"],t:70,f:{r:["~/actions","@context"],s:"[_0.editProvidedSource((_1))]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"pencil"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:"title",f:"Log data to console...",t:13,g:1},{n:["click"],t:70,f:{r:["@this","."],s:"[_0.logData(_1)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,x:{r:[],s:"\"console\""}}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico large",g:1},{n:["click"],t:70,f:{r:["@this","@keypath","@context","@index"],s:"[_0.checkLink(\"import\",_1),(_2).splice(\"../\",_3,1)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"times"}]}]}]}],n:52,r:"~/sources"}]}],n:50,r:"~/sources"},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"style",f:"justify-content: center;",g:1},{t:13,n:"class",f:"header",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"plain",g:1},{n:["click"],t:70,f:{r:["~/actions"],s:"[_0.provideSource()]"}},{n:"title",f:"Create a new source of data to reference from a report source",t:13,g:1}],f:["Provide Source"]}]}],n:51,l:1}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"header",g:1}],f:[{t:7,e:"h3",m:[{n:"title",f:"Define data sources that will be available in the report and will pull from provided sources or a base value",t:13,g:1}],f:["Sources"]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"add",g:1},{n:["click"],t:70,f:{r:["@this"],s:"[_0.push(\"report.sources\",{name:\"\",parameters:{}})]"}},{n:"title",f:"Add source",t:13,g:1}],f:["+"]}]}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"src head",g:1}],f:[{t:7,e:"div",m:[{t:13,n:"style",f:"width: 100%;",g:1},{t:13,n:"class",f:"src-name",g:1}],f:["Name"]}]}],n:50,r:"report.sources.length"}," ",{t:7,e:"div",f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"src",g:1},{n:["focusin"],t:70,f:{r:["@this","@context"],s:"[_0.editReportSrc((_1))]"}}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"rsrc-name",g:1}],f:[{t:7,e:"input",m:[{n:"value",f:[{t:2,r:".name"}],t:13}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"rsrc-src",g:1}],f:[{t:7,e:"select",m:[{n:"value",f:[{t:2,r:".source"}],t:13}],f:[{t:4,f:[{t:7,e:"option",f:[{t:2,r:".name"}]}],n:52,r:"~/sources"}]}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"rsrc-btn",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:["click"],t:70,f:{r:["@this","@keypath","@context","@index"],s:"[_0.checkLink(\"source\",_1),(_2).splice(\"../\",_3,1)]"}},{n:"tabindex",f:"-1",t:13,g:1}],f:[{t:8,r:"times"}]}]}]}],n:52,r:"report.sources"}]}],n:50,x:{r:["~/temp.widget"],s:"_0===\"report\""}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"scrolled-wrapper",g:1}],f:[{t:7,e:"div",m:[{n:"scrolled",t:71}],f:[{t:7,e:"div",m:[{t:13,n:"class",f:"sheet",g:1}],f:[{t:4,f:[{t:8,x:{r:[".type"],s:"_0+\"-props\""}}," ",{t:8,r:"widget-props"}],n:54,r:"~/widget"}]}]}]}],n:50,r:"~/widget",l:1}]}]}],n:50,x:{r:["~/temp.widget","~/show.hideprops"],s:"_0&&!_1"}},{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"placeholder",g:1}],f:["Click on a Widget"]}],n:50,x:{r:["~/show.hideprops"],s:"!_0"},l:1}]}],"delimited-fields":[{t:7,e:"div",m:[{t:13,n:"class",f:"delimited children",g:1}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"node",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["@keypath","~/temp.expr.path"],s:"_0===_1"}}]},{n:"class-hover",t:13,f:[{t:2,x:{r:["@keypath","~/temp.expr.hover"],s:"_0===_1"}}]},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.editExpr((_1))]"}}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"line",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.expr.hover\",_1),false]"}},{n:["mouseout"],t:70,f:{r:["@this"],s:"[_0.set(\"temp.expr.hover\",\"\"),false]"}}],f:[{t:7,e:"span",f:[{t:2,x:{r:["@index"],s:"_0+1"}},". ",{t:4,f:[{t:2,rx:{r:"^^/headers",m:[{t:30,n:"@index"}]}}," (",{t:2,r:"."},")"],n:50,rx:{r:"^^/headers",m:[{t:30,n:"@index"}]}},{t:4,f:[{t:2,r:"."}],n:51,l:1}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico field up-arrow",g:1},{n:"title",f:"Move up (hold the shift key to move to first)",t:13,g:1},{n:"disabled",f:[{t:2,x:{r:["@index"],s:"_0===0"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context","~/report.headers","@index","@event.shiftKey"],s:"[_0.moveUp((_1),[\"../\",_2?\"~/report.headers\":undefined],_3,_4),false]"}}],f:[{t:8,r:"arrow"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico field down-arrow",g:1},{n:"title",f:"Move down (hold the shift key to move to last)",t:13,g:1},{n:"disabled",f:[{t:2,x:{r:["@index","@last"],s:"_0===_1"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context","~/report.headers","@index","@event.shiftKey"],s:"[_0.moveDown((_1),[\"../\",_2?\"~/report.headers\":undefined],_3,_4),false]"}}],f:[{t:8,r:"arrow"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico field remove",g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1))]"}}],f:[{t:8,r:"times"}]}]}]}],n:52,r:".fields"}]}],"widget-tree":[{t:7,e:"div",m:[{t:13,n:"class",f:"children",g:1}],f:[{t:4,f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"node",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.widget","@keypath"],s:"_0===_1"}}]},{n:"class-hover",t:13,f:[{t:2,x:{r:["~/temp.hover","@keypath"],s:"_0===_1"}}]},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.clickWidget((_1))]"}},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:"title",f:[{t:4,f:["Click to move the widget to this container -"],n:50,r:"~/reparent"},{t:4,f:["Click to add a copy of the widget to this container -"],n:50,r:"~/copy",l:1}," Path: ",{t:2,r:"@keypath"}],t:13}],f:[{t:7,e:"span",m:[{n:"class",f:["line ",{t:2,x:{r:["@this","@keypath"],s:"_0.getNestLevel(_1)"}}],t:13}],f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico expander",g:1},{n:["click"],t:70,f:{r:["@this","escapeKey","@keypath","~/temp.tree"],s:"[_0.set(\"temp.tree.\"+_1(_2),_3&&_3[_2]===false?true:false),false]"}}],f:[{t:4,f:["-"],n:50,x:{r:["@keypath","~/temp.tree"],s:"_1[_0]!==false"}},{t:4,f:["+"],n:51,l:1}]}],n:50,r:".widgets.length"}," ",{t:7,e:"span",f:["group ",{t:2,x:{r:["@index"],s:"_0+1"}}," ",{t:8,r:"widget-info"}]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico up-arrow",g:1},{n:"disabled",f:[{t:2,x:{r:["@index"],s:"_0===0"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.moveUp((_1),[\"../\",\"^^/groupEnds\"]),false]"}},{n:"title",f:"Move up",t:13,g:1}],f:[{t:8,r:"arrow"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico down-arrow",g:1},{n:"disabled",f:[{t:2,x:{r:["@index","@last"],s:"_0===_1"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.moveDown((_1),[\"../\",\"^^/groupEnds\"]),false]"}},{n:"title",f:"Move down",t:13,g:1}],f:[{t:8,r:"arrow"}]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico remove",g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1)),false]"}},{n:"title",f:"Remove group",t:13,g:1}],f:[{t:8,r:"times"}]}]}," ",{t:4,f:[{t:8,r:"widget-tree"}],n:50,x:{r:["@keypath","~/temp.tree"],s:"_1[_0]!==false"}}]}],n:52,r:".group"}],n:50,x:{r:[".type",".group"],s:"_0===\"repeater\"&&_1"}}," ",{t:4,f:[{t:4,f:[{t:8,r:"special-container",z:[{n:"label",x:{x:{r:[],s:"\"overlay\""}}}]}],n:54,r:".overlay"}],n:50,x:{r:[".overlay.type"],s:"_0===\"container\""}}," ",{t:4,f:[{t:4,f:[{t:8,r:"special-container",z:[{n:"label",x:{x:{r:[],s:"\"header\""}}}]}],n:54,r:".header"}],n:50,x:{r:[".header.type"],s:"_0===\"container\""}}," ",{t:4,f:[{t:4,f:[{t:8,r:"special-container",z:[{n:"label",x:{r:"@key"}}]}],n:50,x:{r:["@key",".type"],s:"_0!==\"header\"&&_0!==\"footer\"&&_0!==\"alternate\"&&_0!==\"overlay\"&&_0!==\"watermark\"&&_1===\"container\""}}],n:52,r:"."}," ",{t:4,f:[{t:4,f:[{t:8,r:"special-container",z:[{n:"label",x:{x:{r:[],s:"\"alternate\""}}}]}],n:54,r:".alternate"}],n:50,x:{r:[".alternate.type"],s:"_0===\"container\""}}," ",{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"node",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.widget","@keypath"],s:"_0===_1"}}]},{n:"class-hover",t:13,f:[{t:2,x:{r:["~/temp.hover","@keypath"],s:"_0===_1"}}]},{n:"class-moving",t:13,f:[{t:2,x:{r:["~/reparent","@keypath","~/copy"],s:"_0&&_1===_0.resolve()||_2&&_1===_2.resolve()"}}]},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.clickWidget((_1))]"}},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:"title",f:[{t:4,f:["Click to move the widget to this container. -"],n:50,x:{r:["~/reparent",".widgets",".type"],s:"!!_0&&(!!_1||_2===\"container\")"}},{t:4,f:["Click to add a copy of the widget to this container. Shift click to add a copy of the widget before this container. - "],n:50,x:{r:["~/copy",".widgets",".type"],s:"!!_0&&(!!_1||_2===\"container\")"},l:1},{t:4,f:["Click to add a copy of the widget before this widget -"],n:50,x:{r:["~/copy"],s:"!!_0"},l:1}," Path: ",{t:2,r:"@keypath"}],t:13}],f:[{t:7,e:"span",m:[{n:"class",f:["line ",{t:2,x:{r:["@this","@keypath"],s:"_0.getNestLevel(_1)"}}],t:13}],f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico expander",g:1},{n:["click"],t:70,f:{r:["@this","escapeKey","@keypath","~/temp.tree"],s:"[_0.set(\"temp.tree.\"+_1(_2),_3&&_3[_2]===false?true:false),false]"}}],f:[{t:4,f:["-"],n:50,x:{r:["@keypath","~/temp.tree"],s:"_1[_0]!==false"}},{t:4,f:["+"],n:51,l:1}]}],n:50,x:{r:[".widgets.length",".type"],s:"_0||_1===\"repeater\""}}," ",{t:7,e:"span",f:[{t:2,r:".type"},{t:8,r:"widget-info"}]}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"actions",g:1}],f:[{t:4,f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add header",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".header\",{type:\"container\"}),false]"}}],f:["+H"]}],n:50,x:{r:[".header"],s:"!_0"}}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:["Add group ",{t:4,f:["level"],n:50,r:".group"}],t:13},{n:["click"],t:70,f:{r:[".group","@context"],s:"[_0?[(_1).push(\".group\",{type:\"container\"}),(_1).splice(\".groupEnds\",-1,0,true)]:(_1).set({\".group\":[{type:\"container\"}],\".groupEnds\":[true,true]}),false]"}}],f:["+G"]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add alternate",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".alternate\",{type:\"container\"}),false]"}}],f:["+A"]}],n:50,x:{r:[".alternate"],s:"!_0"}}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:"Add footer",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".footer\",{type:\"container\"}),false]"}}],f:["+F"]}],n:50,x:{r:[".footer"],s:"!_0"}}],n:50,x:{r:[".type"],s:"_0===\"repeater\""}}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:["Copy ",{t:2,x:{r:[".type"],s:"_0||\"widget\""}}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.set(\"copy\",(_1)),false]"}}],f:[{t:8,r:"copy"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico",g:1},{n:"title",f:["Move ",{t:2,x:{r:[".type"],s:"_0||\"widget\""}}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.set(\"reparent\",(_1)),false]"}}],f:[{t:8,r:"reparent"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico up-arrow",g:1},{n:"title",f:["Move up (hold the shift key to move to first",{t:4,f:[", hold the control key to swap layout coordinate too"],n:50,x:{r:["^^/layout"],s:"Array.isArray(_0)"}},")"],t:13},{n:"disabled",f:[{t:2,x:{r:["@index"],s:"_0===0"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context","@event.ctrlKey","^^/layout","@index","@event.shiftKey"],s:"[_0.moveUp((_1),[\"../\",!_2&&Array.isArray(_3)?\"^^/layout\":undefined],_4,_5),false]"}}],f:[{t:8,r:"arrow"}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico down-arrow",g:1},{n:"title",f:["Move down (hold the shift key to move to last",{t:4,f:[", hold the control key to swap layout coordinates too"],n:50,x:{r:["^^/layout"],s:"Array.isArray(_0)"}},")"],t:13},{n:"disabled",f:[{t:2,x:{r:["@index","@last"],s:"_0===_1"}}],t:13},{n:["click"],t:70,f:{r:["@this","@context","@event.ctrlKey","^^/layout","@index","@event.shiftKey"],s:"[_0.moveDown((_1),[\"../\",!_2&&Array.isArray(_3)?\"^^/layout\":undefined],_4,_5),false]"}}],f:[{t:8,r:"arrow"}]}]}," ",{t:7,e:"button",m:[{t:13,n:"class",f:"ico remove",g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1)),false]"}},{n:"title",f:["Remove ",{t:2,r:".type"}],t:13}],f:[{t:8,r:"times"}]}],n:50,x:{r:["~/reparent","~/copy"],s:"!_0&&!_1"}}]}," ",{t:4,f:[{t:8,r:"widget-tree"}],n:50,x:{r:["@keypath","~/temp.tree"],s:"_1[_0]!==false"}}]}],n:52,z:[{n:"widget",x:{r:"."}},{n:"kp",x:{r:"@keypath"}}],r:".widgets"}," ",{t:4,f:[{t:4,f:[{t:8,r:"special-container",z:[{n:"label",x:{x:{r:[],s:"\"footer\""}}}]}],n:54,r:".footer"}],n:50,x:{r:[".footer.type"],s:"_0===\"container\""}}," ",{t:4,f:[{t:4,f:[{t:8,r:"special-container",z:[{n:"label",x:{x:{r:[],s:"\"watermark\""}}}]}],n:54,r:".watermark"}],n:50,x:{r:[".watermark.type"],s:"_0===\"container\""}}]}],max:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 32 32",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"M 14.618244,4.9839578 V 6.2242813 8.2613998 H 21.78473 L 7.4782137,22.564804 9.7954554,24.882046 23.977473,10.701585 v 6.984406 h 3.277442 V 8.1633567 c 0,-1.7435588 -1.438601,-3.1793989 -3.180956,-3.1793989 z M 24.732249,7.0662073 9.2320964,22.564804 9.7954554,23.128163 25.295608,7.6295663 Z M 9.5143344,22.847073 25.013998,7.3474099 m -9.15543,-1.1231286 v 0.796795 h 8.215391 c 0.639958,0 1.143837,0.5023239 1.143837,1.1422804 v 8.2823113 h 0.796795 V 8.1633567 c 0,-1.067599 -0.873032,-1.9390754 -1.940632,-1.9390754 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 3.2910156,1.1269531 c -1.3398667,0 -2.43554685,1.093727 -2.43554685,2.4335938 V 28.708984 c 0,1.339867 1.09568015,2.435547 2.43554685,2.435547 H 28.845703 c 1.339867,0 2.433594,-1.09568 2.433594,-2.435547 V 3.5605469 c 0,-1.3398668 -1.093727,-2.4335938 -2.433594,-2.4335938 z m 0,1 H 28.845703 c 0.803165,0 1.433594,0.6304293 1.433594,1.4335938 V 28.708984 c 0,0.803165 -0.630429,1.435547 -1.433594,1.435547 H 3.2910156 c -0.8031645,0 -1.4355468,-0.632382 -1.4355469,-1.435547 V 3.5605469 c 0,-0.8031645 0.6323824,-1.4335938 1.4355469,-1.4335938 z",t:13,g:1}]}]}],cog:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 32 32",t:13,g:1}],f:[{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"M 16.00011,3.228628 A 12.771503,12.771503 0 0 0 14.886282,3.308861 L 13.781893,7.7216959 10.600878,4.4344882 A 12.771503,12.771503 0 0 0 8.6894353,5.5601152 L 9.9401325,9.9399127 5.5603348,8.6892168 a 12.771503,12.771503 0 0 0 -1.125627,1.9114422 l 3.2872078,3.181016 -4.4128347,1.104389 a 12.771503,12.771503 0 0 0 -0.080233,1.113828 12.771503,12.771503 0 0 0 0.080233,1.113828 l 4.4128347,1.104388 -3.2872078,3.181018 a 12.771503,12.771503 0 0 0 1.125627,1.913801 l 4.3797977,-1.253056 -1.2506972,4.379798 a 12.771503,12.771503 0 0 0 1.9138017,1.125626 l 3.178656,-3.287208 1.104389,4.412835 a 12.771503,12.771503 0 0 0 1.113828,0.08024 12.771503,12.771503 0 0 0 1.113828,-0.08024 l 1.104388,-4.412835 3.181018,3.289569 a 12.771503,12.771503 0 0 0 1.911441,-1.127987 l -1.250696,-4.379798 4.379798,1.253056 a 12.771503,12.771503 0 0 0 1.125626,-1.913801 L 24.278305,18.218108 28.69114,17.11372 a 12.771503,12.771503 0 0 0 0.08024,-1.113828 12.771503,12.771503 0 0 0 -0.04955,-1.106749 l -4.443513,-1.111468 3.294288,-3.185736 A 12.771503,12.771503 0 0 0 26.461136,8.6821366 L 22.0601,9.9399127 23.317875,5.5365171 A 12.771503,12.771503 0 0 0 21.404063,4.4297687 L 18.218326,7.7216959 17.106858,3.2805437 A 12.771503,12.771503 0 0 0 16.00011,3.228628 Z m 0,5.4794672 A 7.2902771,7.2902771 0 0 1 23.289547,15.999892 7.2902771,7.2902771 0 0 1 16.00011,23.289329 7.2902771,7.2902771 0 0 1 8.7106746,15.999892 7.2902771,7.2902771 0 0 1 16.00011,8.7080952 Z",t:13,g:1}]}]}],tree:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 32 32",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 3.1714129,1.718648 h 1.9581459 c 0.5092546,0 0.9192321,0.4099775 0.9192321,0.9192321 v 1.9581458 c 0,0.5092546 -0.4099775,0.9192322 -0.9192321,0.9192322 H 3.1714129 c -0.5092546,0 -0.9192321,-0.4099776 -0.9192321,-0.9192322 V 2.6378801 c 0,-0.5092546 0.4099775,-0.9192321 0.9192321,-0.9192321 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 8.8285534,7.5689573 h 1.9581456 c 0.509255,0 0.919232,0.4099776 0.919232,0.9192322 v 1.9581455 c 0,0.509255 -0.409977,0.919232 -0.919232,0.919232 H 8.8285534 c -0.5092546,0 -0.9192321,-0.409977 -0.9192321,-0.919232 V 8.4881895 c 0,-0.5092546 0.4099775,-0.9192322 0.9192321,-0.9192322 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 8.8285534,13.419266 h 1.9581456 c 0.509255,0 0.919232,0.409977 0.919232,0.919232 v 1.958146 c 0,0.509254 -0.409977,0.919232 -0.919232,0.919232 H 8.8285534 c -0.5092546,0 -0.9192321,-0.409978 -0.9192321,-0.919232 v -1.958146 c 0,-0.509255 0.4099775,-0.919232 0.9192321,-0.919232 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 8.8285534,25.119884 h 1.9581456 c 0.509255,0 0.919232,0.409978 0.919232,0.919233 v 1.958145 c 0,0.509255 -0.409977,0.919233 -0.919232,0.919233 H 8.8285534 c -0.5092546,0 -0.9192321,-0.409978 -0.9192321,-0.919233 v -1.958145 c 0,-0.509255 0.4099775,-0.919233 0.9192321,-0.919233 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 14.485694,19.269575 h 1.958146 c 0.509254,0 0.919232,0.409978 0.919232,0.919232 v 1.958146 c 0,0.509255 -0.409978,0.919232 -0.919232,0.919232 h -1.958146 c -0.509255,0 -0.919232,-0.409977 -0.919232,-0.919232 v -1.958146 c 0,-0.509254 0.409977,-0.919232 0.919232,-0.919232 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"m 14,9.467 h 9.447664",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"M 9.4132559,21.16788 H 13.192658",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"M 3.5344077,27.29019 H 7.3138096 M 3.5344077,9.620506 H 7.3138096 M 3.5344077,15.317571 H 7.3138096 M 4.0344077,6.3835565 V 27.576964",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"m 14,15.317309 h 9.447664",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"m 9.8082219,18.086466 v 3.574792",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"m 19.28605,21.167618 h 9.447664",t:13,g:1}]}," ",{t:7,e:"path",m:[{t:13,n:"style",f:"stroke-width:1;",g:1},{n:"d",f:"m 14,27.017928 h 9.447664",t:13,g:1}]}]}],warning:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"M 7.9999999,1.3419993 A 0.51954981,0.51954981 0 0 0 7.5501881,1.6016783 L 0.46200598,13.878401 A 0.51954981,0.51954981 0 0 0 0.91181778,14.658 H 15.088182 a 0.51954981,0.51954981 0 0 0 0.449812,-0.779599 L 8.4498118,1.6016783 A 0.51954981,0.51954981 0 0 0 7.9999999,1.3419993 Z m 0,1.5580761 6.1879971,10.7186456 H 1.8120026 Z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"M 7.5117187,5.7675781 V 10.755859 H 8.4882813 V 5.7675781 Z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 7.5097656,11.556641 v 1.058593 h 0.9804688 v -1.058593 z",t:13,g:1}]}]}],autosize:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 7.8643604,1.1461781 c -0.1252288,1.027e-4 -0.2452523,0.050113 -0.333504,0.13896 L 3.8599966,4.9559978 c -0.1847627,0.1839512 -0.1847627,0.4830568 0,0.667008 0.1836871,0.1832173 0.4810049,0.1832173 0.664692,0 L 7.3942123,2.7534819 V 14.081037 L 4.5246886,11.213829 c -0.1836871,-0.183218 -0.4810049,-0.183218 -0.664692,0 -0.1832174,0.183687 -0.1832174,0.481004 0,0.664692 l 3.6708598,3.673175 c 0.088631,0.088 0.1892895,0.136645 0.333504,0.136645 0.1442144,0 0.2225519,-0.0257 0.3335039,-0.136645 0.1109522,-0.110954 3.6708597,-3.673175 3.6708597,-3.673175 0.183218,-0.183688 0.183218,-0.481005 0,-0.664692 -0.183951,-0.184763 -0.483057,-0.184763 -0.667008,0 L 8.3345084,14.081037 V 2.7534819 l 2.8672076,2.8695239 c 0.183951,0.1847627 0.483057,0.1847627 0.667008,0 0.184763,-0.1839512 0.184763,-0.4830568 0,-0.667008 L 8.1978643,1.2851381 C 8.1096126,1.1962906 7.9895891,1.1462808 7.8643604,1.1461781 Z",t:13,g:1}]}]}],times:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 3.081157,3.2367593 a 0.39687499,0.39687499 0 0 0 -0.28125,0.1171875 0.39687499,0.39687499 0 0 0 0,0.5605469 L 7.3038132,8.4184 2.799907,12.920353 a 0.39687499,0.39687499 0 0 0 0,0.560547 0.39687499,0.39687499 0 0 0 0.5625,0 L 7.8643601,8.9789468 12.368266,13.4809 a 0.39687499,0.39687499 0 0 0 0.560547,0 0.39687499,0.39687499 0 0 0 0,-0.560547 L 8.424907,8.4184 12.928813,3.9144937 a 0.39687499,0.39687499 0 0 0 0,-0.5605469 0.39687499,0.39687499 0 0 0 -0.560547,0 L 7.8643601,7.8558999 3.362407,3.3539468 A 0.39687499,0.39687499 0 0 0 3.081157,3.2367593 Z",t:13,g:1}]}]}],eye:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"M 8.0292969,3.84375 C 5.8187216,3.7959779 3.2719166,4.828582 0.6875,7.9414062 L 0.47851563,8.1933594 0.68554687,8.4472656 C 4.2213376,12.771626 7.6072279,13.362529 10.207031,12.503906 12.806835,11.645284 14.588183,9.4664365 15.279297,8.4121094 L 15.449219,8.1542969 15.240234,7.9257812 C 14.56764,7.1977999 12.721311,5.0903713 10.117188,4.2148437 9.4661566,3.9959619 8.7661553,3.859674 8.0292969,3.84375 Z M 8.0019531,4.6191406 C 8.6565753,4.6408129 9.2772607,4.769772 9.8632813,4.9667969 12.042444,5.6994492 13.625228,7.3762655 14.40625,8.2207031 13.700218,9.2262323 12.130956,11.032675 9.9589844,11.75 7.7038396,12.494794 4.8499214,12.067539 1.5566406,8.1992188 3.9323632,5.4612889 6.1082738,4.5564473 8.0019531,4.6191406 Z",t:13,g:1}]}," ",{t:7,e:"circle",m:[{n:"r",f:"3.5391803",t:13,g:1},{n:"cy",f:"8.3395138",t:13,g:1},{n:"cx",f:"8.0542507",t:13,g:1},{n:"fill",f:"#000",t:13,g:1}]}]}],play:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"M 2.5273438,2.1328125 A 0.39691468,0.39691468 0 0 0 2.328125,2.4765625 V 14.357422 a 0.39691468,0.39691468 0 0 0 0.5957031,0.34375 L 13.201172,8.7675781 a 0.39691468,0.39691468 0 0 0 0,-0.6875 L 2.9238281,2.1328125 a 0.39691468,0.39691468 0 0 0 -0.3964843,0 z m 0.5957031,1.03125 9.0878911,5.2597656 -9.0878911,5.2460939 z",t:13,g:1}]}]}],pencil:[{t:7,e:"svg",m:[{t:13,n:"class",f:"pencil",g:1},{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 10.574807,3.7181493 1.230348,-1.230348 c 0.786061,-0.1047571 2.169305,1.3270952 2.115927,2.0909526 l -1.24767,1.2476704 z m 0,0 L 12.677529,5.825142 5.136945,13.365724 3.5226704,13.820162 1.9083957,14.2746 2.5400804,12.67292 3.1717651,11.07124 10.574806,3.718149 Z",t:13,g:1}]}]}],console:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 2.5800781,4.140625 a 0.39687499,0.39687499 0 0 0 -0.2773437,0.1230469 0.39687499,0.39687499 0 0 0 0.011719,0.5625 L 5.9921875,8.3320313 2.3085938,12.015625 a 0.39687499,0.39687499 0 0 0 0,0.5625 0.39687499,0.39687499 0 0 0 0.5605468,0 L 6.8417969,8.6054688 a 0.39687499,0.39687499 0 0 0 0.00391,-0.00391 0.39687499,0.39687499 0 0 0 0.00195,-0.00195 0.39687499,0.39687499 0 0 0 0.00977,-0.015625 0.39687499,0.39687499 0 0 0 0.076172,-0.1425781 0.39687499,0.39687499 0 0 0 0.011719,-0.060547 A 0.39687499,0.39687499 0 0 0 6.9433594,8.25 0.39687499,0.39687499 0 0 0 6.9316406,8.1992188 0.39687499,0.39687499 0 0 0 6.8417969,8.0449219 a 0.39687499,0.39687499 0 0 0 -0.00391,0 0.39687499,0.39687499 0 0 0 -0.00391,-0.00781 L 2.8632813,4.25 A 0.39687499,0.39687499 0 0 0 2.5800781,4.140625 Z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 7.0917969,11.767578 v 0.792969 h 6.4453121 v -0.792969 z",t:13,g:1}]}]}],switch:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 11.226563,3.7128906 -0.707032,0.7070313 1.642578,1.6445312 H 3.046875 v 1 h 11.529297 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"M 1.1855469,8.9433594 4.5351562,12.292969 5.2421875,11.585938 3.5996094,9.9433594 h 9.1171876 v -1 z",t:13,g:1}]}]}],scrollto:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 7.9921875,0.95883941 c -0.250488,-0.00872 -0.5000001,0.18861599 -0.5,0.59179689 0,2.4565678 0.014046,5.4488885 0.015625,5.7792969 -0.414832,-0.4134912 -1.618944,-1.609179 -3.0527344,-3.0429688 -0.208715,-0.2087145 -0.833715,0.4162855 -0.625,0.625 L 8,9.0818863 12.169922,4.9119644 c 0.208822,-0.2088228 -0.41813,-0.8357759 -0.626953,-0.6269531 -1.010297,1.0102962 -2.5173079,2.5148582 -3.0351565,3.03125 -0.00152,-0.3342485 -0.013672,-3.072983 -0.013672,-5.71875 0,-0.4162448 -0.2514651,-0.62995161 -0.5019531,-0.63867189 z M 8.28125,7.5408707 C 8.2531767,7.5688634 8,7.8221207 8,7.8221207 c 0,0 -0.257095,-0.255216 -0.2792969,-0.2773438 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 1.9238281,10.37163 v 2 H 14.076172 v -2 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 1.9238281,13.169922 v 2 H 14.076172 v -2 z",t:13,g:1}]}]}],reparent:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 7.717269,6.5496963 c 1.1791128,1.1791128 3.537021,3.5439517 3.537021,3.5439517 0,0 -1.8715903,1.878096 -3.536918,3.543424 -0.2087145,0.208715 0.4174295,0.834858 0.626144,0.626143 1.739959,-1.739959 4.170103,-4.170102 4.170103,-4.170102 0,0 -2.8836136,-2.8836169 -4.170102,-4.1701053 C 8.1346942,5.7141849 7.5084462,6.3408735 7.717269,6.5496963 Z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"M 1.25,1.265625 V 3.1953125 H 3.1816406 V 1.265625 Z m 3.8613281,0 V 3.1953125 H 7.0410156 V 1.265625 Z m 3.859375,0 V 3.1953125 H 10.900391 V 1.265625 Z m 3.8593749,0 V 3.1953125 H 14.75 V 1.265625 Z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 3.5527344,4 c 0,1.570084 0,5.1494183 0,5.1494183 0,0.8840967 0.4590976,1.4746067 1.428392,1.4746067 l 7.3118426,-0.0166 -0.0039,-1.0000001 -7.2599976,0.014648 c -0.3569634,0 -0.476331,-0.1906315 -0.476331,-0.5277838 0,0 0,-3.4980046 0,-5.0942891 0,-0.3333353 -1.000006,-0.3333353 -1.000006,0 z",t:13,g:1}]}," ",{t:4,f:[{t:7,e:"path",m:[{n:"d",f:"M 2.5878906 1.7539062 L 1.3984375 2.9433594 L 6.7871094 8.3320312 L 1.3984375 13.720703 L 2.5878906 14.912109 L 7.9765625 9.5234375 L 13.367188 14.912109 L 14.556641 13.720703 L 9.1679688 8.3320312 L 14.556641 2.9433594 L 13.367188 1.7539062 L 7.9765625 7.1425781 L 2.5878906 1.7539062 z",t:13,g:1},{n:"opacity",f:"0.5",t:13,g:1},{n:"fill",f:"red",t:13,g:1}]}],n:50,r:"cancel"}]}],copy:[{t:7,e:"svg",m:[{n:"viewBox",f:"0 0 16 16",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"m 2.5507813,0.02148438 c -1.0111865,0 -1.84570318,0.84012077 -1.84570318,1.84960932 v 9.7968753 c 0,1.009488 0.83451588,1.847656 1.84570318,1.847656 H 6.4335937 V 4.4023437 c 0,-0.2045815 0.1433298,-0.3457031 0.3496094,-0.3457031 H 11.121094 V 1.8710937 c 0,-1.00948872 -0.83647,-1.84960932 -1.8476565,-1.84960932 z m 0,1.50000002 h 6.7226562 c 0.2045818,0 0.3476563,0.1433291 0.3476563,0.3496093 V 2.5566406 H 6.7832031 c -1.0094885,0 -1.8496094,0.8345165 -1.8496094,1.8457031 V 12.015625 H 2.5507813 c -0.2045816,0 -0.3457032,-0.141378 -0.3457032,-0.347656 V 1.8710937 c 0,-0.2062803 0.1411208,-0.3496093 0.3457032,-0.3496093 z",t:13,g:1}]}," ",{t:7,e:"path",m:[{n:"d",f:"m 6.7832031,2.5566406 c -1.0104117,0 -1.8476562,0.8372445 -1.8476562,1.8476563 v 9.7968751 c 0,1.010412 0.8372445,1.847656 1.8476562,1.847656 h 6.7226559 c 1.010412,0 1.845704,-0.837245 1.845704,-1.847656 V 4.4042969 c 0,-1.010411 -0.835292,-1.8476563 -1.845704,-1.8476563 z m 0,1.5 h 6.7226559 c 0.205359,0 0.345703,0.1422974 0.345704,0.3476563 v 9.7968751 c 0,0.20536 -0.140345,0.347656 -0.345704,0.347656 H 6.7832031 c -0.205358,0 -0.3476562,-0.142297 -0.3476562,-0.347656 V 4.4042969 c 0,-0.205358 0.1422982,-0.3476563 0.3476562,-0.3476563 z",t:13,g:1}]}," ",{t:4,f:[{t:7,e:"path",m:[{n:"d",f:"M 2.5878906 1.7539062 L 1.3984375 2.9433594 L 6.7871094 8.3320312 L 1.3984375 13.720703 L 2.5878906 14.912109 L 7.9765625 9.5234375 L 13.367188 14.912109 L 14.556641 13.720703 L 9.1679688 8.3320312 L 14.556641 2.9433594 L 13.367188 1.7539062 L 7.9765625 7.1425781 L 2.5878906 1.7539062 z",t:13,g:1},{n:"opacity",f:"0.5",t:13,g:1},{n:"fill",f:"red",t:13,g:1}]}],n:50,r:"cancel"}]}],arrow:[{t:7,e:"svg",m:[{n:"viewBox",f:"4 7 16 10",t:13,g:1}],f:[{t:7,e:"path",m:[{n:"d",f:"M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z",t:13,g:1}]}]}],"special-container":[{t:7,e:"div",m:[{t:13,n:"class",f:"node",g:1},{n:"class-active",t:13,f:[{t:2,x:{r:["~/temp.widget","@keypath"],s:"_0===_1"}}]},{n:"class-hover",t:13,f:[{t:2,x:{r:["~/temp.hover","@keypath"],s:"_0===_1"}}]},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.clickWidget((_1))]"}},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:"title",f:[{t:4,f:["Click to move the widget to this container -"],n:50,r:"~/reparent"},{t:4,f:["Click to add a copy of the widget to this container. -"],n:50,r:"~/copy",l:1}," Path: ",{t:2,r:"@keypath"}],t:13}],f:[{t:7,e:"span",m:[{n:"class",f:["line ",{t:2,x:{r:["@this","@keypath"],s:"_0.getNestLevel(_1)"}}],t:13}],f:[{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico expander",g:1},{n:["click"],t:70,f:{r:["@this","escapeKey","@keypath","~/temp.tree"],s:"[_0.set(\"temp.tree.\"+_1(_2),_3&&_3[_2]===false?true:false),false]"}}],f:[{t:4,f:["-"],n:50,x:{r:["@keypath","~/temp.tree"],s:"_1[_0]!==false"}},{t:4,f:["+"],n:51,l:1}]}],n:50,r:".widgets.length"}," ",{t:7,e:"span",f:[{t:2,x:{r:["label"],s:"_0||\"unknown\""}}," ",{t:8,r:"widget-info"}]}," ",{t:4,f:[{t:7,e:"button",m:[{t:13,n:"class",f:"ico remove",g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1)),false]"}},{n:"title",f:["Remove ",{t:2,x:{r:["label"],s:"_0||\"unknown\""}}],t:13}],f:[{t:8,r:"times"}]}],n:50,x:{r:["@key","../type"],s:"_0!==\"row\"||_1!==\"repeater\""}}]}," ",{t:4,f:[{t:8,r:"widget-tree"}],n:50,x:{r:["@keypath","~/temp.tree"],s:"_1[_0]!==false"}}]}],"widget-info":[{t:4,f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"widget-id",g:1}],f:[".",{t:2,r:".id"}]}],n:50,x:{r:[".id"],s:"_0!=null"}}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"widget-info",g:1}],f:[{t:2,r:".text"}]}],n:50,x:{r:[".type"],s:"_0===\"label\"||_0===\"measured\""}},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"widget-info",g:1}],f:[{t:2,r:".url"}]}," "],n:50,x:{r:[".type"],s:"_0===\"image\""},l:1},{t:4,f:[" ",{t:7,e:"span",m:[{t:13,n:"class",f:"widget-info",g:1}],f:[{t:2,x:{r:[".source.x",".source",".source.name",".source.source"],s:"_1&&typeof _1===\"object\"&&\"x\" in _1?_0:typeof _1===\"string\"?_1:(_2||_3||\"(None)\")"}}]}," "],n:50,x:{r:[".type"],s:"_0===\"repeater\""},l:1},{t:4,f:[" ",{t:7,e:"span",m:[{t:13,n:"class",f:"widget-info",g:1}],f:["macro: ",{t:2,r:".macro"}]}," "],n:50,r:".macro",l:1},{t:4,f:[" ",{t:7,e:"span",m:[{t:13,n:"class",f:"widget-info",g:1}],f:["(",{t:2,r:".widgets.length"}," child",{t:4,f:["ren"],n:50,x:{r:[".widgets.length"],s:"_0!==1"}},")"]}],n:50,r:".widgets.length",l:1}],repeater:[{t:7,e:"div",m:[{t:13,n:"class",f:"bar",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"name",g:1}],f:["Repeater"]}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context","@this"],s:"[(_0).set(\".group\",undefined),(_0).set(\".groupEnds\",[true]),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]"}}],f:["Remove Group"]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).push(\".group\",{type:\"container\"}),(_0).splice(\".groupEnds\",-1,0,true)]"}}],f:["Add Group Level"]}],n:50,r:".group"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".group\",[{type:\"container\"}]),(_0).set(\".groupEnds\",[true,true])]"}}],f:["Add Group"]}],n:51,l:1}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context","@this"],s:"[(_0).set(\".header\",undefined),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]"}}],f:["Remove Header"]}],n:50,r:".header"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".header\",{type:\"container\"})]"}}],f:["Add Header"]}],n:51,l:1}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context","@this"],s:"[(_0).set(\".alternate\",undefined),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]"}}],f:["Remove Alternate"]}],n:50,r:".alternate"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".alternate\",{type:\"container\"})]"}}],f:["Add Alternate"]}],n:51,l:1}," ",{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context","@this"],s:"[(_0).set(\".footer\",undefined),_1.unlink(\"widget\"),_1.set(\"temp.widget\",undefined)]"}}],f:["Remove Footer"]}],n:50,r:".footer"},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"btn",g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).set(\".footer\",{type:\"container\"})]"}}],f:["Add Footer"]}],n:51,l:1}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"widgets",g:1}],f:[{t:4,f:[{t:4,f:[{t:8,r:"widget",z:[{n:"label",x:{x:{r:["@index"],s:"\"Group Header \"+(_0+1)"}}}]}],n:52,r:".group"}],n:50,r:".group"}," ",{t:4,f:[{t:4,f:[{t:8,r:"widget",z:[{n:"label",x:{x:{r:[],s:"\"Header\""}}}]}],n:54,r:".header"}],n:50,r:".header"}," ",{t:4,f:[{t:2,x:{r:["@context"],s:"(_0).set(\".row\",{type:\"container\"})&&\"\""}}],n:50,x:{r:[".row"],s:"!_0"}}," ",{t:4,f:[{t:8,r:"widget",z:[{n:"label",x:{x:{r:[],s:"\"Row\""}}}]}],n:54,r:".row"}," ",{t:4,f:[{t:4,f:[{t:8,r:"widget",z:[{n:"label",x:{x:{r:[],s:"\"Alternate\""}}}]}],n:54,r:".alternate"}],n:50,r:".alternate"}," ",{t:4,f:[{t:4,f:[{t:8,r:"widget",z:[{n:"label",x:{x:{r:[],s:"\"Footer\""}}}]}],n:54,r:".footer"}],n:50,r:".footer"}]}],html:[{t:19,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"preview btn",g:1},{n:"title",f:"Toggle Preview",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).toggle(\"ctx.preview\")]"}}],f:[{t:8,r:"eye"}]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"autosize btn",g:1},{n:"title",f:"Autosize Block",t:13,g:1},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.autosizeHtml((_1))]"}}],f:[{t:8,r:"autosize"}]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"content",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.editExpr((_1).resolve(\".html\"),{html:true})]"}},{n:"class-preview",t:13,f:[{t:2,r:"ctx.preview"}]},{t:4,f:[{n:"style-font-size",f:[{t:2,x:{r:[".font.size"],s:"_0||0.83"}},"rem"],t:13},{n:"style-line-height",f:[{t:2,x:{r:[".font.line",".font.size"],s:"_0===0?\"initial\":(_0||_1||1)+\"rem\""}}],t:13}],n:50,r:"ctx.preview"},{t:4,f:[{n:"style",f:"height: auto;",t:13}],n:50,r:"ctx.autosize"},{t:4,f:[{n:"title",f:[{t:2,r:".html"}],t:13}],n:50,x:{r:[".html.length"],s:"_0<50"}}],f:[{t:4,f:[{t:3,r:".html"}],n:50,r:"ctx.preview"},{t:4,f:[{t:7,e:"Viewer",m:[{t:13,n:"style",f:"overflow: hidden;",g:1},{n:"src",f:[{t:2,r:".html"}],t:13},{n:"template",f:"true",t:13,g:1}]}],n:51,l:1}]}],n:54,z:[{n:"ctx",x:{r:"@local"}}]}],image:[{t:19,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"content",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:"title",f:[{t:2,r:".url"}],t:13}],f:[{t:4,f:[{t:7,e:"div",m:[{n:"style",f:["width: 100%; height: 100%; background-image: url('",{t:2,x:{r:["@this",".url"],s:"_0.evalExpr(_1)"}},"'); background-repeat: no-repeat; background-size: ",{t:2,x:{r:[".fit"],s:"!_0?\"contain\":_0===\"stretch\"?\"100% 100%\":\"cover\""}},"; background-position: center;"],t:13}]}],n:50,r:"ctx.preview"},{t:4,f:["IMG"],n:51,l:1}]}," ",{t:7,e:"span",m:[{t:13,n:"class",f:"preview btn",g:1},{n:"title",f:"Toggle Preview",t:13,g:1},{n:["click"],t:70,f:{r:["@context"],s:"[(_0).toggle(\"ctx.preview\")]"}}],f:[{t:8,r:"eye"}]}],n:54,z:[{n:"ctx",x:{r:"@local"}}]}],label:[{t:7,e:"span",m:[{t:13,n:"class",f:"content",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:"title",f:[{t:2,r:".text"}],t:13}],f:[{t:4,f:[{t:4,f:[{t:4,f:[{t:2,r:"."}],n:50,x:{r:["."],s:"typeof _0===\"string\""}},{t:4,f:[{t:7,e:"span",m:[{t:4,f:[{n:"style",f:[{t:2,x:{r:["@this","."],s:"_0.calcFont(_1)"}}],t:13}],n:50,r:".font"}],f:[{t:2,r:".text"}]}],n:51,l:1}],n:52,r:".text"}],n:50,x:{r:[".text"],s:"Array.isArray(_0)"}},{t:4,f:[{t:7,e:"Viewer",m:[{t:13,n:"style",f:"overflow: hidden;",g:1},{n:"src",f:[{t:2,r:".text"}],t:13}]}],n:51,l:1}]}],container:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"content",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}},{n:"title",f:[{t:2,r:".text"}],t:13}],f:[{t:7,e:"Viewer",m:[{t:13,n:"style",f:"overflow: hidden;",g:1},{n:"src",f:[{t:2,r:".macro"}],t:13}]}]}],n:50,r:".macro"},{t:4,f:[{t:19,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"bar",g:1},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1),false]"}}],f:[{t:7,e:"span",m:[{t:13,n:"class",f:"name",g:1}],f:[{t:2,x:{r:["label"],s:"_0||\"container\""}}]}," ",{t:4,f:[{t:2,x:{r:["@context",".layout"],s:"(_0).set(\"ctx.layout\",_1===\"row\"||!_1?\"auto\":\"manual\")&&\"\""}}],n:50,r:"ctx.layout"}," ",{t:7,e:"select",m:[{n:"value",f:[{t:2,r:"ctx.layout"}],t:13},{n:["change"],t:70,f:{r:["@node.value","@context"],s:"[_0===\"auto\"?(_1).set(\".layout\",undefined):(_1).set(\".layout\",[])]"}}],f:[{t:7,e:"option",m:[{n:"value",f:"auto",t:13}],f:["Auto Layout"]}," ",{t:7,e:"option",m:[{n:"value",f:"manual",t:13}],f:["Manual Layout"]}]}]}],n:54,z:[{n:"ctx",x:{r:"@local"}}]}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"widgets",g:1},{n:"class-manual",t:13,f:[{t:2,x:{r:[".layout"],s:"Array.isArray(_0)"}}]},{n:"style",f:["height: ",{t:2,r:"heightMargin"},";"],t:13},{n:["mouseover"],t:70,f:{r:["@this","@keypath"],s:"[_0.set(\"temp.hover\",_1)]"}}],f:[{t:4,f:[{t:8,r:"widget",z:[{n:"label",x:{x:{r:[],s:"false"}}}]}],n:52,r:".widgets"}]}],n:51,l:1}],widget:[{t:19,f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"break",g:1}]}],n:50,x:{r:[".br"],s:"_0===true"}}," ",{t:7,e:"div",m:[{n:"widget",t:71,f:{r:[".type"],s:"[_0]"}},{n:"style",f:[{t:4,f:["width: ",{t:2,r:"widthMargin"},";"],n:50,x:{r:["label"],s:"_0!==\"page footer\""}},{t:4,f:["position: absolute; width: auto; left: ",{t:2,x:{r:["~/pageSize.margin.1"],s:"_0||0"}},"rem; right: ",{t:2,x:{r:["~/pageSize.margin.1"],s:"_0||0"}},"rem; bottom: ",{t:2,x:{r:["~/pageSize.margin.0"],s:"_0||0"}},"rem;"],n:51,l:1}," ",{t:4,f:[{t:2,x:{r:[".type"],s:"_0===\"container\"?\"min-\":\"\""}},"height: ",{t:2,r:"heightMargin"},";"],n:50,x:{r:[".height",".type"],s:"(_0&&_0!==\"auth\")||_1!==\"container\""}}],t:13},{t:4,f:[{n:"style",f:[{t:2,x:{r:["@this","@index","^^/layout","widthMargin","heightMargin"],s:"_0.calcManualLayout(_2[_1],_3,_4)"}}],t:13},{t:4,f:[{n:"moveable",t:71}],n:50,x:{r:["~/temp.widget","@keypath"],s:"_0===_1"}}," "],n:50,x:{r:["^^/layout"],s:"Array.isArray(_0)"}},{t:4,f:[{n:"style",f:[{t:4,f:["flex-grow: 1; break-after: always;"],n:50,x:{r:[".width"],s:"_0===\"grow\""}}],t:13}],n:51,l:1},{n:"class-macro",t:13,f:[{t:2,r:".macro"}]},{t:4,f:[{n:"style",f:[{t:2,x:{r:["@this","."],s:"_0.calcMargin(_1)"}}],t:13}],n:50,r:".margin"},{t:4,f:[{n:"style",f:[{t:2,x:{r:["@this","."],s:"_0.calcBorder(_1)"}}],t:13}],n:50,r:".border"},{t:4,f:[{n:"style",f:[{t:2,x:{r:["@this","."],s:"_0.calcFont(_1)"}}],t:13}],n:50,r:".font"},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.clickWidget((_1))]"}}],f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"remove btn",g:1},{n:"title",f:["Remove ",{t:2,r:".type"}],t:13},{n:["click"],t:70,f:{r:["@this","@context"],s:"[_0.removeWidget((_1),false)]"}}],f:[{t:8,r:"times"}]}],n:50,x:{r:["../"],s:"Array.isArray(_0)"}}," ",{t:8,r:".type"}]}],n:54,z:[{n:"widthMargin",x:{x:{r:["@this",".","@context"],s:"_0.calcWidthWithMargin(_1,(_2))"}}},{n:"heightMargin",x:{x:{r:["@this","."],s:"_0.calcHeightWithMargin(_1)"}}}]}]}};
    const css$1 = function(data) { return [(function () { return this.Ractive({ template: {v:4,t:["h3 { padding: 0.5rem; margin: 0; } input, select, textarea { font-size: 0.875rem; } .raport-wrapper { font-family: sans-serif; } .left-bar { position: absolute; left: 0; width: 2rem; top: 0; bottom: 0; z-index: 20; background-color: ",{t:2,r:"@style.bg"},"; display: flex; flex-direction: column; padding-top: 0.5rem; align-items: center; } .left-bar .ico { margin-bottom: 1.5rem; } .ico.off svg { opacity: 0.3; } .left-pop { transform: translateX(-105%); position: absolute; left: 2rem; top: 0; bottom: 0; z-index: 19 !important; transition: transform 0.2s ease-in-out; } .left-pop.popped { transform: translateX(0); } .top-bar { position: absolute; top: 0; left: 2rem; right: 0; height: 2.1rem; background-color: ",{t:2,r:"@style.bg"},"; color: ",{t:2,r:"@style.fg"},"; overflow-x: auto; } .top-bar > .actions { min-width: max-content; height: 2.1rem; } .bottom-bar { position: absolute; left: 2rem; right: 0; bottom: 0; height: 2rem; background-color: ",{t:2,r:"@style.bg"},"; z-index: 10; padding: 0 0.5rem; color: ",{t:2,r:"@style.fg"},"; overflow-x: auto; } .bottom-bar > .actions { min-width: max-content; } .proppop .top-bar.shrinkleft { left: ",{t:2,x:{r:["@style.leftwidth"],s:"(_0||28)+2"}},"rem; } .proppop .bottom-bar.shrinkleft { left: ",{t:2,x:{r:["@style.leftwidth"],s:"(_0||28)+2"}},"rem; } .proppop .center-pane.shrinkleft { left: ",{t:2,x:{r:["@style.leftwidth"],s:"(_0||28)+2"}},"rem; } .proppop .bottom-pane.shrinkleft { left: ",{t:2,x:{r:["@style.leftwidth"],s:"(_0||28)+2"}},"rem; } @media screen and (max-width: 60rem) { .left-pop { box-shadow: 0 0 1rem #000; } } .bottom-pop { position: absolute; left: 2rem; right: 0; z-index: 9 !important; bottom: 2rem; transform: translateY(-100%); transition: transform 0.2s ease-in-out; } .bottom-pop.popped { transform: translateY(0); } .center-pane { position: absolute; left: 2rem; right: 0; bottom: 2rem; top: 2.1rem; z-index: 5; } .center-pane.shrinkbottom { bottom: calc(",{t:2,x:{r:["@style.bottomheight"],s:"_0||33"}},"vh + 2rem); } button.plain { text-decoration: none; text-align: center; letter-spacing: 0.5px; cursor: pointer; user-select: none; border: none; border-radius: 0.2rem; padding: 0 1.25rem; box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2); transition: 0.2s ease-in-out; transition-property: box-shadow, opacity, background-color; font-size: 0.7rem; line-height: 1.5rem; background-color: ",{t:2,r:"@style.active"},"; color: ",{t:2,r:"@style.btntxt"},"; vertical-align: middle; min-height: 2.25rem; outline: 0; margin: 0.25rem; position: relative; overflow: hidden; -webkit-tap-highlight-color: transparent; font-family: inherit; } button.plain:hover { background-color: ",{t:2,r:"@style.hover"},"; } span.ico, button.ico { display: inline-block; border: none; background-color: transparent; cursor: pointer; outline: none; width: 1.2rem; height: 1.2rem; font-size: 0.8rem; margin-left: 0.1rem; box-sizing: content-box; color: ",{t:2,r:"@style.fg"},"; } span.ico svg, button.ico svg { fill: ",{t:2,r:"@style.fg"},"; stroke: ",{t:2,r:"@style.fg"},"; } span.ico.error svg, button.ico.error svg { fill: ",{t:2,r:"@style.error"},"; stroke: ",{t:2,r:"@style.error"},"; } button.ico.text { width: auto; } button.hide { border: none; width: 0; height: 0; padding: 0; outline: none; } button.ico:hover svg { fill: ",{t:2,r:"@style.hover"},"; } button.ico:hover { color: ",{t:2,r:"@style.hover"},"; } button.ico svg.pencil { stroke: ",{t:2,r:"@style.fg"},"; fill: none; } button.ico:hover svg.pencil { stroke: ",{t:2,r:"@style.hover"},"; fill: none; } button.ico.large { font-size: 1.5rem; width: 1.5rem; height: 1.5rem; padding: 0 0.5rem; } .properties button.ico.large { line-height: 1.5rem; } button.ico:disabled { color: ",{t:2,r:"@style.border"},"; cursor: default; } span.which { flex-grow: 0; flex-shrink: 1; white-space: nowrap; line-height: 1.5rem; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; cursor: pointer; } span.which button { flex-shrink: 0; } .raport-report { display: flex; flex-grow: 1; flex-shrink: 1; font-family: sans-serif; box-sizing: border-box; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; overflow: hidden; } button.add { width: 2rem; height: 2rem; line-height: 1em; text-align: center; border-radius: 2rem; background-color: ",{t:2,r:"@style.active"},"; color: ",{t:2,r:"@style.btntxt"},"; margin: 0.5rem; border: none; cursor: pointer; font-size: 1.5em; transition: background-color 0.2s ease-in-out; } button.add:hover { background-color: ",{t:2,r:"@style.hover"},"; } select { padding: 0.2rem; border-style: solid; border-width: 0 0 1px 0; background: none; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } .layout { display: flex; flex-direction: column; flex-grow: 2; flex-shrink: 1; box-sizing: border-box; overflow: hidden; } .layout.pad-me { padding-bottom: 32.5vh; } .layout > .tab { background-color: ",{t:2,r:"@style.dark"},"; font-size: 0.875rem; } .editor > .tab, .layout > .tab { flex-grow: 10; flex-shrink: 1; overflow: hidden; max-height: 0; } .editor > .active-tab, .layout > .active-tab { max-height: none; } .designer { display: flex; flex-direction: column; } .spacer { margin-right: 3em; } .actions { display: flex; align-items: center; z-index: 2; } .actions .tab { box-sizing: border-box; padding: 0.5em; margin: 0 0.5em; background-color: ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; border-style: solid; border-width: 1px 1px 0 1px; font-weight: bold; cursor: pointer; outline: none; border-color: ",{t:2,r:"@style.border"},"; font-size: 0.875rem; } .actions .tab:first-of-type { margin-left: 0; } .actions span.ico { vertical-align: sub; } .actions .center { margin: auto; font-family: sans-serif; font-size: 0.8em; margin-right: 1em; } .actions a { color: ",{t:2,r:"@style.fg"},"; text-decoration: none; } .actions .right { margin-left: auto; } .actions.design .tab { background-color: ",{t:2,r:"@style.bg"},"; border-color: ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; } .actions .tab.active { background-color: ",{t:2,r:"@style.dark"},"; color: ",{t:2,r:"@style.btntxt"},"; border: none; border-top: 2px solid ",{t:2,r:"@style.highlight"},"; margin-bottom: -1px; } .actions .tab.output-tab.active { background-color: ",{t:2,x:{r:["@style.out.dark","@style.dark"],s:"_0||_1"}},"; color: ",{t:2,x:{r:["@style.out.fg","@style.fg"],s:"_0||_1"}},"; } .bottom-pane .actions .tab { line-height: 1.3rem; } .bottom-pane .actions .tab.active { background-color: ",{t:2,r:"@style.bg"},"; border-color: ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; margin-bottom: -2px; border-style: solid; border-width: 1px; border-bottom-color: ",{t:2,r:"@style.bg"},"; border-top-width: 2px; border-top-color: ",{t:2,r:"@style.fg"},"; } .bottom-pane .actions button.error { color: ",{t:2,r:"@style.error"},"; } .bottom-pane .actions button.error svg { fill: ",{t:2,r:"@style.error"},"; } .bottom-pane .actions .tab.error { border-color: ",{t:2,r:"@style.error"},"; color: ",{t:2,r:"@style.btntxt"},"; background-color: ",{t:2,r:"@style.error"},"; } .bottom-pane .actions .tab.active.error { background-color: ",{t:2,r:"@style.bg"},"; color: ",{t:2,r:"@style.error"},"; border-bottom-color: ",{t:2,r:"@style.bg"},"; } .bottom-pane { position: absolute; left: 2rem; right: 0; bottom: 2rem; height: ",{t:2,x:{r:["@style.bottomheight"],s:"_0||33"}},"vh; overflow: hidden; flex-shrink: 0; display: flex; flex-direction: column; flex-grow: 0; box-sizing: border-box; background-color: ",{t:2,r:"@style.bg"},"; transform: translateY(105%); transition: transform 0.2s ease-in-out; z-index: 8; border-style: solid; border-color: ",{t:2,r:"@style.border"},"; border-width: 0 0 1px 1px; } .bottom-pane.max { height: calc(100vh - 2rem); } .bottom-pane.active { transform: translateY(0); border-top: 1px solid ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } .result { display: flex; flex-grow: 2; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } iframe { display: block; border: none; } .bar { height: 2rem; background-color: ",{t:2,r:"@style.dark"},"; color: ",{t:2,r:"@style.fg"},"; display: flex; align-items: center; font-size: 0.75rem; border-bottom: 1px solid ",{t:2,r:"@style.border"},"; box-sizing: border-box; padding: 0 0.25rem; user-select: none; transition: background-color 0.2s ease-in-out, opacity 0.2s ease-in-out; opacity: 0; position: absolute; width: 100%; top: -2rem; height: 2rem; left: 0; } .delimited.paper .bar { opacity: 1; } .delimited.paper .active-widget { border: none; background-color: ",{t:2,r:"@style.bg"},"; } .delimited.paper .active-widget > .bar { top: -4.5rem; left: -0.5rem; right: -0.5rem; width: auto; } .delimited.paper .hover-widget { margin-top: 2.5rem; background-color: ",{t:2,r:"@style.bg"},"; } .active-widget > .bar, .hover-widget > .bar, .bar.active, .bar.hover { opacity: 1; } .shiftKey.paper .widget .bar { pointer-events: none; } .bar * { margin: 0 0.5em 0 0; } .bar .name { color: ",{t:2,r:"@style.btntxt"},"; } .bar button, .bar .btn { background: none; color: #fff; border: none; cursor: pointer; font-size: inherit; padding: 0 0.5em; } .bar select { background: none; border: none; color: #fff; height: 1rem; font-size: 0.6rem; padding: 0; } div.widgets { display: flex; flex-wrap: wrap; align-content: flex-start; position: relative; height: min-content; width: calc(100% + 3px); left: -1.5px; background-position: 1.5rem 1.5rem; background-size: 1rem 1rem; z-index: 10; } div.widgets.manual { display: inline-block; } div.widget { cursor: pointer; display: block; border: 1px dotted rgba(0, 0, 0, 0.2); box-sizing: border-box; font-size: 0.83rem; position: relative; z-index: 10; } div.widgets.manual > .widget { float: left; } div.widgets.manual > .active-widget { cursor: move; } div.widget:hover { z-index: 1000; } div.active-widget { border-color: ",{t:2,r:"@style.active"},"; border-style: solid; background-color: ",{t:2,r:"@style.active"},"20; user-select: none; z-index: 999; } div.active-widget > .widgets, div.hover-widget > .widgets { background-image: linear-gradient(to top, ",{t:2,r:"@style.active"},"20, ",{t:2,r:"@style.active"},"20), radial-gradient(circle, ",{t:2,r:"@style.dark"}," 1px, transparent 1px); background-color: ",{t:2,r:"@style.bg"},"; } div.hover-widget { border-color: ",{t:2,r:"@style.hover"},"; border-style: solid; background-color: ",{t:2,r:"@style.hover"},"20; z-index: 888; } .active-widget > .bar, .bar.active { background-color: ",{t:2,r:"@style.active"}," !important; z-index: 999; } .hover-widget > .bar, .bar.hover { background-color: ",{t:2,r:"@style.hover"}," !important; z-index: 888; } .widget > .btn { position: absolute; right: 0; top: 0; opacity: 0; cursor: pointer; font-weight: bold; border-radius: 0.2rem; width: 0.9rem; height: 0.9rem; text-align: center; line-height: 0.9rem; font-size: 0.7rem; z-index: 10; } .widget > .preview.btn { right: 1.2rem; } .widget > .autosize.btn { right: 2.3rem; } .widget > .btn > svg { width: 100%; height: 100%; } .active-widget > .btn, .hover-widget > .btn { opacity: 1; } .label, .html { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .html .preview { font-size: 0.83rem; line-height: 1rem; white-space: normal; word-break: break-all; display: block; } .widget.image .content { display: flex; align-items: center; justify-content: space-around; font-size: 2em; font-weight: bold; overflow: hidden; } .widget > .content { display: block; height: 100%; } .sheet .toggles { margin-bottom: 0.5rem; } .toggle { font-size: 0.6rem; border: 1px dotted; padding: 0.2rem; border-radius: 0.2rem; display: inline-block; margin: 0.1em; line-height: 0.8rem; color: ",{t:2,r:"@style.fg"},"; cursor: pointer; user-select: none; } .toggle.active { border: 1px solid; color: ",{t:2,r:"@style.highlight"},"; } .sides { display: flex; flex-wrap: wrap; width: 12rem; margin: 0.5rem; } .properties .sheet .sides > input { width: 3rem; margin: 0.5rem 0.5rem; box-sizing: border-box; color: ",{t:2,r:"@style.fg"},"; background: transparent; } .sides .square { width: 4rem; height: 4rem; background-color: ",{t:2,r:"@style.active"},"; border: 1px solid; box-sizing: border-box; } .sides span { width: 4rem; height: 0.1rem; display: inline-block; } .shrinky { flex-shrink: 200; flex-grow: 1; } .growy { flex-grow: 100; flex-shrink: 1; } .scrolled-wrapper { position: relative; overflow: hidden; min-height: 4em; display: flex; flex-direction: column; } .scrolled { height: 100%; overflow: auto; } .scrolled:before, .scrolled:after { content: ' '; display: block; position: absolute; z-index: 2; box-shadow: 0px 0px 10px ",{t:2,x:{r:["@style.theme"],s:"_0===\"dark\"?\"#265189\":\"rgb(0, 0, 0, 0.5)\""}},"; height: 5px; width: 100%; opacity: 1; transition: opacity 0.25s ease-in-out; } .scrolled:before { top: -5px; } .scrolled:after { bottom: -5px; } .scrolled.scroll-top:before { opacity: 0; transition: opacity 0s linear; } .scrolled.scroll-bottom:after { opacity: 0; transition: opacity 0s linear; } @media screen and (max-width: 72em) { .bottom-pane .bottom .ops { display: none; } } @media screen and (max-width: 48em) { .bottom-pane .bottom .context { display: none; } }"],e:{"(_0||28)+2":function (_0){return((_0||28)+2);},"_0||33":function (_0){return(_0||33);},"_0||_1":function (_0,_1){return(_0||_1);},"_0===\"dark\"?\"#265189\":\"rgb(0, 0, 0, 0.5)\"":function (_0){return(_0==="dark"?"#265189":"rgb(0, 0, 0, 0.5)");}}}, data: this.cssData }).fragment.toString(false); }).call(this), (function () { return this.Ractive({ template: {v:4,t:[".tab.data-import { display: flex; flex-direction: column; } .import.paper { flex-grow: 1; display: flex; flex-direction: column; max-height: calc(100% - 2em); } .import .definition { display: flex; flex-direction: column; max-height: 100%; } .import .fetch { margin: 1em 0 2em; max-height: 40%; flex-grow: 0; flex-shrink: 1; } label.input, label.check { display: inline-block; } label.check { padding-top: 1rem; } label.input input, label.input select { display: block; height: 2.5rem; width: 100%; padding: 0.5rem; box-sizing: border-box; margin: 0; border: 1px solid ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; border-radius: 0; font-size: 0.875rem; } label.area { display: block; padding: 0.25rem; } label.area.grow { display: flex; flex-direction: column; flex-grow: 1; } label.area textarea { display: block; min-height: 11rem; width: 100%; padding: 0.5rem; box-sizing: border-box; border: 1px solid ",{t:2,r:"@style.border"},"; margin: 0; border-radius: 0; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; font-size: 0.875rem; } label.area.grow textarea { flex-grow: 1; } label.check input { height: 2rem; vertical-align: middle; }"]}, data: this.cssData }).fragment.toString(false); }).call(this), (function () { return this.Ractive({ template: {v:4,t:[".project { display: flex; flex-grow: 1; flex-direction: column; } .active-tab .project { min-height: 75vh; } .settings-pane { display: flex; flex-direction: column; flex-grow: 0; flex-shrink: 0; } .settings-pane-inner { padding: 0.5rem; margin-bottom: 1em; border-bottom: 1px solid; } .project-pane { display: flex; flex-grow: 1; padding: 0.5rem; position: relative; flex-wrap: wrap; } .project-pane-left { flex-grow: 1; flex-shrink: 1; padding-right: 1rem; display: flex; flex-direction: column; box-sizing: border-box; } @media screen and (min-width: 48rem) { .project-pane-left { max-width: calc(100% - 15rem); } } .project-pane-right { width: 15rem; display: flex; flex-direction: column; flex-shrink: 0; margin-top: 0.5rem; } .project-list { flex-grow: 1; border: 1px solid ",{t:2,r:"@style.border"},"; overflow-y: auto; } .project-item { padding: 0.25rem 0.5rem; min-height: 1.5rem; line-height: 1.5rem; cursor: pointer; } .active-project { background-color: ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; cursor: default; } label.input { display: inline-block; margin: 0 1em 1em 0; }"]}, data: this.cssData }).fragment.toString(false); }).call(this), (function () { return this.Ractive({ template: {v:4,t:[".report-definition .paper { flex-grow: 1; display: flex; flex-direction: column; } .tab.report-definition { display: flex; flex-direction: column; } .definition { display: flex; flex-direction: column; flex-grow: 1; } .definition .json, .definition .extra-context { display: flex; flex-direction: column; flex-grow: 1; height: 10em; border: 1px solid ",{t:2,r:"@style.border"},"; } .definition .json > *, .definition .extra-context > * { flex-grow: 1; } .definition .json textarea, .definition .extra-context textarea { flex-shrink: 0; flex-grow: 1; width: 100%; box-sizing: border-box; min-height: 99%; border: none; outline: none; font-size: 0.875rem; } .definition .json textarea { color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; }"]}, data: this.cssData }).fragment.toString(false); }).call(this), " .report-context .paper { flex-grow: 1; display: flex; flex-direction: column; } .tab.report-context { display: flex; flex-direction: column; }", (function () { return this.Ractive({ template: {v:4,t:[".paper { background-color: ",{t:2,r:"@style.bg"},"; color: ",{t:2,r:"@style.fg"},"; position: relative; user-select: none; } .report-paper.bar { background-color: ",{t:2,r:"@style.border"},"; opacity: 1; } .delimited.paper { padding: 0.5rem; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } @media screen and (min-width: 48rem) { .delimited.paper { margin: 1rem; } } .delimited .children.fields { display: flex; flex-wrap: wrap; } .field { display: flex; border: 1px solid ",{t:2,r:"@style.border"},"; margin: 0.25rem; padding: 0.25rem; } .field span { display: inline-block; width: 15em; min-height: 1em; max-height: 6em; word-break: break-all; white-space: pre-wrap; overflow: hidden; } .field.active-expr { background-color: ",{t:2,r:"@style.active"},"20; border-color: ",{t:2,r:"@style.active"},"; } .field.hover-expr { background-color: ",{t:2,r:"@style.hover"},"20; border-color: ",{t:2,r:"@style.hover"},"; } .widget span.btn { background-color: ",{t:2,r:"@style.fg"},"; color: ",{t:2,r:"@style.bg"},"; } .widget span.btn svg { fill: ",{t:2,r:"@style.bg"},"; } .widget .bar span.btn { background-color: transparent; color: ",{t:2,r:"@style.btntxt"},"; } .widget.container > .remove.btn { top: -1.5rem; right: 0.5rem; z-index: 1000; } .widget.container.macro > .remove.btn { top: 0; right: 0; } .break { width: 100%; }"]}, data: this.cssData }).fragment.toString(false); }).call(this), " .unit { font-size: 0.6rem; margin-left: 1em; }", (function () { return this.Ractive({ template: {v:4,t:[".bottom-pane pre { margin: 0; } .bottom-pane .top { display: flex; flex-shrink: 0; flex-grow: 0; box-sizing: border-box; height: 2.5em; font-size: 0.75rem; align-items: end; } .bottom-pane .bottom { display: flex; flex-grow: 1; flex-shrink: 1; overflow: hidden; height: 100%; } .bottom-pane .bottom > .tab { display: flex; flex-grow: 0; border: none; display: none; overflow: auto; } .bottom-pane .bottom > .active-tab { flex-grow: 1; display: flex; } .bottom-pane .context, .bottom-pane .ops { margin: 0.2em; width: 25%; max-width: 20em; flex-shrink: 0; display: flex; flex-direction: column; } .bottom-pane .context .panel, .bottom-pane .ops .panel { border: 1px solid ",{t:2,r:"@style.border"},"; flex-grow: 1; } .bottom-pane .context .header, .bottom-pane .ops .header { flex-wrap: wrap; font-weight: bold; display: flex; justify-content: space-evenly; line-height: 2.2em; font-size: 0.85rem; } .bottom-pane .editor { flex-grow: 2; display: flex; flex-direction: column; padding: 0.25rem; box-sizing: border-box; } .bottom-pane textarea { width: 100%; box-sizing: border-box; padding: 0.5em; min-height: 99%; border: none; outline: none; font-size: 1em; } .bottom-pane .properties textarea, .bottom-pane .properties select, .bottom-pane input { color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; border: 1px solid ",{t:2,r:"@style.border"},"; } .bottom-pane .properties textarea { min-height: 7em; } .bottom-pane .active-tab { border: 1px solid ",{t:2,r:"@style.border"},"; } .bottom-pane .editor .tab { display: flex; flex-direction: column; } .bottom-pane .ast.tab { word-wrap: anywhere; word-break: break-all; } .bottom-pane .ast.tab.error { border-color: ",{t:2,r:"@style.error"},"; } .bottom-pane .tab.html .scrolled { display: flex; flex-direction: column; } .bottom-pane .tab.result .scrolled { padding: 0.5rem; } .bottom-pane .tab.html, .bottom-pane .tab.result { display: flex; flex-direction: column; } .bottom-pane .tab .editor-buttons { display: flex; flex-shrink: 0; padding: 0.2rem; border-bottom: 1px solid ",{t:2,r:"@style.border"},"; } .bottom-pane .tab.html button { border: none; background-color: transparent; padding: 0.25rem; cursor: pointer; outline: none; } .bottom-pane .tab.html button:hover { color: ",{t:2,r:"@style.active"},"; } .bottom-pane .tab.html button.skip { margin-left: 1rem; } .bottom-pane .html-editor { padding: 0.5rem; flex-grow: 1; flex-shrink: 1; white-space: pre-wrap; word-wrap: anywhere; word-break: break-all; } .bottom-pane pre { white-space: pre-wrap; word-break: break-all; } .bottom-pane .properties { flex-direction: column; flex-wrap: wrap; align-content: flex-start; } .bottom-pane .properties > label { width: 20em; margin: 0 0.5rem; padding: 0.5rem 0; } .bottom-pane .options label { display: inline-block; } .bottom-pane .options label > span:first-of-type { font-size: 0.8rem; } .bottom-pane .properties > label > span:first-of-type { font-size: 0.8rem; display: flex; align-items: center; } .bottom-pane .options { box-sizing: border-box; padding: 0.5rem; border: 1px solid ",{t:2,r:"@style.border"},"; overflow: hidden; display: flex; flex-direction: column; } .bottom-pane .group-edit { display: flex; align-items: center; } .ast-node { margin-left: 0.5em; display: flex; cursor: pointer; min-height: 2em; border: 1px solid transparent; } .ast-node input, .ast-node select { border: 1px solid rgba(0, 0, 0, 0.15); background-color: ",{t:2,r:"@style.bg"},"; padding: 0.2em; } .ast-content { display: flex; flex-direction: column; flex-grow: 1; } .ast-active-node { background-color: ",{t:2,r:"@style.active"},"20; border: 1px solid ",{t:2,r:"@style.active"},"; cursor: default; } .ast-string:before, .ast-string:after { content: '\"'; } .ast-number { font-family: mono; } .ast-op-name, .ast-content-value, .ast-content-ref { display: flex; justify-content: space-between; } .entry-local .entry-name { font-style: italic; } .entry-details { display: flex; justify-content: space-between; } .entry-type { opacity: 0.6; padding: 0 0.5em; } .entry-details button { text-align: left; padding: 0; background: none; border: none; margin: 0; font-size: 1rem; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } .entry-details button.expand { margin-left: -1em; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; border: 1px solid ",{t:2,r:"@style.border"},"; width: 1em; height: 1em; text-align: center; line-height: 0.6em; } .context-entry { padding-left: 0.5em; border-left: 1px dotted ",{t:2,r:"@style.border"},"; margin-left: 1em; } .context-entry .context-entry { margin-left: 0.5em; } .context-entry > .context-entry { display: none; } .context-entry.expanded > .context-entry { display: block; } .expr-operator, .context-entry { cursor: pointer; } .entry-details .expr-operator { padding: 0 0.5em; } .label-part { padding: 0.25em; margin: 0.25em; border: 1px solid; border-radius: 0.2em; } .label-part code { background-color: ",{t:2,r:"@style.bg"},"; color: ",{t:2,r:"@style.fg"},"; } .label-part input, .label-part label, .label-part select { font-size: 0.8rem; padding: 0.25em; border-radius: 0.2rem; margin: 0.25em; vertical-align: middle; border: 1px solid ",{t:2,r:"@style.border"},"; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } .label-part input[type=number] { width: 8rem; } .label-part label { white-space: nowrap; } .option-entry { box-sizing: border-box; display: flex; margin-bottom: 0.5em; align-items: end; justify-content: space-between; } .option-entry > * { flex-shrink: 1; flex-grow: 1; margin: 0.2em; } .bottom-pane dt { margin-top: 1rem; font-family: monospace; } .bottom-pane dd { margin: 0.5em 0 1em 2em; white-space: pre-wrap; } .bottom-pane .ops-search { width: 10em; position: absolute; right: 2em; top: 0; background-color: ",{t:2,r:"@style.bg"},"; padding: 0.5rem; border: 1px solid ",{t:2,r:"@style.border"},"; border-radius: 0 0 0.5em 0.5em; border-top-width: 0; opacity: 0.2; transition: opacity 0.2s ease-in-out; } .bottom-pane .ops-search:hover { opacity: 1; }"]}, data: this.cssData }).fragment.toString(false); }).call(this), (function () { return this.Ractive({ template: {v:4,t:[".parameters { display: flex; flex-direction: column; width: 100%; height: 100%; box-sizing: border-box; } .param { width: 18rem; margin: 0.5rem; break-inside: avoid; } .param label { width: 100%; } .param label input, .param label select { display: block; width: 100%; box-sizing: border-box; padding: 0.5rem; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; } .param label.check input { width: auto; display: inline-block; vertical-align: middle; padding: 0; } .param-editor { display: flex; flex-direction: column; flex-wrap: wrap; width: 100%; height: 100%; align-content: start; overflow: auto; }"]}, data: this.cssData }).fragment.toString(false); }).call(this), (function () { return this.Ractive({ template: {v:4,t:[".properties { width: ",{t:2,x:{r:["@style.leftwidth"],s:"_0||28"}},"rem; flex-grow: 0; flex-shrink: 0; border: 1px solid ",{t:2,r:"@style.border"},"; border-width: 0 1px; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; display: flex; flex-direction: column; z-index: 1999; } .properties-pull { display: none; } .placeholder { flex-grow: 1; align-items: center; display: flex; justify-content: center; font-size: 1.7rem; color: #aaa; } .properties .header { display: flex; flex: 1 1 auto; flex-grow: 0; flex-shrink: 0; align-items: center; margin-top: 1em; } .properties .header:first-of-type { margin-top: 0; } .properties .header h3 { flex-grow: 5; } .properties .tree { overflow-y: auto; } .properties .tree .children { margin-left: 0.5em; padding-left: 0.5em; border-left: 1px dotted ",{t:2,r:"@style.border"},"; } .properties .tree .node { color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; cursor: pointer; position: relative; transition: background-color 0.2s ease-in-out; z-index: 1; user-select: none; } .properties .tree .node.active > .line { background-color: ",{t:2,r:"@style.active"},"; color: ",{t:2,r:"@style.btntxt"},"; } .properties .tree .node.active { background-color: ",{t:2,r:"@style.active"},"20; } .properties .tree .node.hover > .children > .node { background-color: ",{t:2,r:"@style.hover"},"20; } .properties .tree .node .line { display: flex; align-items: center; padding: 0.1rem 0.25rem; margin: 0.1rem; min-height: 2rem; transition: background-color 0.2s ease-in-out; background-color: ",{t:2,r:"@style.bg"},"; z-index: 10; } .properties .tree .node.hover > .line { background-color: ",{t:2,r:"@style.hover"},"; color: #fff; } .properties .tree .node.moving > .line { background-color: #8061ee; color: #fff; } .properties .tree .node .line span { flex-grow: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .properties .tree .node.active > .line button, .properties .tree .node .line:hover button, .properties .tree .node.hover > .line button { color: #fff; } .properties .tree .node.active > .line button:disabled, .properties .tree .node .line:hover button:disabled, .properties .tree .node.hover > .line button:disabled { color: #ccc; cursor: default; } .properties .sheet { display: table; border-collapse: collapse; width: 100%; box-sizing: border-box; } .properties .sheet > label { display: table-row; } .properties .sheet > label > * { display: table-cell; line-height: 1rem; padding: 0.4rem; vertical-align: middle; border-style: solid; border-width: 1px 0; border-color: ",{t:2,r:"@style.border"},"; } .properties .sheet > label > *:first-of-type { border-width: 1px 1px 1px 0; } .properties .sheet > label > *:first-of-type > * { vertical-align: middle; } .properties .sheet input, .properties .sheet select { border: none; padding: 0; margin: 0; width: 100%; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.bg"},"; outline: none; } .properties .sheet textarea { border: none; width: 100%; height: 100%; margin: -0.2rem; padding: 0; box-sizing: border-box; outline: none; } .properties .sheet label:focus-within { background-color: transparent; color: ",{t:2,r:"@style.fg"},"; } .parameter, .src { display: flex; border-bottom: 1px solid ",{t:2,r:"@style.border"},"; } .parameter:focus-within, .src:focus-within { background-color: ",{t:2,r:"@style.border"},"; } .parameter.head, .src.head { border-top: 1px solid ",{t:2,r:"@style.border"},"; font-weight: bold; } .parameter > *, .src > * { border-left: 1px solid ",{t:2,r:"@style.border"},"; padding: 0.2rem; flex-grow: 0; flex-shrink: 0; box-sizing: border-box; } .parameter > *:first-of-type, .src > *:first-of-type { border-left: none; } .parameter input:not([type=checkbox]), .parameter select, .src input:not([type=checkbox]), .src select { width: 100%; height: 100%; border: none; background-color: ",{t:2,r:"@style.bg"},"; color: ",{t:2,r:"@style.fg"},"; } .param-name { width: 40%; } .param-type { width: 30%; } .param-require { width: 19%; text-align: center; } .param-btn { width: 10%; } .src-name { width: 65%; } .rsrc-name { width: 43%; } .rsrc-src { width: 43%; } .src-btn { width: 35%; display: flex; justify-content: space-around; } .rsrc-btn { width: 14%; }"],e:{"_0||28":function (_0){return(_0||28);}}}, data: this.cssData }).fragment.toString(false); }).call(this), (function () { return this.Ractive({ template: {v:4,t:["@media screen and (min-height: 10em) { .tree .line { position: sticky; top: 0; } .tree .line.level1 { top: 2.2em; } } @media screen and (min-height: 15em) { .tree .line.level2 { top: 4.4em; } .tree .line.level3 { top: 6.6em; } } @media screen and (min-height: 20em) { .tree .line.level4 { top: 8.8em; } .tree .line.level5 { top: 11em; } } @media screen and (min-height: 25em) { .tree .line.level6 { top: 13.2em; } .tree .line.level7 { top: 15.4em; } } @media screen and (min-height: 30em) { .tree .line.level8 { top: 17.6em; } } .line .actions { display: none; position: absolute; right: 3rem; background-color: inherit; } .line:hover .actions { display: flex; } button.ico svg { width: 100%; height: 100%; border-radius: 0.2rem; transition: transform 0.2s ease-in-out 0.3s; } .line button.ico { flex-shrink: 0; } .line button.ico.expander { position: absolute; left: -1.35em; opacity: 0.5; border: 0px solid; transition: border-width 0.2s ease; width: 0.75em; text-align: center; padding: 0 0.2em; } .line button.ico.expander:hover { border-width: 1px; } .properties .tree .node.hover > .line button.ico { color: ",{t:2,r:"@style.bg"},"; } .properties .tree .node.hover > .line button.ico:hover { color: ",{t:2,r:"@style.fg"},"; } .line button.ico svg, .line button.ico.remove:hover svg, .hover .line .actions button.ico svg { fill: ",{t:2,r:"@style.bg"},"; } .line button.ico.field svg, .line button.ico.remove svg { fill: ",{t:2,r:"@style.fg"},"; } .line button.ico.field[disabled] svg { fill: ",{t:2,r:"@style.dark"},"; } .line button.ico.field:hover svg { fill: ",{t:2,r:"@style.bg"},"; } .hover .line .actions button.ico:hover svg, .line button.ico:hover svg { fill: ",{t:2,r:"@style.fg"},"; } span.widget-id { display: inline-block; overflow: hidden; text-overflow: ellipsis; vertical-align: bottom; max-width: 20%; font-weight: bold; opacity: 0.5; } span.widget-info { display: inline; overflow: hidden; text-overflow: ellipsis; vertical-align: bottom; padding-left: 0.5em; max-width: 85%; opacity: 0.7; } button.ico[disabled] svg, button.ico[disabled]:hover svg { fill: gray; } button.ico.up-arrow svg { transform: rotate(180deg); } button.ico.left-arrow svg { transform: rotate(90deg); } button.ico.right-arrow svg { transform: rotate(270deg); }"]}, data: this.cssData }).fragment.toString(false); }).call(this)].join(' '); };

    /*
    	Ractive.js v1.4.2
    	Build: d08f9e0d50cdd62c3c44a94944852b81d1c95972
    	Date: Fri Mar 10 2023 19:12:23 GMT-0500 (Eastern Standard Time)
    	Website: https://ractive.js.org
    	License: MIT
    */
    /* istanbul ignore if */
    if (!Object.assign) {
      Object.assign = function(target) {
        var sources = [], len = arguments.length - 1;
        while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

        if (target == null) { throw new TypeError('Cannot convert undefined or null to object'); }

        var to = Object(target);
        var sourcesLength = sources.length;

        for (var index = 0; index < sourcesLength; index++) {
          var nextSource = sources[index];
          for (var nextKey in nextSource) {
            if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { continue; }
            to[nextKey] = nextSource[nextKey];
          }
        }

        return to;
      };
    }

    function hasOwn(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    function fillGaps(target) {
      var sources = [], len = arguments.length - 1;
      while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

      for (var i = 0; i < sources.length; i++) {
        var source = sources[i];
        for (var key in source) {
          // Source can be a prototype-less object.
          if (key in target || !hasOwn(source, key)) { continue; }
          target[key] = source[key];
        }
      }

      return target;
    }

    function toPairs(obj) {
      if ( obj === void 0 ) obj = {};

      var pairs = [];
      for (var key in obj) {
        // Source can be a prototype-less object.
        if (!hasOwn(obj, key)) { continue; }
        pairs.push([key, obj[key]]);
      }
      return pairs;
    }

    var obj = Object;

    var assign = obj.assign;

    var create = obj.create;

    var defineProperty = obj.defineProperty;

    var defineProperties = obj.defineProperties;

    var keys = obj.keys;

    var toString = Object.prototype.toString;


    var isArray = Array.isArray;

    function isEqual(a, b) {
      if (a === null && b === null) {
        return true;
      }

      if (isObjectType(a) || isObjectType(b)) {
        return false;
      }

      return a === b;
    }

    // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
    function isNumeric(thing) {
      return !isNaN(parseFloat(thing)) && isFinite(thing);
    }

    function isObject(thing) {
      return thing && toString.call(thing) === '[object Object]';
    }

    function isObjectLike(thing) {
      return !!(thing && (isObjectType(thing) || isFunction(thing))) && !isDate(thing);
    }

    function isDate(thing) {
      return thing instanceof Date;
    }

    function isObjectType(thing) {
      return typeof thing === 'object';
    }

    function isFunction(thing) {
      return typeof thing === 'function';
    }

    function isString(thing) {
      return typeof thing === 'string';
    }

    function isNumber(thing) {
      return typeof thing === 'number';
    }

    function isUndefined(thing) {
      return thing === undefined;
    }

    /* istanbul ignore if */
    if (!Array.prototype.find) {
      defineProperty(Array.prototype, 'find', {
        value: function value(callback, thisArg) {
          if (this === null || isUndefined(this))
            { throw new TypeError('Array.prototype.find called on null or undefined'); }

          if (!isFunction(callback)) { throw new TypeError((callback + " is not a function")); }

          var array = Object(this);
          var arrayLength = array.length >>> 0;

          for (var index = 0; index < arrayLength; index++) {
            if (!hasOwn(array, index)) { continue; }
            if (!callback.call(thisArg, array[index], index, array)) { continue; }
            return array[index];
          }

          return undefined;
        },
        configurable: true,
        writable: true
      });
    }

    // NOTE: Node doesn't exist in IE8. Nothing can be done.
    /* istanbul ignore if */
    if (
      typeof window !== 'undefined' &&
      window.Node &&
      window.Node.prototype &&
      !window.Node.prototype.contains
    ) {
      Node.prototype.contains = function(node) {
        var this$1 = this;

        if (!node) { throw new TypeError('node required'); }

        do {
          if (this$1 === node) { return true; }
        } while ((node = node && node.parentNode));

        return false;
      };
    }

    /* istanbul ignore if */
    if (typeof window !== 'undefined' && window.performance && !window.performance.now) {
      window.performance = window.performance || {};

      var nowOffset = Date.now();

      window.performance.now = function() {
        return Date.now() - nowOffset;
      };
    }

    /* eslint no-console:"off" */
    var win = typeof window !== 'undefined' ? window : null;
    var doc = win ? document : null;
    var isClient = !!doc;
    var base = typeof global !== 'undefined' ? global : win;
    var hasConsole =
      typeof console !== 'undefined' && isFunction(console.warn) && isFunction(console.warn.apply);

    var svg = doc
      ? doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')
      : false;

    var vendors = ['o', 'ms', 'moz', 'webkit'];

    /* istanbul ignore if */
    if (!base.Promise) {
      var PENDING = {};
      var FULFILLED = {};
      var REJECTED = {};

      var Promise$1 = (base.Promise = function(callback) {
        var fulfilledHandlers = [];
        var rejectedHandlers = [];
        var state = PENDING;
        var result;
        var dispatchHandlers;

        var makeResolver = function (newState) {
          return function(value) {
            if (state !== PENDING) { return; }
            result = value;
            state = newState;
            dispatchHandlers = makeDispatcher(
              state === FULFILLED ? fulfilledHandlers : rejectedHandlers,
              result
            );
            wait(dispatchHandlers);
          };
        };

        var fulfill = makeResolver(FULFILLED);
        var reject = makeResolver(REJECTED);

        try {
          callback(fulfill, reject);
        } catch (err) {
          reject(err);
        }

        return {
          // `then()` returns a Promise - 2.2.7
          then: function then(onFulfilled, onRejected) {
            var promise2 = new Promise$1(function (fulfill, reject) {
              var processResolutionHandler = function (handler, handlers, forward) {
                if (isFunction(handler)) {
                  handlers.push(function (p1result) {
                    try {
                      resolve$1(promise2, handler(p1result), fulfill, reject);
                    } catch (err) {
                      reject(err);
                    }
                  });
                } else {
                  handlers.push(forward);
                }
              };

              processResolutionHandler(onFulfilled, fulfilledHandlers, fulfill);
              processResolutionHandler(onRejected, rejectedHandlers, reject);

              if (state !== PENDING) {
                wait(dispatchHandlers);
              }
            });
            return promise2;
          },
          catch: function catch$1(onRejected) {
            return this.then(null, onRejected);
          },
          finally: function finally$1(callback) {
            return this.then(
              function (v) {
                callback();
                return v;
              },
              function (e) {
                callback();
                throw e;
              }
            );
          }
        };
      });

      Promise$1.all = function(promises) {
        return new Promise$1(function (fulfill, reject) {
          var result = [];
          var pending;
          var i;

          if (!promises.length) {
            fulfill(result);
            return;
          }

          var processPromise = function (promise, i) {
            if (promise && isFunction(promise.then)) {
              promise.then(function (value) {
                result[i] = value;
                --pending || fulfill(result);
              }, reject);
            } else {
              result[i] = promise;
              --pending || fulfill(result);
            }
          };

          pending = i = promises.length;

          while (i--) {
            processPromise(promises[i], i);
          }
        });
      };

      Promise$1.race = function(promises) {
        return new Promise$1(function (fulfill, reject) {
          var pending = true;
          function ok(v) {
            if (!pending) { return; }
            pending = false;
            fulfill(v);
          }
          function fail(e) {
            if (!pending) { return; }
            pending = false;
            reject(e);
          }
          for (var i = 0; i < promises.length; i++) {
            if (promises[i] && isFunction(promises[i].then)) {
              promises[i].then(ok, fail);
            }
          }
        });
      };

      Promise$1.resolve = function(value) {
        if (value && isFunction(value.then)) { return value; }
        return new Promise$1(function (fulfill) {
          fulfill(value);
        });
      };

      Promise$1.reject = function(reason) {
        if (reason && isFunction(reason.then)) { return reason; }
        return new Promise$1(function (fulfill, reject) {
          reject(reason);
        });
      };

      // TODO use MutationObservers or something to simulate setImmediate
      var wait = function(callback) {
        setTimeout(callback, 0);
      };

      var makeDispatcher = function(handlers, result) {
        return function() {
          for (var handler = (void 0); (handler = handlers.shift()); ) {
            handler(result);
          }
        };
      };

      var resolve$1 = function(promise, x, fulfil, reject) {
        var then;
        if (x === promise) {
          throw new TypeError("A promise's fulfillment handler cannot return the same promise");
        }
        if (x instanceof Promise$1) {
          x.then(fulfil, reject);
        } else if (x && (isObjectType(x) || isFunction(x))) {
          try {
            then = x.then;
          } catch (e) {
            reject(e);
            return;
          }
          if (isFunction(then)) {
            var called;

            var resolvePromise = function(y) {
              if (called) { return; }
              called = true;
              resolve$1(promise, y, fulfil, reject);
            };
            var rejectPromise = function(r) {
              if (called) { return; }
              called = true;
              reject(r);
            };

            try {
              then.call(x, resolvePromise, rejectPromise);
            } catch (e) {
              if (!called) {
                reject(e);
                called = true;
                return;
              }
            }
          } else {
            fulfil(x);
          }
        } else {
          fulfil(x);
        }
      };
    }

    /* istanbul ignore if */
    if (
      typeof window !== 'undefined' &&
      !(window.requestAnimationFrame && window.cancelAnimationFrame)
    ) {
      var lastTime = 0;
      window.requestAnimationFrame = function(callback) {
        var currentTime = Date.now();
        var timeToNextCall = Math.max(0, 16 - (currentTime - lastTime));
        var id = window.setTimeout(function () {
          callback(currentTime + timeToNextCall);
        }, timeToNextCall);
        lastTime = currentTime + timeToNextCall;
        return id;
      };
      window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
      };
    }

    var defaults = {
      // render placement:
      el: void 0,
      append: false,
      delegate: true,
      enhance: false,

      // template:
      template: null,

      // parse:
      allowExpressions: true,
      delimiters: ['{{', '}}'],
      tripleDelimiters: ['{{{', '}}}'],
      staticDelimiters: ['[[', ']]'],
      staticTripleDelimiters: ['[[[', ']]]'],
      csp: true,
      interpolate: false,
      preserveWhitespace: false,
      preserveStandaloneSections: false,
      sanitize: false,
      stripComments: true,
      contextLines: 0,

      // data & binding:
      data: create(null),
      helpers: create(null),
      computed: create(null),
      syncComputedChildren: false,
      resolveInstanceMembers: false,
      warnAboutAmbiguity: false,
      adapt: [],
      isolated: true,
      twoway: true,
      lazy: false,

      // transitions:
      noIntro: false,
      noOutro: false,
      transitionsEnabled: true,
      complete: void 0,
      nestedTransitions: true,

      // css:
      css: null,
      noCSSTransform: false
    };

    // These are a subset of the easing equations found at
    // https://raw.github.com/danro/easing-js - license info
    // follows:

    // --------------------------------------------------
    // easing.js v0.5.4
    // Generic set of easing functions with AMD support
    // https://github.com/danro/easing-js
    // This code may be freely distributed under the MIT license
    // http://danro.mit-license.org/
    // --------------------------------------------------
    // All functions adapted from Thomas Fuchs & Jeremy Kahn
    // Easing Equations (c) 2003 Robert Penner, BSD license
    // https://raw.github.com/danro/easing-js/master/LICENSE
    // --------------------------------------------------

    // In that library, the functions named easeIn, easeOut, and
    // easeInOut below are named easeInCubic, easeOutCubic, and
    // (you guessed it) easeInOutCubic.
    //
    // You can add additional easing functions to this list, and they
    // will be globally available.

    var easing = {
      linear: function linear(pos) {
        return pos;
      },
      easeIn: function easeIn(pos) {
        /* istanbul ignore next */
        return Math.pow(pos, 3);
      },
      easeOut: function easeOut(pos) {
        return Math.pow(pos - 1, 3) + 1;
      },
      easeInOut: function easeInOut(pos) {
        /* istanbul ignore next */
        if ((pos /= 0.5) < 1) {
          return 0.5 * Math.pow(pos, 3);
        }
        /* istanbul ignore next */
        return 0.5 * (Math.pow(pos - 2, 3) + 2);
      }
    };

    function noop() {}

    /* global console */
    /* eslint no-console:"off" */

    var alreadyWarned = {};
    var log;
    var printWarning;
    var welcome;

    if (hasConsole) {
      var welcomeIntro = [
        "%cRactive.js %c1.4.2 %cin debug mode, %cmore...",
        'color: rgb(114, 157, 52); font-weight: normal;',
        'color: rgb(85, 85, 85); font-weight: normal;',
        'color: rgb(85, 85, 85); font-weight: normal;',
        'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'
      ];
      var welcomeMessage = "You're running Ractive 1.4.2 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://ractive.js.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

      welcome = function () {
        if (Ractive.WELCOME_MESSAGE === false) {
          welcome = noop;
          return;
        }
        var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;
        var hasGroup = !!console.groupCollapsed;
        if (hasGroup) { console.groupCollapsed.apply(console, welcomeIntro); }
        console.log(message);
        if (hasGroup) {
          console.groupEnd(welcomeIntro);
        }

        welcome = noop;
      };

      printWarning = function (message, args) {
        welcome();

        // extract information about the instance this message pertains to, if applicable
        if (isObjectType(args[args.length - 1])) {
          var options = args.pop();
          var ractive = options ? options.ractive : null;

          if (ractive) {
            // if this is an instance of a component that we know the name of, add
            // it to the message
            var name;
            if (ractive.component && (name = ractive.component.name)) {
              message = "<" + name + "> " + message;
            }

            var node;
            if (
              (node =
                options.node || (ractive.fragment && ractive.fragment.rendered && ractive.find('*')))
            ) {
              args.push(node);
            }
          }
        }

        console.warn.apply(
          console,
          ['%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);'].concat(
            args
          )
        );
      };

      log = function() {
        console.log.apply(console, arguments);
      };
    } else {
      printWarning = log = welcome = noop;
    }

    function format(message, args) {
      return message.replace(/%s/g, function () { return args.shift(); });
    }

    function fatal(message) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      message = format(message, args);
      throw new Error(message);
    }

    function logIfDebug() {
      if (Ractive.DEBUG) {
        log.apply(null, arguments);
      }
    }

    function warn(message) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      message = format(message, args);
      printWarning(message, args);
    }

    function warnOnce(message) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      message = format(message, args);

      if (alreadyWarned[message]) {
        return;
      }

      alreadyWarned[message] = true;
      printWarning(message, args);
    }

    function warnIfDebug() {
      if (Ractive.DEBUG) {
        warn.apply(null, arguments);
      }
    }

    function warnOnceIfDebug() {
      if (Ractive.DEBUG) {
        warnOnce.apply(null, arguments);
      }
    }

    // Error messages that are used (or could be) in multiple places
    var badArguments = 'Bad arguments';
    var noRegistryFunctionReturn =
      'A function was specified for "%s" %s, but no %s was returned';
    var missingPlugin = function (name, type) { return ("Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://ractive.js.org/integrations/#" + type + "s"); };

    function findInViewHierarchy(registryName, ractive, name) {
      var instance = findInstance(registryName, ractive, name);
      return instance ? instance[registryName][name] : null;
    }

    function findInstance(registryName, ractive, name) {
      while (ractive) {
        if (name in ractive[registryName]) {
          return ractive;
        }

        if (ractive.isolated) {
          return null;
        }

        ractive = ractive.parent;
      }
    }

    function interpolate(from, to, ractive, type) {
      if (from === to) { return null; }

      if (type) {
        var interpol = findInViewHierarchy('interpolators', ractive, type);
        if (interpol) { return interpol(from, to) || null; }

        fatal(missingPlugin(type, 'interpolator'));
      }

      return (
        interpolators.number(from, to) ||
        interpolators.array(from, to) ||
        interpolators.object(from, to) ||
        null
      );
    }

    var interpolators = {
      number: function number(from, to) {
        if (!isNumeric(from) || !isNumeric(to)) {
          return null;
        }

        from = +from;
        to = +to;

        var delta = to - from;

        if (!delta) {
          return function() {
            return from;
          };
        }

        return function(t) {
          return from + t * delta;
        };
      },

      array: function array(from, to) {
        var len, i;

        if (!isArray(from) || !isArray(to)) {
          return null;
        }

        var intermediate = [];
        var interpolators = [];

        i = len = Math.min(from.length, to.length);
        while (i--) {
          interpolators[i] = interpolate(from[i], to[i]);
        }

        // surplus values - don't interpolate, but don't exclude them either
        for (i = len; i < from.length; i += 1) {
          intermediate[i] = from[i];
        }

        for (i = len; i < to.length; i += 1) {
          intermediate[i] = to[i];
        }

        return function(t) {
          var i = len;

          while (i--) {
            intermediate[i] = interpolators[i](t);
          }

          return intermediate;
        };
      },

      object: function object(from, to) {
        if (!isObject(from) || !isObject(to)) {
          return null;
        }

        var properties = [];
        var intermediate = {};
        var interpolators = {};

        var loop = function ( prop ) {
          if (hasOwn(from, prop)) {
            if (hasOwn(to, prop)) {
              properties.push(prop);
              interpolators[prop] = interpolate(from[prop], to[prop]) || (function () { return to[prop]; });
            } else {
              intermediate[prop] = from[prop];
            }
          }
        };

        for (var prop in from) loop( prop );

        for (var prop$1 in to) {
          if (hasOwn(to, prop$1) && !hasOwn(from, prop$1)) {
            intermediate[prop$1] = to[prop$1];
          }
        }

        var len = properties.length;

        return function(t) {
          var i = len;

          while (i--) {
            var prop = properties[i];

            intermediate[prop] = interpolators[prop](t);
          }

          return intermediate;
        };
      }
    };

    var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
    var splitPattern = /([^\\](?:\\\\)*)\./;
    var escapeKeyPattern = /\\|\./g;
    var unescapeKeyPattern = /((?:\\)+)\1|\\(\.)/g;

    function escapeKey(key) {
      if (isString(key)) {
        return key.replace(escapeKeyPattern, '\\$&');
      }

      return key;
    }

    function normalise(ref) {
      return ref ? ref.replace(refPattern, '.$1') : '';
    }

    function splitKeypath(keypath) {
      var result = [];
      var match;

      keypath = normalise(keypath);

      while ((match = splitPattern.exec(keypath))) {
        var index = match.index + match[1].length;
        result.push(keypath.substr(0, index));
        keypath = keypath.substr(index + 1);
      }

      result.push(keypath);

      return result;
    }

    function unescapeKey(key) {
      if (isString(key)) {
        return key.replace(unescapeKeyPattern, '$1$2');
      }

      return key;
    }

    function addToArray(array, value) {
      var index = array.indexOf(value);

      if (index === -1) {
        array.push(value);
      }
    }

    function arrayContains(array, value) {
      for (var i = 0, c = array.length; i < c; i++) {
        if (array[i] == value) {
          return true;
        }
      }

      return false;
    }

    function arrayContentsMatch(a, b) {
      var i;

      if (!isArray(a) || !isArray(b)) {
        return false;
      }

      if (a.length !== b.length) {
        return false;
      }

      i = a.length;
      while (i--) {
        if (a[i] !== b[i]) {
          return false;
        }
      }

      return true;
    }

    function ensureArray(x) {
      if (isString(x)) {
        return [x];
      }

      if (isUndefined(x)) {
        return [];
      }

      return x;
    }

    function lastItem(array) {
      return array[array.length - 1];
    }

    function removeFromArray(array, member) {
      if (!array) {
        return;
      }

      var index = array.indexOf(member);

      if (index !== -1) {
        array.splice(index, 1);
      }
    }

    function combine() {
      var arrays = [], len = arguments.length;
      while ( len-- ) arrays[ len ] = arguments[ len ];

      var res = arrays.concat.apply([], arrays);
      var i = res.length;
      while (i--) {
        var idx = res.indexOf(res[i]);
        if (~idx && idx < i) { res.splice(i, 1); }
      }

      return res;
    }

    function toArray(arrayLike) {
      var array = [];
      var i = arrayLike.length;
      while (i--) {
        array[i] = arrayLike[i];
      }

      return array;
    }

    function findMap(array, fn) {
      var len = array.length;
      for (var i = 0; i < len; i++) {
        var result = fn(array[i]);
        if (result) { return result; }
      }
    }

    function buildNewIndices(one, two, comparator) {
      var oldArray = one;
      var newArray = two;
      if (comparator) {
        oldArray = oldArray.map(comparator);
        newArray = newArray.map(comparator);
      }

      var oldLength = oldArray.length;

      var usedIndices = {};
      var firstUnusedIndex = 0;

      var result = oldArray.map(function (item) {
        var index;
        var start = firstUnusedIndex;

        do {
          index = newArray.indexOf(item, start);

          if (index === -1) {
            return -1;
          }

          start = index + 1;
        } while (usedIndices[index] === true && start < oldLength);

        // keep track of the first unused index, so we don't search
        // the whole of newArray for each item in oldArray unnecessarily
        if (index === firstUnusedIndex) {
          firstUnusedIndex += 1;
        }
        // allow next instance of next "equal" to be found item
        usedIndices[index] = true;
        return index;
      });

      var len = (result.oldLen = oldArray.length);
      result.newLen = newArray.length;

      if (len === result.newLen) {
        var i = 0;
        for (i; i < len; i++) {
          if (result[i] !== i) { break; }
        }

        if (i === len) { result.same = true; }
      }

      return result;
    }

    var fnBind = Function.prototype.bind;

    function bind(fn, context) {
      if (!/this/.test(fn.toString())) { return fn; }

      var bound = fnBind.call(fn, context);
      for (var prop in fn) { bound[prop] = fn[prop]; }

      return bound;
    }

    var shuffleTasks = { early: [], mark: [] };
    var registerQueue = { early: [], mark: [] };
    var noVirtual = { virtual: false };

    var ModelBase = function ModelBase(parent) {
      this.deps = [];

      this.children = [];
      this.childByKey = {};
      this.links = [];

      this.bindings = [];

      if (parent) {
        this.parent = parent;
        this.root = parent.root;
      }
    };
    var ModelBase__proto__ = ModelBase.prototype;

    ModelBase__proto__.addShuffleTask = function addShuffleTask (task, stage) {
        if ( stage === void 0 ) stage = 'early';

      shuffleTasks[stage].push(task);
    };
    ModelBase__proto__.addShuffleRegister = function addShuffleRegister (item, stage) {
        if ( stage === void 0 ) stage = 'early';

      registerQueue[stage].push({ model: this, item: item });
    };

    ModelBase__proto__.downstreamChanged = function downstreamChanged () {};

    ModelBase__proto__.findMatches = function findMatches (keys$$1) {
      var len = keys$$1.length;

      var existingMatches = [this];
      var matches;
      var i;

      var loop = function (  ) {
        var key = keys$$1[i];

        if (key === '*') {
          matches = [];
          existingMatches.forEach(function (model) {
            matches.push.apply(matches, model.getValueChildren(model.get()));
          });
        } else {
          matches = existingMatches.map(function (model) { return model.joinKey(key); });
        }

        existingMatches = matches;
      };

        for (i = 0; i < len; i += 1) loop(  );

      return matches;
    };

    ModelBase__proto__.getKeypath = function getKeypath (ractive) {
      if (ractive !== this.ractive && this._link) { return this._link.target.getKeypath(ractive); }

      if (!this.keypath) {
        var parent = this.parent && this.parent.getKeypath(ractive);
        this.keypath = parent
          ? ((this.parent.getKeypath(ractive)) + "." + (escapeKey(this.key)))
          : escapeKey(this.key);
      }

      return this.keypath;
    };

    ModelBase__proto__.getValueChildren = function getValueChildren (value) {
        var this$1 = this;

      var children;
      if (isArray(value)) {
        children = [];
        if ('length' in this && this.length !== value.length) {
          children.push(this.joinKey('length'));
        }
        value.forEach(function (m, i) {
          children.push(this$1.joinKey(i));
        });
      } else if (isObject(value) || isFunction(value)) {
        children = keys(value).map(function (key) { return this$1.joinKey(escapeKey(key)); });
      } else if (value != null) {
        children = [];
      }

      var computed = this.computed;
      if (computed) {
        children.push.apply(children, keys(computed).map(function (k) { return this$1.joinKey(k); }));
      }

      return children;
    };

    ModelBase__proto__.getVirtual = function getVirtual (shouldCapture) {
        var this$1 = this;

      var value = this.get(shouldCapture, { virtual: false });
      if (isObjectLike(value)) {
        var result = isArray(value) ? [] : create(null);

        var keys$$1 = keys(value);
        var i = keys$$1.length;
        while (i--) {
          var child = this$1.childByKey[keys$$1[i]];
          if (!child) { result[keys$$1[i]] = value[keys$$1[i]]; }
          else if (child._link) { result[keys$$1[i]] = child._link.getVirtual(); }
          else { result[keys$$1[i]] = child.getVirtual(); }
        }

        i = this.children.length;
        while (i--) {
          var child$1 = this$1.children[i];
          if (!(child$1.key in result) && child$1._link) {
            result[child$1.key] = child$1._link.getVirtual();
          }
        }

        if (this.computed) {
          keys$$1 = keys(this.computed);
          i = keys$$1.length;
          while (i--) {
            result[keys$$1[i]] = this$1.computed[keys$$1[i]].get();
          }
        }

        return result;
      } else { return value; }
    };

    ModelBase__proto__.has = function has (key) {
        var this$1 = this;

      if (this._link) { return this._link.has(key); }

      var value = this.get(false, noVirtual);
      if (!value) { return false; }

      key = unescapeKey(key);
      if ((isFunction(value) || isObject(value)) && key in value) { return true; }

      var computed = this.computed;
      if (computed && key in this.computed) { return true; }

      computed = this.root.ractive && this.root.ractive.computed;
      if (computed) {
        keys(computed).forEach(function (k) {
          if (computed[k].pattern && computed[k].pattern.test(this$1.getKeypath())) { return true; }
        });
      }

      return false;
    };

    ModelBase__proto__.joinAll = function joinAll (keys$$1, opts) {
      var model = this;
      for (var i = 0; i < keys$$1.length; i += 1) {
        if (
          opts &&
          opts.lastLink === false &&
          i + 1 === keys$$1.length &&
          model.childByKey[keys$$1[i]] &&
          model.childByKey[keys$$1[i]]._link
        )
          { return model.childByKey[keys$$1[i]]; }
        model = model.joinKey(keys$$1[i], opts);
      }

      return model;
    };

    ModelBase__proto__.notifyUpstream = function notifyUpstream (startPath) {
        var this$1 = this;

      var parent = this.parent;
      var path = startPath || [this.key];
      while (parent) {
        if (parent.patterns) { parent.patterns.forEach(function (o) { return o.notify(path.slice()); }); }
        path.unshift(parent.key);
        parent.links.forEach(function (l) { return l.notifiedUpstream(path, this$1.root); });
        parent.deps.forEach(function (d) { return d.handleChange(path); });
        parent.downstreamChanged(startPath);
        parent = parent.parent;
      }
    };

    ModelBase__proto__.rebind = function rebind (next, previous, safe) {
        var this$1 = this;

      if (this._link) {
        this._link.rebind(next, previous, false);
      }

      if (next === this) { return; }

      // tell the deps to move to the new target
      var i = this.deps.length;
      while (i--) {
        if (this$1.deps[i].rebind) { this$1.deps[i].rebind(next, previous, safe); }
      }

      i = this.links.length;
      while (i--) {
        var link = this$1.links[i];
        // only relink the root of the link tree
        if (link.owner && link.owner._link) { link.relinking(next, safe); }
      }

      i = this.children.length;
      while (i--) {
        var child = this$1.children[i];
        child.rebind(next ? next.joinKey(child.key) : undefined, child._link || child, safe);
        if (this$1.dataModel) {
          this$1.addShuffleTask(function () { return checkDataLink(this$1, this$1.retrieve()); }, 'early');
        }
      }

      i = this.bindings.length;
      while (i--) {
        this$1.bindings[i].rebind(next, previous, safe);
      }
    };

    ModelBase__proto__.reference = function reference () {
      'refs' in this ? this.refs++ : (this.refs = 1);
    };

    ModelBase__proto__.register = function register (dep) {
      this.deps.push(dep);
    };

    ModelBase__proto__.registerLink = function registerLink (link) {
      addToArray(this.links, link);
    };

    ModelBase__proto__.registerPatternObserver = function registerPatternObserver (observer) {
      (this.patterns || (this.patterns = [])).push(observer);
      this.register(observer);
    };

    ModelBase__proto__.registerTwowayBinding = function registerTwowayBinding (binding) {
      this.bindings.push(binding);
    };

    ModelBase__proto__.unreference = function unreference () {
      if ('refs' in this) { this.refs--; }
    };

    ModelBase__proto__.unregister = function unregister (dep) {
      removeFromArray(this.deps, dep);
    };

    ModelBase__proto__.unregisterLink = function unregisterLink (link) {
      removeFromArray(this.links, link);
    };

    ModelBase__proto__.unregisterPatternObserver = function unregisterPatternObserver (observer) {
      removeFromArray(this.patterns, observer);
      this.unregister(observer);
    };

    ModelBase__proto__.unregisterTwowayBinding = function unregisterTwowayBinding (binding) {
      removeFromArray(this.bindings, binding);
    };

    ModelBase__proto__.updateFromBindings = function updateFromBindings$1 (cascade) {
        var this$1 = this;

      var i = this.bindings.length;
      while (i--) {
        var value = this$1.bindings[i].getValue();
        if (value !== this$1.value) { this$1.set(value); }
      }

      // check for one-way bindings if there are no two-ways
      if (!this.bindings.length) {
        var oneway = findBoundValue(this.deps);
        if (oneway && oneway.value !== this.value) { this.set(oneway.value); }
      }

      if (cascade) {
        this.children.forEach(updateFromBindings);
        this.links.forEach(updateFromBindings);
        if (this._link) { this._link.updateFromBindings(cascade); }
      }
    };

    // TODO: this may be better handled by overriding `get` on models with a parent that isRoot
    function maybeBind(model, value, shouldBind) {
      if (shouldBind && isFunction(value) && model.parent && model.parent.isRoot) {
        if (!model.boundValue) {
          model.boundValue = bind(value._r_unbound || value, model.parent.ractive);
        }

        return model.boundValue;
      }

      return value;
    }

    function updateFromBindings(model) {
      model.updateFromBindings(true);
    }

    function findBoundValue(list) {
      var i = list.length;
      while (i--) {
        if (list[i].bound) {
          var owner = list[i].owner;
          if (owner) {
            var value = owner.name === 'checked' ? owner.node.checked : owner.node.value;
            return { value: value };
          }
        }
      }
    }

    function fireShuffleTasks(stage) {
      if (!stage) {
        fireShuffleTasks('early');
        fireShuffleTasks('mark');
      } else {
        var tasks = shuffleTasks[stage];
        shuffleTasks[stage] = [];
        var i = tasks.length;
        while (i--) { tasks[i](); }

        var register = registerQueue[stage];
        registerQueue[stage] = [];
        i = register.length;
        while (i--) { register[i].model.register(register[i].item); }
      }
    }

    function shuffle(model, newIndices, link, unsafe) {
      model.shuffling = true;

      var upstream = model.source().length !== model.source().value.length;
      var i = newIndices.length;
      while (i--) {
        var idx = newIndices[i];
        // nothing is actually changing, so move in the index and roll on
        if (i === idx) {
          continue;
        }

        upstream = true;

        // rebind the children on i to idx
        if (i in model.childByKey)
          { model.childByKey[i].rebind(
            !~idx ? undefined : model.joinKey(idx),
            model.childByKey[i],
            !unsafe
          ); }
      }

      model.links.forEach(function (l) { return l.shuffle(newIndices); });
      if (!link) { fireShuffleTasks('early'); }

      i = model.deps.length;
      while (i--) {
        if (model.deps[i].shuffle) { model.deps[i].shuffle(newIndices); }
      }

      model[link ? 'marked' : 'mark']();
      if (!link) { fireShuffleTasks('mark'); }

      if (upstream) { model.notifyUpstream(); }

      model.shuffling = false;
    }

    function checkDataLink(model, value) {
      if (value !== model.dataModel) {
        if (value && value.viewmodel && value.viewmodel.isRoot && model.childByKey.data) {
          model.childByKey.data.link(value.viewmodel, 'data');
          model.dataModel = value;
        } else if (model.dataModel) {
          model.childByKey.data.unlink();
          model.dataModel = true;
        }
      }
    }

    var stack = [];
    var captureGroup;

    function startCapturing() {
      stack.push((captureGroup = []));
    }

    function stopCapturing() {
      var dependencies = stack.pop();
      captureGroup = stack[stack.length - 1];
      return dependencies;
    }

    function capture(model) {
      if (captureGroup) {
        addToArray(captureGroup, model);
      }
    }

    function bind$1(x) {
      x.bind();
    }
    function cancel(x) {
      x.cancel();
    }
    function destroyed(x) {
      x.destroyed();
    }
    function handleChange(x) {
      x.handleChange();
    }
    function mark(x) {
      x.mark();
    }
    function markForce(x) {
      x.mark(true);
    }
    function marked(x) {
      x.marked();
    }
    function markedAll(x) {
      x.markedAll();
    }
    function render(x) {
      x.render();
    }
    function shuffled(x) {
      x.shuffled();
    }
    function teardown(x) {
      x.teardown();
    }
    function unbind(x) {
      x.unbind();
    }
    function unrender(x) {
      x.unrender();
    }

    function update(x) {
      x.update();
    }
    function toString$1(x) {
      return x.toString();
    }
    function toEscapedString(x) {
      return x.toString(true);
    }

    // this is the dry method of checking to see if a rebind applies to
    // a particular keypath because in some cases, a dep may be bound
    // directly to a particular keypath e.g. foo.bars.0.baz and need
    // to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted
    function rebindMatch(template, next, previous, fragment) {
      var keypath = template.r || template;

      // no valid keypath, go with next
      if (!keypath || !isString(keypath)) { return next; }

      // completely contextual ref, go with next
      if (
        keypath === '.' ||
        keypath[0] === '@' ||
        (next || previous).isKey ||
        (next || previous).isKeypath
      )
        { return next; }

      var parts = keypath.split('/');
      var keys = splitKeypath(parts[parts.length - 1]);
      var last = keys[keys.length - 1];

      // check the keypath against the model keypath to see if it matches
      var model = next || previous;

      // check to see if this was an alias
      if (model && keys.length === 1 && last !== model.key && fragment) {
        keys = findAlias(last, fragment) || keys;
      }

      var i = keys.length;
      var match = true;
      var shuffling = false;

      while (model && i--) {
        if (model.shuffling) { shuffling = true; }
        // non-strict comparison to account for indices in keypaths
        if (keys[i] != model.key) { match = false; }
        model = model.parent;
      }

      // next is undefined, but keypath is shuffling and previous matches
      if (!next && match && shuffling) { return previous; }
      else if (next && !match && shuffling)
        // next is defined, but doesn't match the keypath
        { return previous; }
      else { return next; }
    }

    function findAlias(name, fragment) {
      while (fragment) {
        var z = fragment.aliases;
        if (z && z[name]) {
          var aliases = (fragment.owner.iterations ? fragment.owner : fragment).owner.template.z;
          for (var i = 0; i < aliases.length; i++) {
            if (aliases[i].n === name) {
              var alias = aliases[i].x;
              if (!alias.r) { return false; }
              var parts = alias.r.split('/');
              return splitKeypath(parts[parts.length - 1]);
            }
          }
          return;
        }

        fragment = fragment.componentParent || fragment.parent;
      }
    }

    // temporary placeholder target for detached implicit links
    var Missing = {
      key: '@missing',
      animate: noop,
      applyValue: noop,
      get: noop,
      getKeypath: function getKeypath() {
        return this.key;
      },
      joinAll: function joinAll() {
        return this;
      },
      joinKey: function joinKey() {
        return this;
      },
      mark: noop,
      registerLink: noop,
      shufle: noop,
      set: noop,
      unregisterLink: noop
    };
    Missing.parent = Missing;

    var LinkModel = (function (ModelBase) {
      function LinkModel(parent, owner, target, key) {
        ModelBase.call(this, parent);

        this.owner = owner;
        this.target = target;
        this.key = isUndefined(key) ? owner.key : key;
        if (owner && owner.isLink) { this.sourcePath = (owner.sourcePath) + "." + (this.key); }

        if (target) { target.registerLink(this); }

        if (parent) { this.isReadonly = parent.isReadonly; }

        this.isLink = true;
      }

      if ( ModelBase ) LinkModel.__proto__ = ModelBase;
      var LinkModel__proto__ = LinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );
      LinkModel__proto__.constructor = LinkModel;

      LinkModel__proto__.animate = function animate (from, to, options, interpolator) {
        return this.target.animate(from, to, options, interpolator);
      };

      LinkModel__proto__.applyValue = function applyValue (value) {
        if (this.boundValue) { this.boundValue = null; }
        this.target.applyValue(value);
      };

      LinkModel__proto__.attach = function attach (fragment) {
        var model = resolveReference(fragment, this.key);
        if (model) {
          this.relinking(model, false);
        } else {
          // if there is no link available, move everything here to real models
          this.owner.unlink();
        }
      };

      LinkModel__proto__.detach = function detach () {
        this.relinking(Missing, false);
      };

      LinkModel__proto__.get = function get (shouldCapture, opts) {
        if ( opts === void 0 ) opts = {};

        if (shouldCapture) {
          capture(this);

          // may need to tell the target to unwrap
          opts.unwrap = 'unwrap' in opts ? opts.unwrap : true;
        }

        var bind = 'shouldBind' in opts ? opts.shouldBind : true;
        opts.shouldBind = this.mapping && this.target.parent && this.target.parent.isRoot;

        return maybeBind(this, this.target.get(false, opts), bind);
      };

      LinkModel__proto__.getKeypath = function getKeypath (ractive) {
        if (ractive && ractive !== this.root.ractive) { return this.target.getKeypath(ractive); }

        return ModelBase.prototype.getKeypath.call(this, ractive);
      };

      LinkModel__proto__.handleChange = function handleChange$1 () {
        this.deps.forEach(handleChange);
        this.links.forEach(handleChange);
        this.notifyUpstream();
      };

      LinkModel__proto__.isDetached = function isDetached () {
        return this.virtual && this.target === Missing;
      };

      LinkModel__proto__.joinKey = function joinKey (key) {
        // TODO: handle nested links
        if (isUndefined(key) || key === '') { return this; }

        if (!hasOwn(this.childByKey, key)) {
          var child = new LinkModel(this, this, this.target.joinKey(key), key);
          this.children.push(child);
          this.childByKey[key] = child;
        }

        return this.childByKey[key];
      };

      LinkModel__proto__.mark = function mark (force) {
        this.target.mark(force);
      };

      LinkModel__proto__.marked = function marked$1 () {
        if (this.boundValue) { this.boundValue = null; }

        this.links.forEach(marked);

        this.deps.forEach(handleChange);
      };

      LinkModel__proto__.markedAll = function markedAll$1 () {
        this.children.forEach(markedAll);
        this.marked();
      };

      LinkModel__proto__.notifiedUpstream = function notifiedUpstream (startPath, root) {
        var this$1 = this;

        this.links.forEach(function (l) { return l.notifiedUpstream(startPath, this$1.root); });
        this.deps.forEach(handleChange);
        if (startPath && this.rootLink) {
          var parent = this.parent;
          if (this.root !== root) {
            var path = startPath.slice(1);
            path.unshift(this.key);
            this.notifyUpstream(path);
          } else if (parent && parent !== this.target) {
            var path$1 = [parent.key, this.key];
            parent.links.forEach(function (l) { return l.notifiedUpstream(path$1, parent.root); });
            parent.deps.forEach(function (d) { return d.handleChange(path$1); });
            parent.notifyUpstream(path$1);
          }
        }
      };

      LinkModel__proto__.relinked = function relinked () {
        this.target.registerLink(this);
        this.children.forEach(function (c) { return c.relinked(); });
      };

      LinkModel__proto__.relinking = function relinking (target, safe) {
        var this$1 = this;

        if (this.rootLink && this.sourcePath)
          { target = rebindMatch(this.sourcePath, target, this.target); }
        if (!target || this.target === target) { return; }

        this.target && this.target.unregisterLink(this);

        this.target = target;
        this.children.forEach(function (c) {
          c.relinking(target.joinKey(c.key), safe);
        });

        if (!safe) { this.keypath = undefined; }

        if (this.rootLink)
          { this.addShuffleTask(function () {
            this$1.relinked();
            if (!safe) {
              this$1.markedAll();
              this$1.notifyUpstream();
            }
          }); }
      };

      LinkModel__proto__.set = function set (value) {
        if (this.boundValue) { this.boundValue = null; }
        this.target.set(value);
      };

      LinkModel__proto__.shuffle = function shuffle$1 (newIndices) {
        // watch for extra shuffles caused by a shuffle in a downstream link
        if (this.shuffling) { return; }

        // let the real model handle firing off shuffles
        if (!this.target.shuffling) {
          if (this.target.shuffle) {
            this.target.shuffle(newIndices);
          } else {
            // the target is a computation, which can't shuffle
            this.target.mark();
          }
        } else {
          shuffle(this, newIndices, true);
        }
      };

      LinkModel__proto__.source = function source () {
        if (this.target.source) { return this.target.source(); }
        else { return this.target; }
      };

      LinkModel__proto__.teardown = function teardown$3 () {
        if (this._link) { this._link.teardown(); }
        this.target.unregisterLink(this);
        this.children.forEach(teardown);
      };

      return LinkModel;
    }(ModelBase));

    ModelBase.prototype.link = function link(model, keypath, options) {
      var lnk = this._link || new LinkModel(this.parent, this, model, this.key);
      lnk.implicit = options && options.implicit;
      lnk.mapping = options && options.mapping;
      lnk.sourcePath = keypath;
      lnk.rootLink = true;
      if (this._link) { this._link.relinking(model, false); }
      this._link = lnk;
      this.rebind(lnk, this, false);
      fireShuffleTasks();

      lnk.markedAll();

      this.notifyUpstream();
      return lnk;
    };

    ModelBase.prototype.unlink = function unlink() {
      if (this._link) {
        var ln = this._link;
        this._link = undefined;
        ln.rebind(this, ln, false);
        fireShuffleTasks();
        ln.teardown();
        this.notifyUpstream();
      }
    };

    function fromExpression(body, length) {
      if ( length === void 0 ) length = 0;

      var args = new Array(length);

      while (length--) {
        args[length] = "_" + length;
      }

      // Functions created directly with new Function() look like this:
      //     function anonymous (_0 /**/) { return _0*2 }
      //
      // With this workaround, we get a little more compact:
      //     function (_0){return _0*2}
      return new Function([], ("return function (" + (args.join(',')) + "){return(" + body + ");};"))();
    }

    var functions = create(null);

    function getFunction(str, i) {
      if (functions[str]) { return functions[str]; }
      return (functions[str] = createFunction(str, i));
    }

    function addFunctions(template) {
      if (!template) { return; }

      var exp = template.e;

      if (!exp) { return; }

      keys(exp).forEach(function (str) {
        if (functions[str]) { return; }
        functions[str] = exp[str];
      });
    }

    var TEMPLATE_VERSION = 4;

    var leadingWhitespace = /^\s+/;

    var ParseError = function(message) {
      this.name = 'ParseError';
      this.message = message;
      try {
        throw new Error(message);
      } catch (e) {
        this.stack = e.stack;
      }
    };

    ParseError.prototype = Error.prototype;

    var Parser = function(str, options) {
      var item;
      var lineStart = 0;

      this.str = str;
      this.options = options || {};
      this.pos = 0;

      this.lines = this.str.split('\n');
      this.lineEnds = this.lines.map(function (line) {
        var lineEnd = lineStart + line.length + 1; // +1 for the newline

        lineStart = lineEnd;
        return lineEnd;
      }, 0);

      // Custom init logic
      if (this.init) { this.init(str, options); }

      var items = [];

      while (this.pos < this.str.length && (item = this.read())) {
        items.push(item);
      }

      this.leftover = this.remaining();
      this.result = this.postProcess ? this.postProcess(items, options) : items;
    };

    Parser.prototype = {
      read: function read(converters) {
        var this$1 = this;

        var i, item;

        if (!converters) { converters = this.converters; }

        var pos = this.pos;

        var len = converters.length;
        for (i = 0; i < len; i += 1) {
          this$1.pos = pos; // reset for each attempt

          if ((item = converters[i](this$1))) {
            return item;
          }
        }

        return null;
      },

      getContextMessage: function getContextMessage(pos, message) {
        var ref = this.getLinePos(pos);
        var lineNum = ref[0];
        var columnNum = ref[1];
        if (this.options.contextLines === -1) {
          return [lineNum, columnNum, (message + " at line " + lineNum + " character " + columnNum)];
        }

        var line = this.lines[lineNum - 1];

        var contextUp = '';
        var contextDown = '';
        if (this.options.contextLines) {
          var start =
            lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;
          contextUp = this.lines
            .slice(start, lineNum - 1 - start)
            .join('\n')
            .replace(/\t/g, '  ');
          contextDown = this.lines
            .slice(lineNum, lineNum + this.options.contextLines)
            .join('\n')
            .replace(/\t/g, '  ');
          if (contextUp) {
            contextUp += '\n';
          }
          if (contextDown) {
            contextDown = '\n' + contextDown;
          }
        }

        var numTabs = 0;
        var annotation =
          contextUp +
          line.replace(/\t/g, function (match, char) {
            if (char < columnNum) {
              numTabs += 1;
            }

            return '  ';
          }) +
          '\n' +
          new Array(columnNum + numTabs).join(' ') +
          '^----' +
          contextDown;

        return [
          lineNum,
          columnNum,
          (message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation)
        ];
      },

      getLinePos: function getLinePos(char) {
        var this$1 = this;

        var lineNum = 0;
        var lineStart = 0;

        while (char >= this.lineEnds[lineNum]) {
          lineStart = this$1.lineEnds[lineNum];
          lineNum += 1;
        }

        var columnNum = char - lineStart;
        return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!
      },

      error: function error(message) {
        var ref = this.getContextMessage(this.pos, message);
        var lineNum = ref[0];
        var columnNum = ref[1];
        var msg = ref[2];

        var error = new ParseError(msg);

        error.line = lineNum;
        error.character = columnNum;
        error.shortMessage = message;

        throw error;
      },

      matchString: function matchString(string) {
        if (this.str.substr(this.pos, string.length) === string) {
          this.pos += string.length;
          return string;
        }
      },

      matchPattern: function matchPattern(pattern) {
        var match;

        if ((match = pattern.exec(this.remaining()))) {
          this.pos += match[0].length;
          return match[1] || match[0];
        }
      },

      sp: function sp() {
        this.matchPattern(leadingWhitespace);
      },

      remaining: function remaining() {
        return this.str.substring(this.pos);
      },

      nextChar: function nextChar() {
        return this.str.charAt(this.pos);
      },

      warn: function warn(message) {
        var msg = this.getContextMessage(this.pos, message)[2];

        warnIfDebug(msg);
      }
    };

    Parser.extend = function(proto) {
      var Parent = this;
      var Child = function(str, options) {
        Parser.call(this, str, options);
      };

      Child.prototype = create(Parent.prototype);

      for (var key in proto) {
        if (hasOwn(proto, key)) {
          Child.prototype[key] = proto[key];
        }
      }

      Child.extend = Parser.extend;
      return Child;
    };

    var TEXT = 1;
    var INTERPOLATOR = 2;
    var TRIPLE = 3;
    var SECTION = 4;
    var INVERTED = 5;
    var CLOSING = 6;
    var ELEMENT = 7;
    var PARTIAL = 8;
    var COMMENT = 9;
    var DELIMCHANGE = 10;
    var ANCHOR = 11;
    var ATTRIBUTE = 13;
    var CLOSING_TAG = 14;
    var COMPONENT = 15;
    var YIELDER = 16;
    var INLINE_PARTIAL = 17;
    var DOCTYPE = 18;
    var ALIAS = 19;

    var AWAIT = 55;

    var NUMBER_LITERAL = 20;
    var STRING_LITERAL = 21;
    var ARRAY_LITERAL = 22;
    var OBJECT_LITERAL = 23;
    var BOOLEAN_LITERAL = 24;
    var REGEXP_LITERAL = 25;

    var GLOBAL = 26;
    var KEY_VALUE_PAIR = 27;

    var REFERENCE = 30;
    var REFINEMENT = 31;
    var MEMBER = 32;
    var PREFIX_OPERATOR = 33;
    var BRACKETED = 34;
    var CONDITIONAL = 35;
    var INFIX_OPERATOR = 36;

    var INVOCATION = 40;

    var SECTION_IF = 50;
    var SECTION_UNLESS = 51;
    var SECTION_EACH = 52;
    var SECTION_WITH = 53;
    var SECTION_IF_WITH = 54;

    var ELSE = 60;
    var ELSEIF = 61;
    var THEN = 62;
    var CATCH = 63;

    var EVENT = 70;
    var DECORATOR = 71;
    var TRANSITION = 72;
    var BINDING_FLAG = 73;
    var DELEGATE_FLAG = 74;

    var delimiterChangePattern = /^[^\s=]+/;
    var whitespacePattern = /^\s+/;

    function readDelimiterChange(parser) {
      if (!parser.matchString('=')) {
        return null;
      }

      var start = parser.pos;

      // allow whitespace before new opening delimiter
      parser.sp();

      var opening = parser.matchPattern(delimiterChangePattern);
      if (!opening) {
        parser.pos = start;
        return null;
      }

      // allow whitespace (in fact, it's necessary...)
      if (!parser.matchPattern(whitespacePattern)) {
        return null;
      }

      var closing = parser.matchPattern(delimiterChangePattern);
      if (!closing) {
        parser.pos = start;
        return null;
      }

      // allow whitespace before closing '='
      parser.sp();

      if (!parser.matchString('=')) {
        parser.pos = start;
        return null;
      }

      return [opening, closing];
    }

    var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;

    function readNumberLiteral(parser) {
      var result;

      if ((result = parser.matchPattern(regexpPattern))) {
        return {
          t: REGEXP_LITERAL,
          v: result
        };
      }

      return null;
    }

    var pattern = /[-/\\^$*+?.()|[\]{}]/g;

    function escapeRegExp(str) {
      return str.replace(pattern, '\\$&');
    }

    var regExpCache = {};

    function getLowestIndex(haystack, needles) {
      return haystack.search(
        regExpCache[needles.join()] ||
          (regExpCache[needles.join()] = new RegExp(needles.map(escapeRegExp).join('|')))
      );
    }

    // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
    //export const booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
    var booleanAttributes = {
      allowfullscreen: 1,
      async: 1,
      autofocus: 1,
      autoplay: 1,
      checked: 1,
      compact: 1,
      controls: 1,
      declare: 1,
      default: 1,
      defaultchecked: 1,
      defaultmuted: 1,
      defaultselected: 1,
      defer: 1,
      disabled: 1,
      enabled: 1,
      formnovalidate: 1,
      hidden: 1,
      indeterminate: 1,
      inert: 1,
      ismap: 1,
      itemscope: 1,
      loop: 1,
      multiple: 1,
      muted: 1,
      nohref: 1,
      noresize: 1,
      noshade: 1,
      novalidate: 1,
      nowrap: 1,
      open: 1,
      pauseonexit: 1,
      readonly: 1,
      required: 1,
      reversed: 1,
      scoped: 1,
      seamless: 1,
      selected: 1,
      sortable: 1,
      translate: 1,
      truespeed: 1,
      typemustmatch: 1,
      visible: 1
    };
    var voidElements = {
      area: 1,
      base: 1,
      br: 1,
      col: 1,
      command: 1,
      doctype: 1,
      embed: 1,
      hr: 1,
      img: 1,
      input: 1,
      keygen: 1,
      link: 1,
      meta: 1,
      param: 1,
      source: 1,
      track: 1,
      wbr: 1
    };

    var htmlEntities = {
      quot: 34,
      amp: 38,
      apos: 39,
      lt: 60,
      gt: 62,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      copy: 169,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      reg: 174,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      sup1: 185,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      Agrave: 192,
      Aacute: 193,
      Acirc: 194,
      Atilde: 195,
      Auml: 196,
      Aring: 197,
      AElig: 198,
      Ccedil: 199,
      Egrave: 200,
      Eacute: 201,
      Ecirc: 202,
      Euml: 203,
      Igrave: 204,
      Iacute: 205,
      Icirc: 206,
      Iuml: 207,
      ETH: 208,
      Ntilde: 209,
      Ograve: 210,
      Oacute: 211,
      Ocirc: 212,
      Otilde: 213,
      Ouml: 214,
      times: 215,
      Oslash: 216,
      Ugrave: 217,
      Uacute: 218,
      Ucirc: 219,
      Uuml: 220,
      Yacute: 221,
      THORN: 222,
      szlig: 223,
      agrave: 224,
      aacute: 225,
      acirc: 226,
      atilde: 227,
      auml: 228,
      aring: 229,
      aelig: 230,
      ccedil: 231,
      egrave: 232,
      eacute: 233,
      ecirc: 234,
      euml: 235,
      igrave: 236,
      iacute: 237,
      icirc: 238,
      iuml: 239,
      eth: 240,
      ntilde: 241,
      ograve: 242,
      oacute: 243,
      ocirc: 244,
      otilde: 245,
      ouml: 246,
      divide: 247,
      oslash: 248,
      ugrave: 249,
      uacute: 250,
      ucirc: 251,
      uuml: 252,
      yacute: 253,
      thorn: 254,
      yuml: 255,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    var controlCharacters = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376
    ];
    var entityPattern = new RegExp(
      '&(#?(?:x[\\w\\d]+|\\d+|' + keys(htmlEntities).join('|') + '));?',
      'g'
    );
    var codePointSupport = isFunction(String.fromCodePoint);
    var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;

    function decodeCharacterReferences(html) {
      return html.replace(entityPattern, function (match, entity) {
        var code;

        // Handle named entities
        if (entity[0] !== '#') {
          code = htmlEntities[entity];
        } else if (entity[1] === 'x') {
          code = parseInt(entity.substring(2), 16);
        } else {
          code = parseInt(entity.substring(1), 10);
        }

        if (!code) {
          return match;
        }

        return codeToChar(validateCode(code));
      });
    }

    var lessThan = /</g;
    var greaterThan = />/g;
    var amp = /&/g;
    var invalid = 65533;

    function escapeHtml(str) {
      return str
        .replace(amp, '&amp;')
        .replace(lessThan, '&lt;')
        .replace(greaterThan, '&gt;');
    }

    // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
    // code points with alternatives in some cases - since we're bypassing that mechanism, we need
    // to replace them ourselves
    //
    // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
    /* istanbul ignore next */
    function validateCode(code) {
      if (!code) {
        return invalid;
      }

      // line feed becomes generic whitespace
      if (code === 10) {
        return 32;
      }

      // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
      if (code < 128) {
        return code;
      }

      // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
      // to correct the mistake or we'll end up with missing € signs and so on
      if (code <= 159) {
        return controlCharacters[code - 128];
      }

      // basic multilingual plane
      if (code < 55296) {
        return code;
      }

      // UTF-16 surrogate halves
      if (code <= 57343) {
        return invalid;
      }

      // rest of the basic multilingual plane
      if (code <= 65535) {
        return code;
      } else if (!codePointSupport) {
        return invalid;
      }

      // supplementary multilingual plane 0x10000 - 0x1ffff
      if (code >= 65536 && code <= 131071) {
        return code;
      }

      // supplementary ideographic plane 0x20000 - 0x2ffff
      if (code >= 131072 && code <= 196607) {
        return code;
      }

      return invalid;
    }

    var expectedExpression = 'Expected a JavaScript expression';
    var expectedParen = 'Expected closing paren';

    // bulletproof number regex from https://gist.github.com/Rich-Harris/7544330
    var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;

    function readNumberLiteral$1(parser) {
      var result;

      if ((result = parser.matchPattern(numberPattern))) {
        return {
          t: NUMBER_LITERAL,
          v: result
        };
      }

      return null;
    }

    function readBooleanLiteral(parser) {
      var remaining = parser.remaining();

      if (remaining.substr(0, 4) === 'true') {
        parser.pos += 4;
        return {
          t: BOOLEAN_LITERAL,
          v: 'true'
        };
      }

      if (remaining.substr(0, 5) === 'false') {
        parser.pos += 5;
        return {
          t: BOOLEAN_LITERAL,
          v: 'false'
        };
      }

      return null;
    }

    // Match one or more characters until: ", ', \, or EOL/EOF.
    // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
    var stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

    // Match one escape sequence, including the backslash.
    var escapeSequencePattern = /^\\(?:[`'"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

    // Match one ES5 line continuation (backslash + line terminator).
    var lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

    // Helper for defining getDoubleQuotedString and getSingleQuotedString.
    function makeQuotedStringMatcher(okQuote) {
      return function(parser) {
        var literal = '"';
        var done = false;
        var next;

        while (!done) {
          next =
            parser.matchPattern(stringMiddlePattern) ||
            parser.matchPattern(escapeSequencePattern) ||
            parser.matchString(okQuote);
          if (next) {
            if (next === "\"") {
              literal += "\\\"";
            } else if (next === "\\'") {
              literal += "'";
            } else {
              literal += next;
            }
          } else {
            next = parser.matchPattern(lineContinuationPattern);
            if (next) {
              // convert \(newline-like) into a \u escape, which is allowed in JSON
              literal += '\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);
            } else {
              done = true;
            }
          }
        }

        literal += '"';

        // use JSON.parse to interpret escapes
        return JSON.parse(literal);
      };
    }

    var singleMatcher = makeQuotedStringMatcher("\"");
    var doubleMatcher = makeQuotedStringMatcher("'");

    function readStringLiteral(parser) {
      var start = parser.pos;
      var quote = parser.matchString("'") || parser.matchString("\"");

      if (quote) {
        var string = (quote === "'" ? singleMatcher : doubleMatcher)(parser);

        if (!parser.matchString(quote)) {
          parser.pos = start;
          return null;
        }

        return {
          t: STRING_LITERAL,
          v: string
        };
      }

      return null;
    }

    // Match one or more characters until: ", ', or \
    var stringMiddlePattern$1 = /^[^`"\\\$]+?(?:(?=[`"\\\$]))/;

    var escapes = /[\r\n\t\b\f]/g;
    function getString(literal) {
      return JSON.parse(("\"" + (literal.replace(escapes, escapeChar)) + "\""));
    }

    function escapeChar(c) {
      switch (c) {
        case '\n':
          return '\\n';
        case '\r':
          return '\\r';
        case '\t':
          return '\\t';
        case '\b':
          return '\\b';
        case '\f':
          return '\\f';
      }
    }

    function readTemplateStringLiteral(parser) {
      if (!parser.matchString('`')) { return null; }

      var literal = '';
      var done = false;
      var next;
      var parts = [];

      while (!done) {
        next =
          parser.matchPattern(stringMiddlePattern$1) ||
          parser.matchPattern(escapeSequencePattern) ||
          parser.matchString('$') ||
          parser.matchString('"');
        if (next) {
          if (next === "\"") {
            literal += "\\\"";
          } else if (next === '\\`') {
            literal += '`';
          } else if (next === '$') {
            if (parser.matchString('{')) {
              parts.push({ t: STRING_LITERAL, v: getString(literal) });
              literal = '';

              parser.sp();
              var expr = readExpression(parser);

              if (!expr) { parser.error('Expected valid expression'); }

              parts.push({ t: BRACKETED, x: expr });

              parser.sp();
              if (!parser.matchString('}'))
                { parser.error("Expected closing '}' after interpolated expression"); }
            } else {
              literal += '$';
            }
          } else {
            literal += next;
          }
        } else {
          next = parser.matchPattern(lineContinuationPattern);
          if (next) {
            // convert \(newline-like) into a \u escape, which is allowed in JSON
            literal += '\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);
          } else {
            done = true;
          }
        }
      }

      if (literal.length) { parts.push({ t: STRING_LITERAL, v: getString(literal) }); }

      if (!parser.matchString('`')) { parser.error("Expected closing '`'"); }

      if (!parts.length) {
        // empty string literal
        return { t: STRING_LITERAL, v: '' };
      } else if (parts.length === 1) {
        return parts[0];
      } else {
        var result = parts.pop();
        var part;

        while ((part = parts.pop())) {
          result = {
            t: INFIX_OPERATOR,
            s: '+',
            o: [part, result]
          };
        }

        return {
          t: BRACKETED,
          x: result
        };
      }
    }

    var name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;
    var spreadPattern = /^\s*\.{3}/;
    var legalReference = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:\.(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
    var relaxedName = /^[a-zA-Z_$][-\/a-zA-Z_$0-9]*(?:\.(?:[a-zA-Z_$][-\/a-zA-Z_$0-9]*))*/;

    var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

    // http://mathiasbynens.be/notes/javascript-properties
    // can be any name, string literal, or number literal
    function readKey(parser) {
      var token;

      if ((token = readStringLiteral(parser))) {
        return identifier.test(token.v) ? token.v : '"' + token.v.replace(/"/g, '\\"') + '"';
      }

      if ((token = readNumberLiteral$1(parser))) {
        return token.v;
      }

      if ((token = parser.matchPattern(name))) {
        return token;
      }

      return null;
    }

    function readKeyValuePair(parser) {
      var spread;
      var start = parser.pos;

      // allow whitespace between '{' and key
      parser.sp();

      var refKey = parser.nextChar() !== "'" && parser.nextChar() !== '"';
      if (refKey) { spread = parser.matchPattern(spreadPattern); }

      var key = spread ? readExpression(parser) : readKey(parser);
      if (key === null) {
        parser.pos = start;
        return null;
      }

      // allow whitespace between key and ':'
      parser.sp();

      // es2015 shorthand property
      if (refKey && (parser.nextChar() === ',' || parser.nextChar() === '}')) {
        if (!spread && !name.test(key)) {
          parser.error(("Expected a valid reference, but found '" + key + "' instead."));
        }

        var pair = {
          t: KEY_VALUE_PAIR,
          k: key,
          v: {
            t: REFERENCE,
            n: key
          }
        };

        if (spread) {
          pair.p = true;
        }

        return pair;
      }

      // next character must be ':'
      if (!parser.matchString(':')) {
        parser.pos = start;
        return null;
      }

      // allow whitespace between ':' and value
      parser.sp();

      // next expression must be a, well... expression
      var value = readExpression(parser);
      if (value === null) {
        parser.pos = start;
        return null;
      }

      return {
        t: KEY_VALUE_PAIR,
        k: key,
        v: value
      };
    }

    function readKeyValuePairs(parser) {
      var start = parser.pos;

      var pair = readKeyValuePair(parser);
      if (pair === null) {
        return null;
      }

      var pairs = [pair];

      if (parser.matchString(',')) {
        var keyValuePairs = readKeyValuePairs(parser);

        if (!keyValuePairs) {
          parser.pos = start;
          return null;
        }

        return pairs.concat(keyValuePairs);
      }

      return pairs;
    }

    function readObjectLiteral(parser) {
      var start = parser.pos;

      // allow whitespace
      parser.sp();

      if (!parser.matchString('{')) {
        parser.pos = start;
        return null;
      }

      var keyValuePairs = readKeyValuePairs(parser);

      // allow whitespace between final value and '}'
      parser.sp();

      if (!parser.matchString('}')) {
        parser.pos = start;
        return null;
      }

      return {
        t: OBJECT_LITERAL,
        m: keyValuePairs
      };
    }

    function readArrayLiteral(parser) {
      var start = parser.pos;

      // allow whitespace before '['
      parser.sp();

      if (!parser.matchString('[')) {
        parser.pos = start;
        return null;
      }

      var expressionList = readExpressionList(parser, true);

      if (!parser.matchString(']')) {
        parser.pos = start;
        return null;
      }

      return {
        t: ARRAY_LITERAL,
        m: expressionList
      };
    }

    function readLiteral(parser) {
      return (
        readNumberLiteral$1(parser) ||
        readBooleanLiteral(parser) ||
        readStringLiteral(parser) ||
        readTemplateStringLiteral(parser) ||
        readObjectLiteral(parser) ||
        readArrayLiteral(parser) ||
        readNumberLiteral(parser)
      );
    }

    // if a reference is a browser global, we don't deference it later, so it needs special treatment
    var globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\b/;

    // keywords are not valid references, with the exception of `this`
    var keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

    var prefixPattern = /^(?:\@\.|\@|~\/|(?:\^\^\/(?:\^\^\/)*(?:\.\.\/)*)|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/;
    var specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local|style|helpers|last|macro)/;

    function readReference(parser) {
      var prefix, name$$1, global, reference, lastDotIndex;

      var startPos = parser.pos;

      prefix = parser.matchPattern(prefixPattern) || '';
      name$$1 =
        (!prefix && parser.relaxedNames && parser.matchPattern(relaxedName)) ||
        parser.matchPattern(legalReference);
      var actual = prefix.length + ((name$$1 && name$$1.length) || 0);

      if (prefix === '@.') {
        prefix = '@';
        if (name$$1) { name$$1 = 'this.' + name$$1; }
        else { name$$1 = 'this'; }
      }

      if (!name$$1 && prefix) {
        name$$1 = prefix;
        prefix = '';
      }

      if (!name$$1) {
        return null;
      }

      if (prefix === '@') {
        if (!specials.test(name$$1)) {
          parser.error(("Unrecognized special reference @" + name$$1));
        } else if ((!name$$1.indexOf('event') || !name$$1.indexOf('node')) && !parser.inEvent) {
          parser.error("@event and @node are only valid references within an event directive");
        } else if (!name$$1.indexOf('context')) {
          parser.pos = parser.pos - (name$$1.length - 7);
          return {
            t: BRACKETED,
            x: {
              t: REFERENCE,
              n: '@context'
            }
          };
        }
      }

      // bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
      if (!prefix && !parser.relaxedNames && keywords.test(name$$1)) {
        parser.pos = startPos;
        return null;
      }

      // if this is a browser global, stop here
      if (!prefix && globals.test(name$$1)) {
        global = globals.exec(name$$1)[0];
        parser.pos = startPos + global.length;

        return {
          t: GLOBAL,
          v: global
        };
      }

      reference = (prefix || '') + normalise(name$$1);

      if (parser.matchString('(')) {
        // if this is a method invocation (as opposed to a function) we need
        // to strip the method name from the reference combo, else the context
        // will be wrong
        // but only if the reference was actually a member and not a refinement
        lastDotIndex = reference.lastIndexOf('.');
        if (lastDotIndex !== -1 && name$$1[name$$1.length - 1] !== ']') {
          if (lastDotIndex === 0) {
            reference = '.';
            parser.pos = startPos;
          } else {
            var refLength = reference.length;
            reference = reference.substr(0, lastDotIndex);
            parser.pos = startPos + (actual - (refLength - lastDotIndex));
          }
        } else {
          parser.pos -= 1;
        }
      }

      return {
        t: REFERENCE,
        n: reference.replace(/^this\./, './').replace(/^this$/, '.')
      };
    }

    function readBracketedExpression(parser) {
      if (!parser.matchString('(')) { return null; }

      parser.sp();

      var expr = readExpression(parser);

      if (!expr) { parser.error(expectedExpression); }

      parser.sp();

      if (!parser.matchString(')')) { parser.error(expectedParen); }

      return {
        t: BRACKETED,
        x: expr
      };
    }

    function readPrimary(parser) {
      return readLiteral(parser) || readReference(parser) || readBracketedExpression(parser);
    }

    function readRefinement(parser) {
      // some things call for strict refinement (partial names), meaning no space between reference and refinement
      if (!parser.strictRefinement) {
        parser.sp();
      }

      // "." name
      if (parser.matchString('.')) {
        parser.sp();

        var name$$1 = parser.matchPattern(name);
        if (name$$1) {
          return {
            t: REFINEMENT,
            n: name$$1
          };
        }

        parser.error('Expected a property name');
      }

      // "[" expression "]"
      if (parser.matchString('[')) {
        parser.sp();

        var expr = readExpression(parser);
        if (!expr) { parser.error(expectedExpression); }

        parser.sp();

        if (!parser.matchString(']')) { parser.error("Expected ']'"); }

        return {
          t: REFINEMENT,
          x: expr
        };
      }

      return null;
    }

    function readMemberOrInvocation(parser) {
      var expression = readPrimary(parser);

      if (!expression) { return null; }

      while (expression) {
        var refinement = readRefinement(parser);
        if (refinement) {
          expression = {
            t: MEMBER,
            x: expression,
            r: refinement
          };
        } else if (parser.matchString('(')) {
          parser.sp();
          var expressionList = readExpressionList(parser, true);

          parser.sp();

          if (!parser.matchString(')')) {
            parser.error(expectedParen);
          }

          expression = {
            t: INVOCATION,
            x: expression
          };

          if (expressionList) { expression.o = expressionList; }
        } else {
          break;
        }
      }

      return expression;
    }

    var readTypeOf;

    var makePrefixSequenceMatcher = function(symbol, fallthrough) {
      return function(parser) {
        var expression;

        if ((expression = fallthrough(parser))) {
          return expression;
        }

        if (!parser.matchString(symbol)) {
          return null;
        }

        parser.sp();

        expression = readExpression(parser);
        if (!expression) {
          parser.error(expectedExpression);
        }

        return {
          s: symbol,
          o: expression,
          t: PREFIX_OPERATOR
        };
      };
    };

    // create all prefix sequence matchers, return readTypeOf
    (function() {
      var i, len, matcher, fallthrough;

      var prefixOperators = '! ~ + - typeof'.split(' ');

      fallthrough = readMemberOrInvocation;
      for (i = 0, len = prefixOperators.length; i < len; i += 1) {
        matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);
        fallthrough = matcher;
      }

      // typeof operator is higher precedence than multiplication, so provides the
      // fallthrough for the multiplication sequence matcher we're about to create
      // (we're skipping void and delete)
      readTypeOf = fallthrough;
    })();

    var readTypeof = readTypeOf;

    var readLogicalOr;

    var makeInfixSequenceMatcher = function(symbol, fallthrough) {
      return function(parser) {
        // > and / have to be quoted
        if (parser.inUnquotedAttribute && (symbol === '>' || symbol === '/'))
          { return fallthrough(parser); }

        var start, left, right;

        left = fallthrough(parser);
        if (!left) {
          return null;
        }

        // Loop to handle left-recursion in a case like `a * b * c` and produce
        // left association, i.e. `(a * b) * c`.  The matcher can't call itself
        // to parse `left` because that would be infinite regress.
        while (true) {
          start = parser.pos;

          parser.sp();

          if (!parser.matchString(symbol)) {
            parser.pos = start;
            return left;
          }

          // special case - in operator must not be followed by [a-zA-Z_$0-9]
          if (symbol === 'in' && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {
            parser.pos = start;
            return left;
          }

          parser.sp();

          // right operand must also consist of only higher-precedence operators
          right = fallthrough(parser);
          if (!right) {
            parser.pos = start;
            return left;
          }

          left = {
            t: INFIX_OPERATOR,
            s: symbol,
            o: [left, right]
          };

          // Loop back around.  If we don't see another occurrence of the symbol,
          // we'll return left.
        }
      };
    };

    // create all infix sequence matchers, and return readLogicalOr
    (function() {
      var i, len, matcher, fallthrough;

      // All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
      // Each sequence matcher will initially fall through to its higher precedence
      // neighbour, and only attempt to match if one of the higher precedence operators
      // (or, ultimately, a literal, reference, or bracketed expression) already matched
      var infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split(
        ' '
      );

      // A typeof operator is higher precedence than multiplication
      fallthrough = readTypeof;
      for (i = 0, len = infixOperators.length; i < len; i += 1) {
        matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);
        fallthrough = matcher;
      }

      // Logical OR is the fallthrough for the conditional matcher
      readLogicalOr = fallthrough;
    })();

    var readLogicalOr$1 = readLogicalOr;

    // The conditional operator is the lowest precedence operator, so we start here
    function getConditional(parser) {
      var expression = readLogicalOr$1(parser);
      if (!expression) {
        return null;
      }

      var start = parser.pos;

      parser.sp();

      if (!parser.matchString('?')) {
        parser.pos = start;
        return expression;
      }

      parser.sp();

      var ifTrue = readExpression(parser);
      if (!ifTrue) {
        parser.error(expectedExpression);
      }

      parser.sp();

      if (!parser.matchString(':')) {
        parser.error('Expected ":"');
      }

      parser.sp();

      var ifFalse = readExpression(parser);
      if (!ifFalse) {
        parser.error(expectedExpression);
      }

      return {
        t: CONDITIONAL,
        o: [expression, ifTrue, ifFalse]
      };
    }

    function readExpression(parser) {
      // if eval is false, no expressions
      if (parser.allowExpressions === false) {
        var ref = readReference(parser);
        parser.sp();
        return ref;
      }

      // The conditional operator is the lowest precedence operator (except yield,
      // assignment operators, and commas, none of which are supported), so we
      // start there. If it doesn't match, it 'falls through' to progressively
      // higher precedence operators, until it eventually matches (or fails to
      // match) a 'primary' - a literal or a reference. This way, the abstract syntax
      // tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
      return getConditional(parser);
    }

    function readExpressionList(parser, spread) {
      var isSpread;
      var expressions = [];

      var pos = parser.pos;

      do {
        parser.sp();

        if (spread) {
          isSpread = parser.matchPattern(spreadPattern);
        }

        var expr = readExpression(parser);

        if (expr === null && expressions.length) {
          parser.error(expectedExpression);
        } else if (expr === null) {
          parser.pos = pos;
          return null;
        }

        if (isSpread) {
          expr.p = true;
        }

        expressions.push(expr);

        parser.sp();
      } while (parser.matchString(','));

      return expressions;
    }

    function readExpressionOrReference(parser, expectedFollowers) {
      var start = parser.pos;
      var expression = readExpression(parser);

      if (!expression) {
        // valid reference but invalid expression e.g. `{{new}}`?
        var ref = parser.matchPattern(/^(\w+)/);
        if (ref) {
          return {
            t: REFERENCE,
            n: ref
          };
        }

        return null;
      }

      for (var i = 0; i < expectedFollowers.length; i += 1) {
        if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {
          return expression;
        }
      }

      parser.pos = start;
      return readReference(parser);
    }

    function flattenExpression(expression) {
      var refs;
      var count = 0;

      extractRefs(expression, (refs = []));
      var stringified = stringify(expression);

      return {
        r: refs,
        s: getVars(stringified)
      };

      function getVars(expr) {
        var vars = [];
        for (var i = count - 1; i >= 0; i--) {
          vars.push(("x$" + i));
        }
        return vars.length ? ("(function(){var " + (vars.join(',')) + ";return(" + expr + ");})()") : expr;
      }

      function stringify(node) {
        if (isString(node)) {
          return node;
        }

        switch (node.t) {
          case BOOLEAN_LITERAL:
          case GLOBAL:
          case NUMBER_LITERAL:
          case REGEXP_LITERAL:
            return node.v;

          case STRING_LITERAL:
            return JSON.stringify(String(node.v));

          case ARRAY_LITERAL:
            if (node.m && hasSpread(node.m)) {
              return ("[].concat(" + (makeSpread(node.m, '[', ']', stringify)) + ")");
            } else {
              return '[' + (node.m ? node.m.map(stringify).join(',') : '') + ']';
            }

          case OBJECT_LITERAL:
            if (node.m && hasSpread(node.m)) {
              return ("Object.assign({}," + (makeSpread(node.m, '{', '}', stringifyPair)) + ")");
            } else {
              return '{' + (node.m ? node.m.map(function (n) { return ((n.k) + ":" + (stringify(n.v))); }).join(',') : '') + '}';
            }

          case PREFIX_OPERATOR:
            return (node.s === 'typeof' ? 'typeof ' : node.s) + stringify(node.o);

          case INFIX_OPERATOR:
            return (
              stringify(node.o[0]) +
              (node.s.substr(0, 2) === 'in' ? ' ' + node.s + ' ' : node.s) +
              stringify(node.o[1])
            );

          case INVOCATION:
            if (node.o && hasSpread(node.o)) {
              var id = count++;
              return ("(x$" + id + "=" + (stringify(node.x)) + ").apply(x$" + id + "," + (stringify({
                t: ARRAY_LITERAL,
                m: node.o
              })) + ")");
            } else {
              return stringify(node.x) + '(' + (node.o ? node.o.map(stringify).join(',') : '') + ')';
            }

          case BRACKETED:
            return '(' + stringify(node.x) + ')';

          case MEMBER:
            return stringify(node.x) + stringify(node.r);

          case REFINEMENT:
            return node.n ? '.' + node.n : '[' + stringify(node.x) + ']';

          case CONDITIONAL:
            return stringify(node.o[0]) + '?' + stringify(node.o[1]) + ':' + stringify(node.o[2]);

          case REFERENCE:
            return '_' + refs.indexOf(node.n);

          default:
            throw new Error('Expected legal JavaScript');
        }
      }

      function stringifyPair(node) {
        return node.p ? stringify(node.k) : ((node.k) + ":" + (stringify(node.v)));
      }

      function makeSpread(list, open, close, fn) {
        var out = list.reduce(
          function (a, c) {
            if (c.p) {
              a.str += "" + (a.open ? close + ',' : a.str.length ? ',' : '') + (fn(c));
            } else {
              a.str += "" + (!a.str.length ? open : !a.open ? ',' + open : ',') + (fn(c));
            }
            a.open = !c.p;
            return a;
          },
          { open: false, str: '' }
        );
        if (out.open) { out.str += close; }
        return out.str;
      }
    }

    function hasSpread(list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].p) { return true; }
      }

      return false;
    }

    // TODO maybe refactor this?
    function extractRefs(node, refs) {
      if (node.t === REFERENCE && isString(node.n)) {
        if (!~refs.indexOf(node.n)) {
          refs.unshift(node.n);
        }
      }

      var list = node.o || node.m;
      if (list) {
        if (isObject(list)) {
          extractRefs(list, refs);
        } else {
          var i = list.length;
          while (i--) {
            extractRefs(list[i], refs);
          }
        }
      }

      if (node.k && node.t === KEY_VALUE_PAIR && !isString(node.k)) {
        extractRefs(node.k, refs);
      }

      if (node.x) {
        extractRefs(node.x, refs);
      }

      if (node.r) {
        extractRefs(node.r, refs);
      }

      if (node.v) {
        extractRefs(node.v, refs);
      }
    }

    function refineExpression(expression, mustache) {
      var referenceExpression;

      if (expression) {
        while (expression.t === BRACKETED && expression.x) {
          expression = expression.x;
        }

        if (expression.t === REFERENCE) {
          var n = expression.n;
          if (!~n.indexOf('@context')) {
            mustache.r = expression.n;
          } else {
            mustache.x = flattenExpression(expression);
          }
        } else {
          if ((referenceExpression = getReferenceExpression(expression))) {
            mustache.rx = referenceExpression;
          } else {
            mustache.x = flattenExpression(expression);
          }
        }

        return mustache;
      }
    }

    // TODO refactor this! it's bewildering
    function getReferenceExpression(expression) {
      var members = [];
      var refinement;

      while (expression.t === MEMBER && expression.r.t === REFINEMENT) {
        refinement = expression.r;

        if (refinement.x) {
          if (refinement.x.t === REFERENCE) {
            members.unshift(refinement.x);
          } else {
            members.unshift(flattenExpression(refinement.x));
          }
        } else {
          members.unshift(refinement.n);
        }

        expression = expression.x;
      }

      if (expression.t !== REFERENCE) {
        return null;
      }

      return {
        r: expression.n,
        m: members
      };
    }

    var attributeNamePattern = /^[^\s"'>\/=(]+/;
    var onPattern = /^on/;
    var eventPattern = /^on-([a-zA-Z\*\.$_]((?:[a-zA-Z\*\.$_0-9\-]|\\-)+))$/;
    var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/;
    var decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;
    var transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;
    var boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/;
    var directives = {
      lazy: { t: BINDING_FLAG, v: 'l' },
      twoway: { t: BINDING_FLAG, v: 't' },
      'no-delegation': { t: DELEGATE_FLAG }
    };
    var unquotedAttributeValueTextPattern = /^[^\s"'=<>\/`]+/;
    var proxyEvent = /^[^\s"'=<>@\[\]()]*/;
    var whitespace = /^\s+/;

    var slashes = /\\/g;
    function splitEvent(str) {
      var result = [];
      var s = 0;

      for (var i = 0; i < str.length; i++) {
        if (str[i] === '-' && str[i - 1] !== '\\') {
          result.push(str.substring(s, i).replace(slashes, ''));
          s = i + 1;
        }
      }

      result.push(str.substring(s).replace(slashes, ''));

      return result;
    }

    function readAttribute(parser) {
      var name, i, nearest, idx;

      parser.sp();

      name = parser.matchPattern(attributeNamePattern);
      if (!name) {
        return null;
      }

      // check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />
      nearest = name.length;
      for (i = 0; i < parser.tags.length; i++) {
        if (~(idx = name.indexOf(parser.tags[i].open))) {
          if (idx < nearest) { nearest = idx; }
        }
      }
      if (nearest < name.length) {
        parser.pos -= name.length - nearest;
        name = name.substr(0, nearest);
        if (!name) { return null; }
      }

      return { n: name };
    }

    function readAttributeValue(parser) {
      var start = parser.pos;

      // next character must be `=`, `/`, `>` or whitespace
      if (!/[=\/>\s]/.test(parser.nextChar())) {
        parser.error('Expected `=`, `/`, `>` or whitespace');
      }

      parser.sp();

      if (!parser.matchString('=')) {
        parser.pos = start;
        return null;
      }

      parser.sp();

      var valueStart = parser.pos;
      var startDepth = parser.sectionDepth;

      var value =
        readQuotedAttributeValue(parser, "'") ||
        readQuotedAttributeValue(parser, "\"") ||
        readUnquotedAttributeValue(parser);

      if (value === null) {
        parser.error('Expected valid attribute value');
      }

      if (parser.sectionDepth !== startDepth) {
        parser.pos = valueStart;
        parser.error(
          'An attribute value must contain as many opening section tags as closing section tags'
        );
      }

      if (!value.length) {
        return '';
      }

      if (value.length === 1 && isString(value[0])) {
        return decodeCharacterReferences(value[0]);
      }

      return value;
    }

    function readUnquotedAttributeValueToken(parser) {
      var text, index;

      var start = parser.pos;

      text = parser.matchPattern(unquotedAttributeValueTextPattern);

      if (!text) {
        return null;
      }

      var haystack = text;
      var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well

      if ((index = getLowestIndex(haystack, needles)) !== -1) {
        text = text.substr(0, index);
        parser.pos = start + text.length;
      }

      return text;
    }

    function readUnquotedAttributeValue(parser) {
      parser.inAttribute = true;

      var tokens = [];

      var token = readMustache(parser) || readUnquotedAttributeValueToken(parser);
      while (token) {
        tokens.push(token);
        token = readMustache(parser) || readUnquotedAttributeValueToken(parser);
      }

      if (!tokens.length) {
        return null;
      }

      parser.inAttribute = false;
      return tokens;
    }

    function readQuotedAttributeValue(parser, quoteMark) {
      var start = parser.pos;

      if (!parser.matchString(quoteMark)) {
        return null;
      }

      parser.inAttribute = quoteMark;

      var tokens = [];

      var token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);
      while (token !== null) {
        tokens.push(token);
        token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);
      }

      if (!parser.matchString(quoteMark)) {
        parser.pos = start;
        return null;
      }

      parser.inAttribute = false;

      return tokens;
    }

    function readQuotedStringToken(parser, quoteMark) {
      var haystack = parser.remaining();

      var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well
      needles.push(quoteMark);

      var index = getLowestIndex(haystack, needles);

      if (index === -1) {
        parser.error('Quoted attribute value must have a closing quote');
      }

      if (!index) {
        return null;
      }

      parser.pos += index;
      return haystack.substr(0, index);
    }

    function readAttributeOrDirective(parser) {
      var match, directive;

      var attribute = readAttribute(parser);

      if (!attribute) { return null; }

      // lazy, twoway
      if ((directive = directives[attribute.n])) {
        attribute.t = directive.t;
        if (directive.v) { attribute.v = directive.v; }
        delete attribute.n; // no name necessary
        parser.sp();
        if (parser.nextChar() === '=') { attribute.f = readAttributeValue(parser); }
      } else if ((match = decoratorPattern.exec(attribute.n))) {
        // decorators
        attribute.n = match[1];
        attribute.t = DECORATOR;
        readArguments(parser, attribute);
      } else if ((match = transitionPattern.exec(attribute.n))) {
        // transitions
        attribute.n = match[1];
        attribute.t = TRANSITION;
        readArguments(parser, attribute);
        attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';
      } else if ((match = eventPattern.exec(attribute.n))) {
        // on-click etc
        attribute.n = splitEvent(match[1]);
        attribute.t = EVENT;

        if (parser.matchString('(')) {
          attribute.a = flattenExpression({
            t: ARRAY_LITERAL,
            m: readExpressionList(parser)
          });
          if (!parser.matchString(')')) { parser.error("Expected closing ')'"); }
        }

        parser.inEvent = true;

        // check for a proxy event
        if (!readProxyEvent(parser, attribute)) {
          // otherwise, it's an expression
          readArguments(parser, attribute, true);
        } else if (reservedEventNames.test(attribute.f)) {
          parser.pos -= attribute.f.length;
          parser.error(
            'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)'
          );
        }

        parser.inEvent = false;
      } else if ((match = boundPattern.exec(attribute.n))) {
        // bound directives
        var bind = match[2] === 'bind';
        attribute.n = bind ? match[3] : match[1];
        attribute.t = ATTRIBUTE;
        readArguments(parser, attribute, false, true);

        if (!attribute.f && bind) {
          attribute.f = [{ t: INTERPOLATOR, r: match[3] }];
        }
      } else {
        parser.sp();
        var value = parser.nextChar() === '=' ? readAttributeValue(parser) : null;
        attribute.f = value != null ? value : attribute.f;

        if (parser.sanitizeEventAttributes && onPattern.test(attribute.n)) {
          return { exclude: true };
        } else {
          attribute.f = attribute.f || (attribute.f === '' ? '' : 0);
          attribute.t = ATTRIBUTE;
        }
      }

      return attribute;
    }

    function readProxyEvent(parser, attribute) {
      var start = parser.pos;
      if (!parser.matchString('=')) { parser.error("Missing required directive arguments"); }

      var quote = parser.matchString("'") || parser.matchString("\"");
      parser.sp();
      var proxy = parser.matchPattern(proxyEvent);

      if (proxy !== undefined) {
        if (quote) {
          parser.sp();
          if (!parser.matchString(quote)) { parser.pos = start; }
          else { return (attribute.f = proxy) || true; }
        } else if (!parser.matchPattern(whitespace)) {
          parser.pos = start;
        } else {
          return (attribute.f = proxy) || true;
        }
      } else {
        parser.pos = start;
      }
    }

    function readArguments(parser, attribute, required, single) {
      if ( required === void 0 ) required = false;
      if ( single === void 0 ) single = false;

      parser.sp();
      if (!parser.matchString('=')) {
        if (required) { parser.error("Missing required directive arguments"); }
        return;
      }
      parser.sp();

      var quote = parser.matchString('"') || parser.matchString("'");
      var spread = parser.spreadArgs;
      parser.spreadArgs = true;
      parser.inUnquotedAttribute = !quote;
      var expr = single
        ? readExpressionOrReference(parser, [quote || ' ', '/', '>'])
        : { m: readExpressionList(parser), t: ARRAY_LITERAL };
      parser.inUnquotedAttribute = false;
      parser.spreadArgs = spread;

      if (quote) {
        parser.sp();
        if (parser.matchString(quote) !== quote) { parser.error(("Expected matching quote '" + quote + "'")); }
      }

      if (single) {
        var interpolator = { t: INTERPOLATOR };
        refineExpression(expr, interpolator);
        attribute.f = [interpolator];
      } else {
        attribute.f = flattenExpression(expr);
      }
    }

    var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };

    function readMustache(parser) {
      var mustache, i;

      // If we're inside a <script> or <style> tag, and we're not
      // interpolating, bug out
      if (parser.interpolate[parser.inside] === false) {
        return null;
      }

      for (i = 0; i < parser.tags.length; i += 1) {
        if ((mustache = readMustacheOfType(parser, parser.tags[i]))) {
          return mustache;
        }
      }

      if (parser.inTag && !parser.inAttribute) {
        mustache = readAttributeOrDirective(parser);
        if (mustache) {
          parser.sp();
          return mustache;
        }
      }
    }

    function readMustacheOfType(parser, tag) {
      var mustache, reader, i;

      var start = parser.pos;

      if (parser.matchString('\\' + tag.open)) {
        if (start === 0 || parser.str[start - 1] !== '\\') {
          return tag.open;
        }
      } else if (!parser.matchString(tag.open)) {
        return null;
      }

      // delimiter change?
      if ((mustache = readDelimiterChange(parser))) {
        // find closing delimiter or abort...
        if (!parser.matchString(tag.close)) {
          return null;
        }

        // ...then make the switch
        tag.open = mustache[0];
        tag.close = mustache[1];
        parser.sortMustacheTags();

        return delimiterChangeToken;
      }

      parser.sp();

      // illegal section closer
      if (parser.matchString('/')) {
        parser.pos -= 1;
        var rewind = parser.pos;
        if (!readNumberLiteral(parser)) {
          parser.pos = rewind - tag.close.length;
          if (parser.inAttribute) {
            parser.pos = start;
            return null;
          } else {
            parser.error("Attempted to close a section that wasn't open");
          }
        } else {
          parser.pos = rewind;
        }
      }

      for (i = 0; i < tag.readers.length; i += 1) {
        reader = tag.readers[i];

        if ((mustache = reader(parser, tag))) {
          if (tag.isStatic) {
            mustache.s = 1;
          }

          if (parser.includeLinePositions) {
            mustache.q = parser.getLinePos(start);
          }

          return mustache;
        }
      }

      parser.pos = start;
      return null;
    }

    function readTriple(parser, tag) {
      var expression = readExpression(parser);

      if (!expression) {
        return null;
      }

      if (!parser.matchString(tag.close)) {
        parser.error(("Expected closing delimiter '" + (tag.close) + "'"));
      }

      var triple = { t: TRIPLE };
      refineExpression(expression, triple); // TODO handle this differently - it's mysterious

      return triple;
    }

    function readUnescaped(parser, tag) {
      if (!parser.matchString('&')) {
        return null;
      }

      parser.sp();

      var expression = readExpression(parser);

      if (!expression) {
        return null;
      }

      if (!parser.matchString(tag.close)) {
        parser.error(("Expected closing delimiter '" + (tag.close) + "'"));
      }

      var triple = { t: TRIPLE };
      refineExpression(expression, triple); // TODO handle this differently - it's mysterious

      return triple;
    }

    var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
    var asRE = /^as/i;

    function readAliases(parser) {
      var aliases = [];
      var alias;
      var start = parser.pos;

      parser.sp();

      alias = readAlias(parser);

      if (alias) {
        alias.x = refineExpression(alias.x, {});
        aliases.push(alias);

        parser.sp();

        while (parser.matchString(',')) {
          alias = readAlias(parser);

          if (!alias) {
            parser.error('Expected another alias.');
          }

          alias.x = refineExpression(alias.x, {});
          aliases.push(alias);

          parser.sp();
        }

        return aliases;
      }

      parser.pos = start;
      return null;
    }

    function readAlias(parser) {
      var start = parser.pos;

      parser.sp();

      var expr = readExpression(parser);

      if (!expr) {
        parser.pos = start;
        return null;
      }

      parser.sp();
      parser.matchPattern(asRE);
      parser.sp();

      var alias = parser.matchPattern(legalAlias);

      if (!alias) {
        parser.pos = start;
        return null;
      }

      return { n: alias, x: expr };
    }

    function readPartial(parser, tag) {
      var type = parser.matchString('>') || parser.matchString('yield');
      var partial = { t: type === '>' ? PARTIAL : YIELDER };
      var aliases;

      if (!type) { return null; }

      parser.sp();

      if (type === '>' || !(aliases = parser.matchString('with'))) {
        // Partial names can include hyphens, so we can't use readExpression
        // blindly. Instead, we use the `relaxedNames` flag to indicate that
        // `foo-bar` should be read as a single name, rather than 'subtract
        // bar from foo'
        parser.relaxedNames = parser.strictRefinement = true;
        var expression = readExpression(parser);
        parser.relaxedNames = parser.strictRefinement = false;

        if (!expression && type === '>') { return null; }

        if (expression) {
          refineExpression(expression, partial); // TODO...
          parser.sp();
          if (type !== '>') { aliases = parser.matchString('with'); }
        }
      }

      parser.sp();

      // check for alias context e.g. `{{>foo bar as bat, bip as bop}}`
      if (aliases || type === '>') {
        aliases = readAliases(parser);
        if (aliases && aliases.length) {
          partial.z = aliases;
        } else {
          // otherwise check for literal context e.g. `{{>foo bar}}` then
          // turn it into `{{#with bar}}{{>foo}}{{/with}}`
          var context = readExpression(parser);
          if (context) {
            partial.c = {};
            refineExpression(context, partial.c);
          }

          // allow aliases after context
          if (parser.matchString(',')) {
            aliases = readAliases(parser);
            if (aliases && aliases.length) {
              partial.z = aliases;
            }
          }
        }

        if (type !== '>' && (!partial.c && !partial.z)) {
          // {{yield with}} requires some aliases
          parser.error("Expected a context or one or more aliases");
        }
      }

      parser.sp();

      if (!parser.matchString(tag.close)) {
        parser.error(("Expected closing delimiter '" + (tag.close) + "'"));
      }

      return partial;
    }

    function readComment(parser, tag) {
      if (!parser.matchString('!')) {
        return null;
      }

      var index = parser.remaining().indexOf(tag.close);

      if (index !== -1) {
        parser.pos += index + tag.close.length;
        return { t: COMMENT };
      }
    }

    function readInterpolator(parser, tag) {
      var expression, err;

      var start = parser.pos;

      // TODO would be good for perf if we could do away with the try-catch
      try {
        expression = readExpressionOrReference(parser, [tag.close]);
      } catch (e) {
        err = e;
      }

      if (!expression) {
        if (parser.str.charAt(start) === '!') {
          // special case - comment
          parser.pos = start;
          return null;
        }

        if (err) {
          throw err;
        }
      }

      if (!parser.matchString(tag.close)) {
        parser.error(("Expected closing delimiter '" + (tag.close) + "' after reference"));

        if (!expression) {
          // special case - comment
          if (parser.nextChar() === '!') {
            return null;
          }

          parser.error("Expected expression or legal reference");
        }
      }

      var interpolator = { t: INTERPOLATOR };
      refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious

      return interpolator;
    }

    function readClosing(parser, tag) {
      var start = parser.pos;

      if (!parser.matchString(tag.open)) {
        return null;
      }

      parser.sp();

      if (!parser.matchString('/')) {
        parser.pos = start;
        return null;
      }

      parser.sp();

      var remaining = parser.remaining();
      var index = remaining.indexOf(tag.close);

      if (index !== -1) {
        var closing = {
          t: CLOSING,
          r: remaining.substr(0, index).split(' ')[0]
        };

        parser.pos += index;

        if (!parser.matchString(tag.close)) {
          parser.error(("Expected closing delimiter '" + (tag.close) + "'"));
        }

        return closing;
      }

      parser.pos = start;
      return null;
    }

    var patterns = {
      else: /^\s*else\s*/,
      elseif: /^\s*elseif\s+/,
      then: /^\s*then\s*/,
      catch: /^\s*catch\s*/
    };

    var types = {
      else: ELSE,
      elseif: ELSEIF,
      then: THEN,
      catch: CATCH
    };

    function readInlineBlock(parser, tag, type) {
      var start = parser.pos;

      if (!parser.matchString(tag.open)) {
        return null;
      }

      if (!parser.matchPattern(patterns[type])) {
        parser.pos = start;
        return null;
      }

      var res = { t: types[type] };

      if (type === 'elseif') {
        res.x = readExpression(parser);
      } else if (type === 'catch' || type === 'then') {
        var nm = parser.matchPattern(name);
        if (nm) { res.n = nm; }
      }

      if (!parser.matchString(tag.close)) {
        parser.error(("Expected closing delimiter '" + (tag.close) + "'"));
      }

      return res;
    }

    var handlebarsBlockCodes = {
      each: SECTION_EACH,
      if: SECTION_IF,
      with: SECTION_IF_WITH,
      unless: SECTION_UNLESS
    };

    var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
    var keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
    var handlebarsBlockPattern = new RegExp('^(' + keys(handlebarsBlockCodes).join('|') + ')\\b');

    function readSection(parser, tag) {
      var expression,
        section,
        child,
        children,
        hasElse,
        block,
        unlessBlock,
        closed,
        i,
        expectedClose,
        hasThen,
        hasCatch,
        inlineThen;
      var aliasOnly = false;

      var start = parser.pos;

      if (parser.matchString('^')) {
        // watch out for parent context refs - {{^^/^^/foo}}
        if (parser.matchString('^/')) {
          parser.pos = start;
          return null;
        }
        section = { t: SECTION, f: [], n: SECTION_UNLESS };
      } else if (parser.matchString('#')) {
        section = { t: SECTION, f: [] };

        if (parser.matchString('partial')) {
          parser.pos = start - parser.standardDelimiters[0].length;
          parser.error(
            'Partial definitions can only be at the top level of the template, or immediately inside components'
          );
        }

        if ((block = parser.matchString('await'))) {
          expectedClose = block;
          section.t = AWAIT;
        } else if ((block = parser.matchPattern(handlebarsBlockPattern))) {
          expectedClose = block;
          section.n = handlebarsBlockCodes[block];
        }
      } else {
        return null;
      }

      parser.sp();

      if (block === 'with') {
        var aliases = readAliases(parser);
        if (aliases) {
          aliasOnly = true;
          section.z = aliases;
          section.t = ALIAS;
        }
      } else if (block === 'each') {
        var alias = readAlias(parser);
        if (alias) {
          section.z = [{ n: alias.n, x: { r: '.' } }];
          expression = alias.x;
        }
      }

      if (!aliasOnly) {
        if (!expression) { expression = readExpression(parser); }

        if (!expression) {
          parser.error('Expected expression');
        }

        // extra each aliases
        if (block === 'each' && parser.matchString(',')) {
          var aliases$1 = readAliases(parser);
          if (aliases$1) {
            if (section.z) { aliases$1.unshift(section.z[0]); }
            section.z = aliases$1;
          }
        }

        // optional index and key references
        if ((block === 'each' || !block) && (i = parser.matchPattern(indexRefPattern))) {
          var extra;

          if ((extra = parser.matchPattern(keyIndexRefPattern))) {
            section.i = i + ',' + extra;
          } else {
            section.i = i;
          }
        } else if (block === 'await' && parser.matchString('then')) {
          parser.sp();
          hasThen = true;
          inlineThen = parser.matchPattern(name);
          if (!inlineThen) { inlineThen = true; }
        }

        if (!block && expression.n) {
          expectedClose = expression.n;
        }
      }

      parser.sp();

      if (parser.matchString('-')) { section.w = 1; }

      if (!parser.matchString(tag.close)) {
        parser.error(("Expected closing delimiter '" + (tag.close) + "'"));
      }

      parser.sectionDepth += 1;
      children = section.f;

      var pos;
      do {
        pos = parser.pos;
        if ((child = readClosing(parser, tag))) {
          if (expectedClose && child.r !== expectedClose) {
            if (!block) {
              if (child.r)
                { parser.warn(
                  ("Expected " + (tag.open) + "/" + expectedClose + (tag.close) + " but found " + (tag.open) + "/" + (child.r) + (tag.close))
                ); }
            } else {
              parser.pos = pos;
              parser.error(("Expected " + (tag.open) + "/" + expectedClose + (tag.close)));
            }
          }

          parser.sectionDepth -= 1;
          closed = true;
        } else if (
          !aliasOnly &&
          ((child = readInlineBlock(parser, tag, 'elseif')) ||
            (child = readInlineBlock(parser, tag, 'else')) ||
            (block === 'await' &&
              ((child = readInlineBlock(parser, tag, 'then')) ||
                (child = readInlineBlock(parser, tag, 'catch')))))
        ) {
          if (section.n === SECTION_UNLESS) {
            parser.error('{{else}} not allowed in {{#unless}}');
          }

          if (hasElse) {
            if (child.t === ELSE) {
              parser.error('there can only be one {{else}} block, at the end of a section');
            } else if (child.t === ELSEIF) {
              parser.error('illegal {{elseif...}} after {{else}}');
            }
          }

          if (!unlessBlock && (inlineThen || !hasThen) && !hasCatch) {
            if (block === 'await') {
              var s = { f: children };
              section.f = [s];
              if (inlineThen) {
                s.t = THEN;
                inlineThen !== true && (s.n = inlineThen);
              } else {
                s.t = SECTION;
              }
            } else {
              unlessBlock = [];
            }
          }

          var mustache = {
            t: SECTION,
            f: (children = [])
          };

          if (child.t === ELSE) {
            if (block === 'await') {
              section.f.push(mustache);
              mustache.t = ELSE;
            } else {
              mustache.n = SECTION_UNLESS;
              unlessBlock.push(mustache);
            }
            hasElse = true;
          } else if (child.t === ELSEIF) {
            mustache.n = SECTION_IF;
            refineExpression(child.x, mustache);
            unlessBlock.push(mustache);
          } else if (child.t === THEN) {
            if (hasElse) { parser.error('{{then}} block must appear before any {{else}} block'); }
            if (hasCatch) { parser.error('{{then}} block must appear before any {{catch}} block'); }
            if (hasThen) { parser.error('there can only be one {{then}} block per {{#await}}'); }
            mustache.t = THEN;
            hasThen = true;
            child.n && (mustache.n = child.n);
            section.f.push(mustache);
          } else if (child.t === CATCH) {
            if (hasElse) { parser.error('{{catch}} block must appear before any {{else}} block'); }
            if (hasCatch) { parser.error('there can only be one {{catch}} block per {{#await}}'); }
            mustache.t = CATCH;
            hasCatch = true;
            mustache.n = child.n;
            section.f.push(mustache);
          }
        } else {
          child = parser.read(READERS);

          if (!child) {
            break;
          }

          children.push(child);
        }
      } while (!closed);

      if (unlessBlock) {
        section.l = unlessBlock;
      }

      if (!aliasOnly) {
        refineExpression(expression, section);
      }

      if (block === 'await' && (inlineThen || !hasThen) && !hasCatch && !hasElse) {
        var s$1 = { f: section.f };
        section.f = [s$1];
        if (inlineThen) {
          s$1.t = THEN;
          inlineThen !== true && (s$1.n = inlineThen);
        } else {
          s$1.t = SECTION;
        }
      }

      // TODO if a section is empty it should be discarded. Don't do
      // that here though - we need to clean everything up first, as
      // it may contain removeable whitespace. As a temporary measure,
      // to pass the existing tests, remove empty `f` arrays
      if (!section.f.length) {
        delete section.f;
      }

      return section;
    }

    var OPEN_COMMENT = '<!--';
    var CLOSE_COMMENT = '-->';

    function readHtmlComment(parser) {
      var start = parser.pos;

      if (parser.textOnlyMode || !parser.matchString(OPEN_COMMENT)) {
        return null;
      }

      var remaining = parser.remaining();
      var endIndex = remaining.indexOf(CLOSE_COMMENT);

      if (endIndex === -1) {
        parser.error("Illegal HTML - expected closing comment sequence ('-->')");
      }

      var content = remaining.substr(0, endIndex);
      parser.pos += endIndex + 3;

      var comment = {
        t: COMMENT,
        c: content
      };

      if (parser.includeLinePositions) {
        comment.q = parser.getLinePos(start);
      }

      return comment;
    }

    var leadingLinebreak = /^[ \t\f\r\n]*\r?\n/;
    var trailingLinebreak = /\r?\n[ \t\f\r\n]*$/;

    function stripStandalones(items, preserveStandaloneSections) {
      var i, current, backOne, backTwo, lastSectionItem;

      for (i = 1; i < items.length; i += 1) {
        current = items[i];
        backOne = items[i - 1];
        backTwo = items[i - 2];

        // if we're at the end of a [text][comment][text] sequence...
        if (isString(current) && isComment(backOne) && isString(backTwo)) {
          // ... and the comment is a standalone (i.e. line breaks either side)...
          if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {
            // ... then we want to remove the whitespace after the first line break
            items[i - 2] = backTwo.replace(trailingLinebreak, '\n');

            // and the leading line break of the second text token
            items[i] = current.replace(leadingLinebreak, '');
          }
        }

        if (!preserveStandaloneSections) {
          // if the current item is a section, and it is preceded by a linebreak, and
          // its first item is a linebreak...
          if (isSection(current) && isString(backOne)) {
            if (
              trailingLinebreak.test(backOne) &&
              isString(current.f[0]) &&
              leadingLinebreak.test(current.f[0])
            ) {
              items[i - 1] = backOne.replace(trailingLinebreak, '\n');
              current.f[0] = current.f[0].replace(leadingLinebreak, '');
            }
          }

          // if the last item was a section, and it is followed by a linebreak, and
          // its last item is a linebreak...
          if (isString(current) && isSection(backOne)) {
            lastSectionItem = lastItem(backOne.f);

            if (
              isString(lastSectionItem) &&
              trailingLinebreak.test(lastSectionItem) &&
              leadingLinebreak.test(current)
            ) {
              backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, '\n');
              items[i] = current.replace(leadingLinebreak, '');
            }
          }
        }
      }

      return items;
    }

    function isComment(item) {
      return item.t === COMMENT || item.t === DELIMCHANGE;
    }

    function isSection(item) {
      return (item.t === SECTION || item.t === INVERTED) && item.f;
    }

    function trimWhitespace(items, leadingPattern, trailingPattern) {
      var item;

      if (leadingPattern) {
        item = items[0];
        if (isString(item)) {
          item = item.replace(leadingPattern, '');

          if (!item) {
            items.shift();
          } else {
            items[0] = item;
          }
        }
      }

      if (trailingPattern) {
        item = lastItem(items);
        if (isString(item)) {
          item = item.replace(trailingPattern, '');

          if (!item) {
            items.pop();
          } else {
            items[items.length - 1] = item;
          }
        }
      }
    }

    var contiguousWhitespace = /[ \t\f\r\n]+/g;
    var leadingWhitespace$1 = /^[ \t\f\r\n]+/;
    var trailingWhitespace = /[ \t\f\r\n]+$/;
    var leadingNewLine = /^(?:\r\n|\r|\n)/;
    var trailingNewLine = /(?:\r\n|\r|\n)$/;
    var trailingIndent = /(\n)?[ \t]*$/;
    var leadingLine = /[ \t]*\n/;

    function cleanup(
      items,
      stripComments,
      preserveWhitespace,
      removeLeadingWhitespace,
      removeTrailingWhitespace,
      whiteSpaceElements,
      preserveStandaloneSections
    ) {
      if (isString(items)) { return; }

      var i,
        item,
        previousItem,
        nextItem,
        preserveWhitespaceInsideFragment,
        removeLeadingWhitespaceInsideFragment,
        removeTrailingWhitespaceInsideFragment;

      // First pass - remove standalones and comments etc
      stripStandalones(items, preserveStandaloneSections);

      i = items.length;
      while (i--) {
        item = items[i];

        // Remove delimiter changes, unsafe elements etc
        if (item.exclude) {
          items.splice(i, 1);
        } else if (stripComments && item.t === COMMENT) {
          // Remove comments, unless we want to keep them
          items.splice(i, 1);
        }
      }

      // If necessary, remove leading and trailing whitespace
      trimWhitespace(
        items,
        removeLeadingWhitespace ? leadingWhitespace$1 : null,
        removeTrailingWhitespace ? trailingWhitespace : null
      );

      i = items.length;
      while (i--) {
        item = items[i];
        removeLeadingWhitespaceInsideFragment = removeTrailingWhitespaceInsideFragment = false;

        if (item.w) {
          var prev = items[i - 1];
          var hitLast = true;
          if (typeof prev === 'string') { items[i - 1] = prev.replace(trailingIndent, '$1'); }
          if (item.f) {
            if (typeof item.f[0] === 'string') { item.f[0] = item.f[0].replace(leadingLine, ''); }
            var last = item.f.length - 1;
            if (typeof item.f[last] === 'string') {
              item.f[last] = item.f[last].replace(trailingIndent, function (_m, str) {
                hitLast = str;
                return str || '';
              });
            }
          }
          var next = items[i + 1];
          if (hitLast && typeof next === 'string') { items[i + 1] = next.replace(leadingLine, ''); }
        }

        // Recurse
        if (item.f) {
          var isPreserveWhitespaceElement =
            item.t === ELEMENT &&
            (whiteSpaceElements[item.e.toLowerCase()] || whiteSpaceElements[item.e]);
          preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

          if (!preserveWhitespace && isPreserveWhitespaceElement) {
            trimWhitespace(item.f, leadingNewLine, trailingNewLine);
          }

          if (!preserveWhitespaceInsideFragment) {
            previousItem = items[i - 1];
            nextItem = items[i + 1];

            // if the previous item was a text item with trailing whitespace,
            // remove leading whitespace inside the fragment
            if (!previousItem || (isString(previousItem) && trailingWhitespace.test(previousItem))) {
              removeLeadingWhitespaceInsideFragment = true;
            }

            // and vice versa
            if (!nextItem || (isString(nextItem) && leadingWhitespace$1.test(nextItem))) {
              removeTrailingWhitespaceInsideFragment = true;
            }
          }

          cleanup(
            item.f,
            stripComments,
            preserveWhitespaceInsideFragment,
            removeLeadingWhitespaceInsideFragment,
            removeTrailingWhitespaceInsideFragment,
            whiteSpaceElements
          );
        }

        // Split if-else blocks into two (an if, and an unless)
        if (item.l) {
          if (item.w) { item.l.forEach(function (l) { return (l.w = 1); }); }
          cleanup(
            item.l,
            stripComments,
            preserveWhitespace,
            removeLeadingWhitespaceInsideFragment,
            removeTrailingWhitespaceInsideFragment,
            whiteSpaceElements
          );

          item.l.forEach(function (s) { return (s.l = 1); });
          item.l.unshift(i + 1, 0);
          items.splice.apply(items, item.l);
          delete item.l; // TODO would be nice if there was a way around this
        }

        // Clean up conditional attributes
        if (item.m) {
          cleanup(
            item.m,
            stripComments,
            preserveWhitespace,
            removeLeadingWhitespaceInsideFragment,
            removeTrailingWhitespaceInsideFragment,
            whiteSpaceElements
          );
          if (item.m.length < 1) { delete item.m; }
        }

        delete item.w;
      }

      // final pass - fuse text nodes together
      i = items.length;
      while (i--) {
        if (isString(items[i])) {
          if (isString(items[i + 1])) {
            items[i] = items[i] + items[i + 1];
            items.splice(i + 1, 1);
          }

          if (!preserveWhitespace) {
            items[i] = items[i].replace(contiguousWhitespace, ' ');
          }

          if (items[i] === '') {
            items.splice(i, 1);
          }
        }
      }
    }

    var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;

    function readClosingTag(parser) {
      var tag;

      var start = parser.pos;

      // are we looking at a closing tag?
      if (!parser.matchString('</')) {
        return null;
      }

      if ((tag = parser.matchPattern(closingTagPattern))) {
        if (parser.inside && tag !== parser.inside) {
          parser.pos = start;
          return null;
        }

        return {
          t: CLOSING_TAG,
          e: tag
        };
      }

      // We have an illegal closing tag, report it
      parser.pos -= 2;
      parser.error('Illegal closing tag');
    }

    function hyphenateCamel(camelCaseStr) {
      return camelCaseStr.replace(/([A-Z])/g, function (match, $1) {
        return '-' + $1.toLowerCase();
      });
    }

    var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
    var anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/;
    var validTagNameFollower = /^[\s\n\/>]/;
    var semiEnd = /;\s*$/;
    var exclude = { exclude: true };

    // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
    var disallowedContents = {
      li: ['li'],
      dt: ['dt', 'dd'],
      dd: ['dt', 'dd'],
      p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(
        ' '
      ),
      rt: ['rt', 'rp'],
      rp: ['rt', 'rp'],
      optgroup: ['optgroup'],
      option: ['option', 'optgroup'],
      thead: ['tbody', 'tfoot'],
      tbody: ['tbody', 'tfoot'],
      tfoot: ['tbody'],
      tr: ['tr', 'tbody'],
      td: ['td', 'th', 'tr'],
      th: ['td', 'th', 'tr']
    };

    function readElement$1(parser) {
      var attribute,
        selfClosing,
        children,
        partials,
        hasPartials,
        child,
        closed,
        pos,
        remaining,
        closingTag,
        anchor;

      var start = parser.pos;

      if (parser.inside || parser.inAttribute || parser.textOnlyMode) {
        return null;
      }

      if (!parser.matchString('<')) {
        return null;
      }

      // if this is a closing tag, abort straight away
      if (parser.nextChar() === '/') {
        return null;
      }

      var element = {};
      if (parser.includeLinePositions) {
        element.q = parser.getLinePos(start);
      }

      // check for doctype decl
      if (parser.matchString('!')) {
        element.t = DOCTYPE;
        if (!parser.matchPattern(/^doctype/i)) {
          parser.error('Expected DOCTYPE declaration');
        }

        element.a = parser.matchPattern(/^(.+?)>/);
        return element;
      } else if ((anchor = parser.matchString('#'))) {
        // check for anchor
        parser.sp();
        element.t = ANCHOR;
        element.n = parser.matchPattern(anchorPattern);
      } else {
        // otherwise, it's an element/component
        element.t = ELEMENT;

        // element name
        element.e = parser.matchPattern(tagNamePattern);
        if (!element.e) {
          return null;
        }
      }

      // next character must be whitespace, closing solidus or '>'
      if (!validTagNameFollower.test(parser.nextChar())) {
        parser.error('Illegal tag name');
      }

      parser.sp();

      parser.inTag = true;

      // directives and attributes
      while ((attribute = readMustache(parser))) {
        if (attribute !== false) {
          if (!element.m) { element.m = []; }
          element.m.push(attribute);
        }

        parser.sp();
      }

      parser.inTag = false;

      // allow whitespace before closing solidus
      parser.sp();

      // self-closing solidus?
      if (parser.matchString('/')) {
        selfClosing = true;
      }

      // closing angle bracket
      if (!parser.matchString('>')) {
        return null;
      }

      var lowerCaseName = (element.e || element.n).toLowerCase();
      var preserveWhitespace = parser.preserveWhitespace;

      if (!selfClosing && (anchor || !voidElements[element.e.toLowerCase()])) {
        if (!anchor) {
          parser.elementStack.push(lowerCaseName);

          // Special case - if we open a script element, further tags should
          // be ignored unless they're a closing script element
          if (lowerCaseName in parser.interpolate) {
            parser.inside = lowerCaseName;
          }
        }

        children = [];
        partials = create(null);

        do {
          pos = parser.pos;
          remaining = parser.remaining();

          if (!remaining) {
            // if this happens to be a script tag and there's no content left, it's because
            // a closing script tag can't appear in a script
            if (parser.inside === 'script') {
              closed = true;
              break;
            }

            parser.error(
              ("Missing end " + (parser.elementStack.length > 1 ? 'tags' : 'tag') + " (" + (parser.elementStack
                .reverse()
                .map(function (x) { return ("</" + x + ">"); })
                .join('')) + ")")
            );
          }

          // if for example we're in an <li> element, and we see another
          // <li> tag, close the first so they become siblings
          if (!anchor && !canContain(lowerCaseName, remaining)) {
            closed = true;
          } else if (!anchor && (closingTag = readClosingTag(parser))) {
            // closing tag
            closed = true;

            var closingTagName = closingTag.e.toLowerCase();

            // if this *isn't* the closing tag for the current element...
            if (closingTagName !== lowerCaseName) {
              // rewind parser
              parser.pos = pos;

              // if it doesn't close a parent tag, error
              if (!~parser.elementStack.indexOf(closingTagName)) {
                var errorMessage = 'Unexpected closing tag';

                // add additional help for void elements, since component names
                // might clash with them
                if (voidElements[closingTagName.toLowerCase()]) {
                  errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
                }

                parser.error(errorMessage);
              }
            }
          } else if (anchor && readAnchorClose(parser, element.n)) {
            closed = true;
          } else {
            // implicit close by closing section tag. TODO clean this up
            var tag = {
              open: parser.standardDelimiters[0],
              close: parser.standardDelimiters[1]
            };
            if (readClosing(parser, tag) || readInline(parser, tag)) {
              closed = true;
              parser.pos = pos;
            } else if ((child = parser.read(PARTIAL_READERS))) {
              if (partials[child.n]) {
                parser.pos = pos;
                parser.error('Duplicate partial definition');
              }

              cleanup(
                child.f,
                parser.stripComments,
                preserveWhitespace,
                !preserveWhitespace,
                !preserveWhitespace,
                parser.whiteSpaceElements
              );

              partials[child.n] = child.f;
              hasPartials = true;
            } else {
              if ((child = parser.read(READERS))) {
                children.push(child);
              } else {
                closed = true;
              }
            }
          }
        } while (!closed);

        if (children.length) {
          element.f = children;
        }

        if (hasPartials) {
          element.p = partials;
        }

        parser.elementStack.pop();
      }

      parser.inside = null;

      if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {
        return exclude;
      }

      if (
        element.m &&
        lowerCaseName !== 'input' &&
        lowerCaseName !== 'select' &&
        lowerCaseName !== 'textarea' &&
        lowerCaseName !== 'option'
      ) {
        var attrs = element.m;
        var classes, styles, cls, style;
        var i = 0;
        var a;
        while (i < attrs.length) {
          a = attrs[i];

          if (a.t !== ATTRIBUTE) {
            i++;
            continue;
          }

          if (a.n.indexOf('class-') === 0 && !a.f) {
            // static class directives
            (classes || (classes = [])).push(a.n.slice(6));
            attrs.splice(i, 1);
          } else if (a.n.indexOf('style-') === 0 && isString(a.f)) {
            // static style directives
            (styles || (styles = [])).push(((hyphenateCamel(a.n.slice(6))) + ": " + (a.f) + ";"));
            attrs.splice(i, 1);
          } else if (a.n === 'class' && isString(a.f)) {
            // static class attrs
            (classes || (classes = [])).push(a.f);
            attrs.splice(i, 1);
          } else if (a.n === 'style' && isString(a.f)) {
            // static style attrs
            (styles || (styles = [])).push(a.f + (semiEnd.test(a.f) ? '' : ';'));
            attrs.splice(i, 1);
          } else if (a.n === 'class') {
            cls = a;
            i++;
          } else if (a.n === 'style') {
            style = a;
            i++;
          } else if (
            !~a.n.indexOf(':') &&
            a.n !== 'value' &&
            a.n !== 'contenteditable' &&
            isString(a.f)
          ) {
            a.g = 1;
            i++;
          } else {
            i++;
          }
        }

        if (classes) {
          if (!cls || !isString(cls.f))
            { attrs.unshift({ t: ATTRIBUTE, n: 'class', f: classes.join(' '), g: 1 }); }
          else { cls.f += ' ' + classes.join(' '); }
        } else if (cls && isString(cls.f)) { cls.g = 1; }

        if (styles) {
          if (!style || !isString(style.f))
            { attrs.unshift({ t: ATTRIBUTE, n: 'style', f: styles.join(' '), g: 1 }); }
          else { style.f += '; ' + styles.join(' '); }
        } else if (style && isString(style.f)) { style.g = 1; }
      }

      return element;
    }

    function canContain(name, remaining) {
      var match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);
      var disallowed = disallowedContents[name];

      if (!match || !disallowed) {
        return true;
      }

      return !~disallowed.indexOf(match[1].toLowerCase());
    }

    function readAnchorClose(parser, name) {
      var pos = parser.pos;
      if (!parser.matchString('</')) {
        return null;
      }

      parser.matchString('#');
      parser.sp();

      if (!parser.matchString(name)) {
        parser.pos = pos;
        return null;
      }

      parser.sp();

      if (!parser.matchString('>')) {
        parser.pos = pos;
        return null;
      }

      return true;
    }

    var inlines = /^\s*(elseif|else|then|catch)\s*/;
    function readInline(parser, tag) {
      var pos = parser.pos;
      if (!parser.matchString(tag.open)) { return; }
      if (parser.matchPattern(inlines)) {
        return true;
      } else {
        parser.pos = pos;
      }
    }

    function readText(parser) {
      var index, disallowed, barrier;

      var remaining = parser.remaining();

      if (parser.textOnlyMode) {
        disallowed = parser.tags.map(function (t) { return t.open; });
        disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\' + t.open; }));

        index = getLowestIndex(remaining, disallowed);
      } else {
        barrier = parser.inside ? '</' + parser.inside : '<';

        if (parser.inside && !parser.interpolate[parser.inside]) {
          index = remaining.indexOf(barrier);
        } else {
          disallowed = parser.tags.map(function (t) { return t.open; });
          disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\' + t.open; }));

          // http://developers.whatwg.org/syntax.html#syntax-attributes
          if (parser.inAttribute === true) {
            // we're inside an unquoted attribute value
            disallowed.push("\"", "'", "=", "<", ">", '`');
          } else if (parser.inAttribute) {
            // quoted attribute value
            disallowed.push(parser.inAttribute);
          } else {
            disallowed.push(barrier);
          }

          index = getLowestIndex(remaining, disallowed);
        }
      }

      if (!index) {
        return null;
      }

      if (index === -1) {
        index = remaining.length;
      }

      parser.pos += index;

      if ((parser.inside && parser.inside !== 'textarea') || parser.textOnlyMode) {
        return remaining.substr(0, index);
      } else {
        return decodeCharacterReferences(remaining.substr(0, index));
      }
    }

    var partialDefinitionSectionPattern = /^\s*#\s*partial\s+/;

    function readPartialDefinitionSection(parser) {
      var child, closed;

      var start = parser.pos;

      var delimiters = parser.standardDelimiters;

      if (!parser.matchString(delimiters[0])) {
        return null;
      }

      if (!parser.matchPattern(partialDefinitionSectionPattern)) {
        parser.pos = start;
        return null;
      }

      var name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-\/]*/);

      if (!name) {
        parser.error('expected legal partial name');
      }

      parser.sp();
      if (!parser.matchString(delimiters[1])) {
        parser.error(("Expected closing delimiter '" + (delimiters[1]) + "'"));
      }

      var content = [];

      var open = delimiters[0];
      var close = delimiters[1];

      do {
        if ((child = readClosing(parser, { open: open, close: close }))) {
          if (child.r !== 'partial') {
            parser.error(("Expected " + open + "/partial" + close));
          }

          closed = true;
        } else {
          child = parser.read(READERS);

          if (!child) {
            parser.error(("Expected " + open + "/partial" + close));
          }

          content.push(child);
        }
      } while (!closed);

      return {
        t: INLINE_PARTIAL,
        n: name,
        f: content
      };
    }

    function readTemplate(parser) {
      var fragment = [];
      var partials = create(null);
      var hasPartials = false;

      var preserveWhitespace = parser.preserveWhitespace;

      while (parser.pos < parser.str.length) {
        var pos = parser.pos;
        var item = (void 0), partial = (void 0);

        if ((partial = parser.read(PARTIAL_READERS))) {
          if (partials[partial.n]) {
            parser.pos = pos;
            parser.error('Duplicated partial definition');
          }

          cleanup(
            partial.f,
            parser.stripComments,
            preserveWhitespace,
            !preserveWhitespace,
            !preserveWhitespace,
            parser.whiteSpaceElements
          );

          partials[partial.n] = partial.f;
          hasPartials = true;
        } else if ((item = parser.read(READERS))) {
          fragment.push(item);
        } else {
          parser.error('Unexpected template content');
        }
      }

      var result = {
        v: TEMPLATE_VERSION,
        t: fragment
      };

      if (hasPartials) {
        result.p = partials;
      }

      return result;
    }

    function insertExpressions(obj, expr) {
      keys(obj).forEach(function (key) {
        if (isExpression(key, obj)) { return addTo(obj, expr); }

        var ref = obj[key];
        if (hasChildren(ref)) { insertExpressions(ref, expr); }
      });
    }

    function isExpression(key, obj) {
      return key === 's' && isArray(obj.r);
    }

    function addTo(obj, expr) {
      var s = obj.s;
      var r = obj.r;
      if (!expr[s]) { expr[s] = fromExpression(s, r.length); }
    }

    function hasChildren(ref) {
      return isArray(ref) || isObject(ref);
    }

    var shared = {};

    // See https://github.com/ractivejs/template-spec for information
    // about the Ractive template specification

    var STANDARD_READERS = [
      readPartial,
      readUnescaped,
      readSection,
      readInterpolator,
      readComment
    ];
    var TRIPLE_READERS = [readTriple];

    var READERS = [readMustache, readHtmlComment, readElement$1, readText];
    var PARTIAL_READERS = [readPartialDefinitionSection];

    var preserveWhitespaceElements = { pre: 1, script: 1, style: 1, textarea: 1 };

    var defaultInterpolate = { textarea: true, script: true, style: true, template: true };

    var StandardParser = Parser.extend({
      init: function init(str, options) {
        var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;
        var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;
        var staticTripleDelimiters =
          options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;

        this.standardDelimiters = options.delimiters || shared.defaults.delimiters;

        this.tags = [
          {
            isStatic: false,
            isTriple: false,
            open: this.standardDelimiters[0],
            close: this.standardDelimiters[1],
            readers: STANDARD_READERS
          },
          {
            isStatic: false,
            isTriple: true,
            open: tripleDelimiters[0],
            close: tripleDelimiters[1],
            readers: TRIPLE_READERS
          },
          {
            isStatic: true,
            isTriple: false,
            open: staticDelimiters[0],
            close: staticDelimiters[1],
            readers: STANDARD_READERS
          },
          {
            isStatic: true,
            isTriple: true,
            open: staticTripleDelimiters[0],
            close: staticTripleDelimiters[1],
            readers: TRIPLE_READERS
          }
        ];

        this.contextLines = options.contextLines || shared.defaults.contextLines;

        this.sortMustacheTags();

        this.sectionDepth = 0;
        this.elementStack = [];

        this.interpolate = assign(
          {},
          defaultInterpolate,
          shared.defaults.interpolate,
          options.interpolate
        );

        if (options.sanitize === true) {
          options.sanitize = {
            // blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
            elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split(
              ' '
            ),
            eventAttributes: true
          };
        }

        this.stripComments = options.stripComments !== false;
        this.preserveWhitespace = isObjectType(options.preserveWhitespace)
          ? false
          : options.preserveWhitespace;
        this.sanitizeElements = options.sanitize && options.sanitize.elements;
        this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
        this.includeLinePositions = options.includeLinePositions;
        this.textOnlyMode = options.textOnlyMode;
        this.csp = options.csp;
        this.allowExpressions = options.allowExpressions;

        this.preserveStandaloneSections = this.preserveWhitespace && options.preserveStandaloneSections;

        if (options.expression) { this.converters = [readExpression]; }

        if (options.attributes) { this.inTag = true; }

        // special whitespace handling requested for certain elements
        this.whiteSpaceElements = assign({}, options.preserveWhitespace, preserveWhitespaceElements);
      },

      postProcess: function postProcess(result, options) {
        var parserResult = result[0];

        if (options.expression) {
          var expr = flattenExpression(parserResult);
          expr.e = fromExpression(expr.s, expr.r.length);
          return expr;
        } else {
          // special case - empty string
          if (!result.length) {
            return { t: [], v: TEMPLATE_VERSION };
          }

          if (this.sectionDepth > 0) {
            this.error('A section was left open');
          }

          cleanup(
            parserResult.t,
            this.stripComments,
            this.preserveWhitespace,
            !this.preserveWhitespace,
            !this.preserveWhitespace,
            this.whiteSpaceElements,
            this.preserveStandaloneSections
          );

          if (this.csp !== false) {
            var expr$1 = {};

            insertExpressions(parserResult.t, expr$1);
            insertExpressions(parserResult.p || {}, expr$1);

            if (keys(expr$1).length) { parserResult.e = expr$1; }
          }

          return parserResult;
        }
      },

      converters: [readTemplate],

      sortMustacheTags: function sortMustacheTags() {
        // Sort in order of descending opening delimiter length (longer first),
        // to protect against opening delimiters being substrings of each other
        this.tags.sort(function (a, b) {
          return b.open.length - a.open.length;
        });
      }
    });

    function parse(template, options) {
      return new StandardParser(template, options || {}).result;
    }

    var parseOptions = [
      'delimiters',
      'tripleDelimiters',
      'staticDelimiters',
      'staticTripleDelimiters',
      'csp',
      'interpolate',
      'preserveWhitespace',
      'preserveStandaloneSections',
      'sanitize',
      'stripComments',
      'contextLines',
      'allowExpressions',
      'attributes'
    ];

    var TEMPLATE_INSTRUCTIONS = "Either preparse or use a ractive runtime source that includes the parser. ";

    var COMPUTATION_INSTRUCTIONS = "Either include a version of Ractive that can parse or convert your computation strings to functions.";

    function throwNoParse(method, error, instructions) {
      if (!method) {
        fatal(("Missing Ractive.parse - cannot parse " + error + ". " + instructions));
      }
    }

    function createFunction(body, length) {
      throwNoParse(fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS);
      return fromExpression(body, length);
    }

    function createFunctionFromString(str, bindTo) {
      throwNoParse(parse, 'compution string "${str}"', COMPUTATION_INSTRUCTIONS);
      var tpl = parse(str, { expression: true });
      return function() {
        return tpl.e.apply(bindTo, tpl.r.map(function (r) { return bindTo.get(r); }));
      };
    }

    var parser = {
      fromId: function fromId(id, options) {
        if (!doc) {
          if (options && options.noThrow) {
            return;
          }
          throw new Error(("Cannot retrieve template #" + id + " as Ractive is not running in a browser."));
        }

        if (id) { id = id.replace(/^#/, ''); }

        var template;

        if (!(template = doc.getElementById(id))) {
          if (options && options.noThrow) {
            return;
          }
          throw new Error(("Could not find template element with id #" + id));
        }

        if (template.tagName.toUpperCase() !== 'SCRIPT') {
          if (options && options.noThrow) {
            return;
          }
          throw new Error(("Template element with id #" + id + ", must be a <script> element"));
        }

        return 'textContent' in template ? template.textContent : template.innerHTML;
      },

      isParsed: function isParsed(template) {
        return !isString(template);
      },

      getParseOptions: function getParseOptions(ractive) {
        // Could be Ractive or a Component
        if (ractive.defaults) {
          ractive = ractive.defaults;
        }

        return parseOptions.reduce(function (val, key) {
          val[key] = ractive[key];
          return val;
        }, {});
      },

      parse: function parse$1(template, options) {
        throwNoParse(parse, 'template', TEMPLATE_INSTRUCTIONS);
        var parsed = parse(template, options);
        addFunctions(parsed);
        return parsed;
      },

      parseFor: function parseFor(template, ractive) {
        return this.parse(template, this.getParseOptions(ractive));
      }
    };

    function getComputationSignature(ractive, key, signature) {
      var getter;
      var setter;

      // useful for debugging
      var getterString;
      var getterUseStack;
      var setterString;

      if (isFunction(signature)) {
        getter = bind(signature, ractive);
        getterString = signature.toString();
        getterUseStack = true;
      }

      if (isString(signature)) {
        getter = createFunctionFromString(signature, ractive);
        getterString = signature;
      }

      if (isObjectType(signature)) {
        if (isString(signature.get)) {
          getter = createFunctionFromString(signature.get, ractive);
          getterString = signature.get;
        } else if (isFunction(signature.get)) {
          getter = bind(signature.get, ractive);
          getterString = signature.get.toString();
          getterUseStack = true;
        } else {
          fatal('`%s` computation must have a `get()` method', key);
        }

        if (isFunction(signature.set)) {
          setter = bind(signature.set, ractive);
          setterString = signature.set.toString();
        }
      }

      return {
        getter: getter,
        setter: setter,
        getterString: getterString,
        setterString: setterString,
        getterUseStack: getterUseStack
      };
    }

    var id = 0;

    var TransitionManager = function TransitionManager(callback, parent) {
      this.callback = callback;
      this.parent = parent;

      this.intros = [];
      this.outros = [];

      this.children = [];
      this.totalChildren = this.outroChildren = 0;

      this.detachQueue = [];
      this.outrosComplete = false;

      this.id = id++;

      if (parent) {
        parent.addChild(this);
      }
    };
    var TransitionManager__proto__ = TransitionManager.prototype;

    TransitionManager__proto__.add = function add (transition) {
      var list = transition.isIntro ? this.intros : this.outros;
      transition.starting = true;
      list.push(transition);
    };

    TransitionManager__proto__.addChild = function addChild (child) {
      this.children.push(child);

      this.totalChildren += 1;
      this.outroChildren += 1;
    };

    TransitionManager__proto__.checkStart = function checkStart () {
      if (this.parent && this.parent.started) { this.start(); }
    };

    TransitionManager__proto__.decrementOutros = function decrementOutros () {
      this.outroChildren -= 1;
      check(this);
    };

    TransitionManager__proto__.decrementTotal = function decrementTotal () {
      this.totalChildren -= 1;
      check(this);
    };

    TransitionManager__proto__.detachNodes = function detachNodes () {
        var this$1 = this;

      var len = this.detachQueue.length;
      for (var i = 0; i < len; i++) { this$1.detachQueue[i].detach(); }
      len = this.children.length;
      for (var i$1 = 0; i$1 < len; i$1++) { this$1.children[i$1].detachNodes(); }
      this.detachQueue = [];
    };

    TransitionManager__proto__.ready = function ready () {
      if (this.detachQueue.length) { detachImmediate(this); }
    };

    TransitionManager__proto__.remove = function remove (transition) {
      var list = transition.isIntro ? this.intros : this.outros;
      removeFromArray(list, transition);
      check(this);
    };

    TransitionManager__proto__.start = function start () {
      this.started = true;
      this.children.forEach(function (c) { return c.start(); });
      this.intros.concat(this.outros).forEach(function (t) { return t.start(); });
      check(this);
    };

    function check(tm) {
      if (!tm.started || tm.outros.length || tm.outroChildren) { return; }

      // If all outros are complete, and we haven't already done this,
      // we notify the parent if there is one, otherwise
      // start detaching nodes
      if (!tm.outrosComplete) {
        tm.outrosComplete = true;

        if (tm.parent) { tm.parent.decrementOutros(tm); }

        if (allOutrosComplete(tm)) {
          tm.detachNodes();
        }
      }

      // Once everything is done, we can notify parent transition
      // manager and call the callback
      if (!tm.intros.length && !tm.totalChildren) {
        if (isFunction(tm.callback)) {
          tm.callback();
        }

        if (tm.parent && !tm.notifiedTotal) {
          tm.notifiedTotal = true;
          tm.parent.decrementTotal();
        }
      }
    }

    function allOutrosComplete(manager) {
      return !manager || (manager.outrosComplete && allOutrosComplete(manager.parent));
    }

    // check through the detach queue to see if a node is up or downstream from a
    // transition and if not, go ahead and detach it
    function detachImmediate(manager) {
      var queue = manager.detachQueue;
      var outros = collectAllOutros(manager);

      if (!outros.length) {
        manager.detachNodes();
      } else {
        var i = queue.length;
        var j = 0;
        var node, trans;
        var nqueue = (manager.detachQueue = []);

        start: while (i--) {
          node = queue[i].node;
          j = outros.length;
          while (j--) {
            trans = outros[j].element.node;
            // check to see if the node is, contains, or is contained by the transitioning node
            if (trans === node || trans.contains(node) || node.contains(trans)) {
              nqueue.push(queue[i]);
              continue start;
            }
          }

          // no match, we can drop it
          queue[i].detach();
        }
      }
    }

    function collectAllOutros(manager, _list) {
      var list = _list;

      // if there's no list, we're starting at the root to build one
      if (!list) {
        list = [];
        var parent = manager;
        while (parent.parent) { parent = parent.parent; }
        return collectAllOutros(parent, list);
      } else {
        // grab all outros from child managers
        var i = manager.children.length;
        while (i--) {
          list = collectAllOutros(manager.children[i], list);
        }

        // grab any from this manager if there are any
        if (manager.outros.length) { list = list.concat(manager.outros); }

        return list;
      }
    }

    var batch;

    var runloop = {
      active: function active() {
        return !!batch;
      },

      start: function start() {
        var fulfilPromise;
        var promise = new Promise(function (f) { return (fulfilPromise = f); });

        batch = {
          previousBatch: batch,
          transitionManager: new TransitionManager(fulfilPromise, batch && batch.transitionManager),
          fragments: [],
          tasks: [],
          immediateObservers: [],
          deferredObservers: [],
          promise: promise
        };

        return promise;
      },

      end: function end() {
        flushChanges();

        if (!batch.previousBatch) { batch.transitionManager.start(); }
        else { batch.transitionManager.checkStart(); }

        batch = batch.previousBatch;
      },

      addFragment: function addFragment(fragment) {
        addToArray(batch.fragments, fragment);
      },

      // TODO: come up with a better way to handle fragments that trigger their own update
      addFragmentToRoot: function addFragmentToRoot(fragment) {
        if (!batch) { return; }

        var b = batch;
        while (b.previousBatch) {
          b = b.previousBatch;
        }

        addToArray(b.fragments, fragment);
      },

      addObserver: function addObserver(observer, defer) {
        if (!batch) {
          observer.dispatch();
        } else {
          addToArray(defer ? batch.deferredObservers : batch.immediateObservers, observer);
        }
      },

      registerTransition: function registerTransition(transition) {
        transition._manager = batch.transitionManager;
        batch.transitionManager.add(transition);
      },

      // synchronise node detachments with transition ends
      detachWhenReady: function detachWhenReady(thing) {
        batch.transitionManager.detachQueue.push(thing);
      },

      scheduleTask: function scheduleTask(task, postRender) {
        var _batch;

        if (!batch) {
          task();
        } else {
          _batch = batch;
          while (postRender && _batch.previousBatch) {
            // this can't happen until the DOM has been fully updated
            // otherwise in some situations (with components inside elements)
            // transitions and decorators will initialise prematurely
            _batch = _batch.previousBatch;
          }

          _batch.tasks.push(task);
        }
      },

      promise: function promise() {
        if (!batch) { return Promise.resolve(); }

        var target = batch;
        while (target.previousBatch) {
          target = target.previousBatch;
        }

        return target.promise || Promise.resolve();
      }
    };

    function dispatch(observer) {
      observer.dispatch();
    }

    function flushChanges() {
      var which = batch.immediateObservers;
      batch.immediateObservers = [];
      which.forEach(dispatch);

      // Now that changes have been fully propagated, we can update the DOM
      // and complete other tasks
      var i = batch.fragments.length;
      var fragment;

      which = batch.fragments;
      batch.fragments = [];

      while (i--) {
        fragment = which[i];
        fragment.update();
      }

      batch.transitionManager.ready();

      which = batch.deferredObservers;
      batch.deferredObservers = [];
      which.forEach(dispatch);

      var tasks = batch.tasks;
      batch.tasks = [];

      for (i = 0; i < tasks.length; i += 1) {
        tasks[i]();
      }

      // If updating the view caused some model blowback - e.g. a triple
      // containing <option> elements caused the binding on the <select>
      // to update - then we start over
      if (
        batch.fragments.length ||
        batch.immediateObservers.length ||
        batch.deferredObservers.length ||
        batch.tasks.length
      )
        { return flushChanges(); }
    }

    // TODO what happens if a transition is aborted?

    var tickers = [];
    var running = false;

    function tick() {
      runloop.start();

      var now = performance.now();

      var i;
      var ticker;

      for (i = 0; i < tickers.length; i += 1) {
        ticker = tickers[i];

        if (!ticker.tick(now)) {
          // ticker is complete, remove it from the stack, and decrement i so we don't miss one
          tickers.splice(i--, 1);
        }
      }

      runloop.end();

      if (tickers.length) {
        requestAnimationFrame(tick);
      } else {
        running = false;
      }
    }

    var Ticker = function Ticker(options) {
      this.duration = options.duration;
      this.step = options.step;
      this.complete = options.complete;
      this.easing = options.easing;

      this.start = performance.now();
      this.end = this.start + this.duration;

      this.running = true;

      tickers.push(this);
      if (!running) { requestAnimationFrame(tick); }
    };
    var Ticker__proto__ = Ticker.prototype;

    Ticker__proto__.tick = function tick (now) {
      if (!this.running) { return false; }

      if (now > this.end) {
        if (this.step) { this.step(1); }
        if (this.complete) { this.complete(1); }

        return false;
      }

      var elapsed = now - this.start;
      var eased = this.easing(elapsed / this.duration);

      if (this.step) { this.step(eased); }

      return true;
    };

    Ticker__proto__.stop = function stop () {
      if (this.abort) { this.abort(); }
      this.running = false;
    };

    var prefixers = {};

    // TODO this is legacy. sooner we can replace the old adaptor API the better
    /* istanbul ignore next */
    function prefixKeypath(obj, prefix) {
      var prefixed = {};

      if (!prefix) {
        return obj;
      }

      prefix += '.';

      for (var key in obj) {
        if (hasOwn(obj, key)) {
          prefixed[prefix + key] = obj[key];
        }
      }

      return prefixed;
    }

    function getPrefixer(rootKeypath) {
      var rootDot;

      if (!prefixers[rootKeypath]) {
        rootDot = rootKeypath ? rootKeypath + '.' : '';

        /* istanbul ignore next */
        prefixers[rootKeypath] = function(relativeKeypath, value) {
          var obj;

          if (isString(relativeKeypath)) {
            obj = {};
            obj[rootDot + relativeKeypath] = value;
            return obj;
          }

          if (isObjectType(relativeKeypath)) {
            // 'relativeKeypath' is in fact a hash, not a keypath
            return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;
          }
        };
      }

      return prefixers[rootKeypath];
    }

    var shared$1 = {};

    var Model = (function (ModelBase) {
      function Model(parent, key) {
        ModelBase.call(this, parent);

        this.ticker = null;

        if (parent) {
          this.key = unescapeKey(key);
          this.isReadonly = parent.isReadonly;

          if (parent.value) {
            this.value = parent.value[this.key];
            if (isArray(this.value)) { this.length = this.value.length; }
            this.adapt();
          }
        }
      }

      if ( ModelBase ) Model.__proto__ = ModelBase;
      var Model__proto__ = Model.prototype = Object.create( ModelBase && ModelBase.prototype );
      Model__proto__.constructor = Model;

      Model__proto__.adapt = function adapt () {
        var this$1 = this;

        var adaptors = this.root.adaptors;
        var len = adaptors.length;

        this.rewrap = false;

        // Exit early if no adaptors
        if (len === 0) { return; }

        var value = this.wrapper
          ? 'newWrapperValue' in this
            ? this.newWrapperValue
            : this.wrapperValue
          : this.value;

        // TODO remove this legacy nonsense
        var ractive = this.root.ractive;
        var keypath = this.getKeypath();

        // tear previous adaptor down if present
        if (this.wrapper) {
          var shouldTeardown =
            this.wrapperValue === value
              ? false
              : !this.wrapper.reset || this.wrapper.reset(value) === false;

          if (shouldTeardown) {
            this.wrapper.teardown();
            delete this.wrapper;
            delete this.wrapperValue;
            delete this.newWrapperValue;

            // don't branch for undefined values
            if (this.value !== undefined) {
              var parentValue = this.parent.value || this.parent.createBranch(this.key);
              if (parentValue[this.key] !== value) { parentValue[this.key] = value; }
              this.value = value;
            }
          } else {
            delete this.newWrapperValue;
            this.value = this.wrapper.get();
            return;
          }
        }

        var i;

        for (i = 0; i < len; i += 1) {
          var adaptor = adaptors[i];
          if (adaptor.filter(value, keypath, ractive)) {
            this$1.wrapper = adaptor.wrap(ractive, value, keypath, getPrefixer(keypath));
            this$1.wrapperValue = value;
            this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor

            this$1.value = this$1.wrapper.get();

            break;
          }
        }
      };

      Model__proto__.animate = function animate (from, to, options, interpolator) {
        var this$1 = this;

        if (this.ticker) { this.ticker.stop(); }

        var fulfilPromise;
        var promise = new Promise(function (fulfil) { return (fulfilPromise = fulfil); });

        this.ticker = new Ticker({
          duration: options.duration,
          easing: options.easing,
          step: function (t) {
            var value = interpolator(t);
            this$1.applyValue(value);
            if (options.step) { options.step(t, value); }
          },
          complete: function () {
            this$1.applyValue(to);
            if (options.complete) { options.complete(to); }

            this$1.ticker = null;
            fulfilPromise(to);
          }
        });

        promise.stop = this.ticker.stop;
        return promise;
      };

      Model__proto__.applyValue = function applyValue (value, notify) {
        if ( notify === void 0 ) notify = true;

        if (isEqual(value, this.value)) { return; }
        if (this.boundValue) { this.boundValue = null; }

        if (this.parent.wrapper && this.parent.wrapper.set) {
          this.parent.wrapper.set(this.key, value);
          this.parent.value = this.parent.wrapper.get();

          this.value = this.parent.value[this.key];
          if (this.wrapper) { this.newWrapperValue = this.value; }
          this.adapt();
        } else if (this.wrapper) {
          this.newWrapperValue = value;
          this.adapt();
        } else {
          var parentValue = this.parent.value || this.parent.createBranch(this.key);
          if (isObjectLike(parentValue)) {
            parentValue[this.key] = value;
          } else {
            warnIfDebug(("Attempted to set a property of a non-object '" + (this.getKeypath()) + "'"));
            return;
          }

          this.value = value;
          this.adapt();
        }

        if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {
          checkDataLink(this, value);
        }

        // keep track of array stuff
        if (isArray(value)) {
          this.length = value.length;
          this.isArray = true;
        } else {
          this.isArray = false;
        }

        // notify dependants
        this.links.forEach(handleChange);
        this.children.forEach(mark);
        this.deps.forEach(handleChange);

        if (notify) { this.notifyUpstream(); }

        if (this.parent.isArray) {
          if (this.key === 'length') { this.parent.length = value; }
          else { this.parent.joinKey('length').mark(); }
        }
      };

      Model__proto__.compute = function compute (key, computed) {
        var registry = this.computed || (this.computed = {});

        if (registry[key]) {
          registry[key].signature = getComputationSignature(this.root.ractive, key, computed);
          registry[key].mark();
        } else {
          registry[key] = new shared$1.Computation(
            this,
            getComputationSignature(this.root.ractive, key, computed),
            key
          );
        }

        return registry[key];
      };

      Model__proto__.createBranch = function createBranch (key) {
        var branch = isNumeric(key) ? [] : {};
        this.applyValue(branch, false);

        return branch;
      };

      Model__proto__.get = function get (shouldCapture, opts) {
        if (this._link) { return this._link.get(shouldCapture, opts); }
        if (shouldCapture) { capture(this); }
        // if capturing, this value needs to be unwrapped because it's for external use
        if (opts && opts.virtual) { return this.getVirtual(false); }
        return maybeBind(
          this,
          (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper
            ? this.wrapperValue
            : this.value,
          !opts || opts.shouldBind !== false
        );
      };

      Model__proto__.joinKey = function joinKey (key, opts) {
        var this$1 = this;

        if (this._link) {
          if (opts && opts.lastLink !== false && (isUndefined(key) || key === '')) { return this; }
          return this._link.joinKey(key);
        }

        if (isUndefined(key) || key === '') { return this; }

        var child;
        if (hasOwn(this.childByKey, key)) { child = this.childByKey[key]; }
        else { child = this.computed && this.computed[key]; }

        if (!child) {
          var computed;
          if (this.isRoot && this.ractive && (computed = this.ractive.computed[key])) {
            child = this.compute(key, computed);
          } else if (!this.isRoot && this.root.ractive) {
            var registry = this.root.ractive.computed;
            for (var k in registry) {
              computed = registry[k];
              if (computed.pattern && computed.pattern.test(this$1.getKeypath() + '.' + key)) {
                child = this$1.compute(key, computed);
              }
            }
          }
        }

        if (!child) {
          child = new Model(this, key);
          this.children.push(child);
          this.childByKey[key] = child;

          if (key === 'data') {
            var val = this.retrieve();
            if (val && val.viewmodel && val.viewmodel.isRoot) {
              // this needs to happen in a runloop, as it can cause bubbling
              var batch$$1 = runloop.active();
              if (!batch$$1) { runloop.start(); }

              child.link(val.viewmodel, 'data');
              this.dataModel = val;

              if (!batch$$1) { runloop.end(); }
            }
          }
        }

        if (child._link && (!opts || opts.lastLink !== false)) { return child._link; }

        return child;
      };

      Model__proto__.mark = function mark$1 (force) {
        if (this._link) { return this._link.mark(force); }

        var old = this.value;
        var value = this.retrieve();

        if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {
          checkDataLink(this, value);
        }

        if (force || !isEqual(value, old)) {
          this.value = value;
          if (this.boundValue) { this.boundValue = null; }

          // make sure the wrapper stays in sync
          if (old !== value || this.rewrap) {
            if (this.wrapper) { this.newWrapperValue = value; }
            this.adapt();
          }

          // keep track of array stuff
          if (isArray(value)) {
            this.length = value.length;
            this.isArray = true;
          } else {
            this.isArray = false;
          }

          this.children.forEach(force ? markForce : mark);
          this.links.forEach(marked);

          this.deps.forEach(handleChange);
        }
      };

      Model__proto__.merge = function merge (array, comparator) {
        var newIndices = buildNewIndices(
          this.value === array ? recreateArray(this) : this.value,
          array,
          comparator
        );
        this.parent.value[this.key] = array;
        this.shuffle(newIndices, true);
      };

      Model__proto__.retrieve = function retrieve () {
        return this.parent.value ? this.parent.value[this.key] : undefined;
      };

      Model__proto__.set = function set (value) {
        if (this.ticker) { this.ticker.stop(); }
        this.applyValue(value);
      };

      Model__proto__.shuffle = function shuffle$2 (newIndices, unsafe) {
        shuffle(this, newIndices, false, unsafe);
      };

      Model__proto__.source = function source () {
        return this;
      };

      Model__proto__.teardown = function teardown$4 () {
        var this$1 = this;

        if (this._link) {
          this._link.teardown();
          this._link = null;
        }
        this.children.forEach(teardown);
        if (this.wrapper) { this.wrapper.teardown(); }
        if (this.computed) { keys(this.computed).forEach(function (k) { return this$1.computed[k].teardown(); }); }
      };

      return Model;
    }(ModelBase));

    function recreateArray(model) {
      var array = [];

      for (var i = 0; i < model.length; i++) {
        array[i] = (model.childByKey[i] || {}).value;
      }

      return array;
    }

    /* global global */
    var data$1 = {};

    var SharedModel = (function (Model) {
      function SharedModel(value, name, ractive) {
        Model.call(this, null, ("@" + name));
        this.key = "@" + name;
        this.value = value;
        this.isRoot = true;
        this.root = this;
        this.adaptors = [];
        this.ractive = ractive;
      }

      if ( Model ) SharedModel.__proto__ = Model;
      var SharedModel__proto__ = SharedModel.prototype = Object.create( Model && Model.prototype );
      SharedModel__proto__.constructor = SharedModel;

      SharedModel__proto__.getKeypath = function getKeypath () {
        return this.key;
      };

      SharedModel__proto__.retrieve = function retrieve () {
        return this.value;
      };

      return SharedModel;
    }(Model));

    var SharedModel$1 = new SharedModel(data$1, 'shared');

    var GlobalModel = new SharedModel(base, 'global');

    function findContext(fragment) {
      var frag = fragment;
      while (frag && !frag.context && !frag.aliases) { frag = frag.parent; }
      return frag;
    }

    function resolveReference(fragment, ref) {
      var initialFragment = fragment;
      // current context ref
      if (ref === '.') { return fragment.findContext(); }

      // ancestor references
      if (ref[0] === '~') { return fragment.ractive.viewmodel.joinAll(splitKeypath(ref.slice(2))); }

      // scoped references
      if (ref[0] === '.' || ref[0] === '^') {
        var frag = fragment;
        var parts = ref.split('/');
        var explicitContext = parts[0] === '^^';

        // find nearest context node
        while (frag && !frag.context) {
          frag = up(frag);
        }
        var context$1 = frag && frag.context;

        // walk up the context chain
        while (frag && parts[0] === '^^') {
          parts.shift();

          // the current fragment should always be a context,
          // and if it happens to be an iteration, jump above the each block
          if (frag.isIteration) {
            frag = frag.parent.parent;
          } else {
            // otherwise jump above the current fragment
            frag = up(frag);
          }

          // walk to the next contexted fragment
          while (frag && !frag.context) {
            frag = up(frag);
          }
          context$1 = frag && frag.context;
        }

        if (!context$1 && explicitContext) {
          throw new Error(
            ("Invalid context parent reference ('" + ref + "'). There is not context at that level.")
          );
        }

        // walk up the context path
        while (parts[0] === '.' || parts[0] === '..') {
          var part = parts.shift();

          if (part === '..') {
            // treat reference expressions as their model
            if (!context$1.parent && context$1.proxy && context$1.target) { context$1 = context$1.target.parent; }
            else { context$1 = context$1.parent; }
          }
        }

        ref = parts.join('/');

        // special case - `{{.foo}}` means the same as `{{./foo}}`
        if (ref[0] === '.') { ref = ref.slice(1); }
        return context$1.joinAll(splitKeypath(ref));
      }

      var keys$$1 = splitKeypath(ref);
      if (!keys$$1.length) { return; }
      var base = keys$$1.shift();

      // special refs
      if (base[0] === '@') {
        // shorthand from outside the template
        // @this referring to local ractive instance
        if (base === '@this' || base === '@') {
          return fragment.ractive.viewmodel.getRactiveModel().joinAll(keys$$1);
        } else if (base === '@index' || base === '@key') {
          // @index or @key referring to the nearest repeating index or key
          if (keys$$1.length) { badReference(base); }
          var repeater = findIter(fragment);
          return repeater && repeater[("get" + (base[1] === 'i' ? 'Index' : 'Key'))]();
        } else if (base === '@last') {
          var repeater$1 = findIter(fragment);
          return repeater$1 && repeater$1.parent.getLast();
        } else if (base === '@global') {
          // @global referring to window or global
          return GlobalModel.joinAll(keys$$1);
        } else if (base === '@shared') {
          // @global referring to window or global
          return SharedModel$1.joinAll(keys$$1);
        } else if (base === '@keypath' || base === '@rootpath') {
          // @keypath or @rootpath, the current keypath string
          var root = ref[1] === 'r' ? fragment.ractive.root : null;
          var f = fragment;

          while (
            f &&
            (!f.context || (f.isRoot && f.ractive.component && (root || !f.ractive.isolated)))
          ) {
            f = f.isRoot ? f.componentParent : f.parent;
          }

          return f.getKeypath(root);
        } else if (base === '@context') {
          return new SharedModel(fragment.getContext(), 'context').joinAll(keys$$1);
        } else if (base === '@local') {
          // @context-local data
          return fragment.getContext()._data.joinAll(keys$$1);
        } else if (base === '@style') {
          // @style shared model
          return fragment.ractive.constructor._cssModel.joinAll(keys$$1);
        } else if (base === '@helpers') {
          // @helpers instance model
          return fragment.ractive.viewmodel.getHelpers().joinAll(keys$$1);
        } else if (base === '@macro') {
          var handle = findMacro(fragment);
          if (handle) { return new SharedModel(handle, 'macro').joinAll(keys$$1); }
          else { return; }
        } else {
          // nope
          throw new Error(("Invalid special reference '" + base + "'"));
        }
      }

      // helpers
      if (base && !keys$$1.length) {
        var helpers = fragment.ractive.viewmodel.getHelpers();
        if (helpers.has(base)) { return helpers.joinKey(base); }
      }

      var context = findContext(fragment);

      // check immediate context for a match
      if (context) {
        if (context.context) {
          context = context.context;
        } else {
          // alias block, so get next full context for later
          context = fragment.findContext();
        }
      } else {
        context = fragment.findContext();
      }

      // walk up the fragment hierarchy looking for a matching ref, alias, or key in a context
      var createMapping = false;
      var shouldWarn = fragment.ractive.warnAboutAmbiguity;
      var crossed = 0;
      var model;

      while (fragment) {
        // repeated fragments
        if (fragment.isIteration) {
          if (base === fragment.parent.keyRef) {
            model = fragment.getKey();
          } else if (base === fragment.parent.indexRef) {
            model = fragment.getIndex();
          }

          if (model && keys$$1.length) { badReference(base); }
        }

        // alias node or iteration
        if (!model && fragment.aliases && hasOwn(fragment.aliases, base)) {
          model = fragment.aliases[base];
        }

        // check fragment context to see if it has the key we need
        if (!model && fragment.context && fragment.context.has(base)) {
          model = fragment.context.joinKey(base);

          // this is an implicit mapping
          if (createMapping) {
            if (shouldWarn)
              { warnIfDebug(
                ("'" + ref + "' resolved but is ambiguous and will create a mapping to a parent component.")
              ); }
          } else if (shouldWarn && crossed) { warnIfDebug(("'" + ref + "' resolved but is ambiguous.")); }
        }

        if (model) {
          if (createMapping) {
            model = initialFragment.ractive.viewmodel.createLink(base, model, base, { implicit: true });
          }

          if (keys$$1.length > 0 && isFunction(model.joinAll)) {
            model = model.joinAll(keys$$1);
          }

          return model;
        }

        // don't consider alias blocks when checking for ambiguity
        if (fragment.context && !fragment.aliases) { crossed = 1; }

        if (
          !fragment.ractive.isolated &&
          !(fragment.owner && fragment.owner.containerFragment) &&
          (fragment.componentParent || (!fragment.parent && fragment.ractive.component))
        ) {
          // ascend through component boundary
          fragment = fragment.componentParent || fragment.ractive.component.up;
          createMapping = true;
        } else {
          fragment = fragment.parent;
        }
      }

      // if enabled, check the instance for a match
      var instance = initialFragment.ractive;
      if (instance.resolveInstanceMembers && base !== 'data' && base in instance) {
        return instance.viewmodel
          .getRactiveModel()
          .joinKey(base)
          .joinAll(keys$$1);
      }

      if (shouldWarn) {
        warnIfDebug(("'" + ref + "' is ambiguous and did not resolve."));
      }

      // didn't find anything, so go ahead and create the key on the local model
      return context.joinKey(base).joinAll(keys$$1);
    }

    function up(fragment) {
      return (
        fragment &&
        ((!fragment.ractive.isolated &&
          !(fragment.owner && fragment.owner.containerFragment) &&
          (fragment.componentParent || (!fragment.parent && fragment.ractive.component))) ||
          fragment.parent)
      );
    }

    function findIter(start) {
      var fragment = start;
      var next;
      while (!fragment.isIteration && (next = up(fragment))) {
        fragment = next;
      }

      return fragment.isIteration && fragment;
    }

    function findMacro(start) {
      var fragment = start;
      while (fragment) {
        if (fragment.owner.handle) { return fragment.owner.handle; }
        fragment = up(fragment);
      }
    }

    function badReference(key) {
      throw new Error(("An index or key reference (" + key + ") cannot have child properties"));
    }

    var extern = {};

    function getRactiveContext(ractive) {
      var assigns = [], len = arguments.length - 1;
      while ( len-- > 0 ) assigns[ len ] = arguments[ len + 1 ];

      var fragment =
        ractive.fragment ||
        ractive._fakeFragment ||
        (ractive._fakeFragment = new FakeFragment(ractive));
      return fragment.getContext.apply(fragment, assigns);
    }

    function getContext() {
      var assigns = [], len = arguments.length;
      while ( len-- ) assigns[ len ] = arguments[ len ];

      if (!this.ctx) { this.ctx = new extern.Context(this); }
      assigns.unshift(create(this.ctx));
      return assign.apply(null, assigns);
    }

    var FakeFragment = function FakeFragment(ractive) {
      this.ractive = ractive;
    };

    FakeFragment.prototype.findContext = function findContext () {
      return this.ractive.viewmodel;
    };
    var proto = FakeFragment.prototype;
    proto.getContext = getContext;
    proto.find = proto.findComponent = proto.findAll = proto.findAllComponents = noop;

    function findParentWithContext(fragment) {
      var frag = fragment;
      while (frag && !frag.context) { frag = frag.parent; }
      if (!frag) { return fragment && fragment.ractive.fragment; }
      else { return frag; }
    }

    var keep = false;

    function set(pairs, options) {
      var k = keep;

      var deep = options && options.deep;
      var shuffle = options && options.shuffle;
      var promise = runloop.start();
      if (options && 'keep' in options) { keep = options.keep; }

      var i = pairs.length;
      while (i--) {
        var model = pairs[i][0];
        var value = pairs[i][1];
        var keypath = pairs[i][2];

        if (!model) {
          runloop.end();
          throw new Error(("Failed to set invalid keypath '" + keypath + "'"));
        }

        if (deep) { deepSet(model, value); }
        else if (shuffle) {
          var array = value;
          var target = model.get();
          // shuffle target array with itself
          if (!array) { array = target; }

          // if there's not an array there yet, go ahead and set
          if (isUndefined(target)) {
            model.set(array);
          } else {
            if (!isArray(target) || !isArray(array)) {
              runloop.end();
              throw new Error('You cannot merge an array with a non-array');
            }

            var comparator = getComparator(shuffle);
            model.merge(array, comparator);
          }
        } else { model.set(value); }
      }

      runloop.end();

      keep = k;

      if (pairs.length === 1) { return promise.then(function () { return pairs[0][1]; }); }
      else { return promise; }
    }

    var star = /\*/;
    function gather(ractive, keypath, base, isolated) {
      if (!base && (keypath[0] === '.' || keypath[1] === '^')) {
        warnIfDebug(
          "Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths."
        );
        return [];
      }

      var keys$$1 = splitKeypath(keypath);
      var model = base || ractive.viewmodel;

      if (star.test(keypath)) {
        return model.findMatches(keys$$1);
      } else {
        if (model === ractive.viewmodel) {
          // allow implicit mappings
          if (
            ractive.component &&
            !ractive.isolated &&
            !model.has(keys$$1[0]) &&
            keypath[0] !== '@' &&
            keypath[0] &&
            !isolated
          ) {
            return [resolveReference(ractive.fragment || new FakeFragment(ractive), keypath)];
          } else {
            return [model.joinAll(keys$$1)];
          }
        } else {
          return [model.joinAll(keys$$1)];
        }
      }
    }

    function build(ractive, keypath, value, isolated) {
      var sets = [];

      // set multiple keypaths in one go
      if (isObject(keypath)) {
        var loop = function ( k ) {
          if (hasOwn(keypath, k)) {
            sets.push.apply(sets, gather(ractive, k, null, isolated).map(function (m) { return [m, keypath[k], k]; }));
          }
        };

        for (var k in keypath) loop( k );
      } else {
        // set a single keypath
        sets.push.apply(sets, gather(ractive, keypath, null, isolated).map(function (m) { return [m, value, keypath]; }));
      }

      return sets;
    }

    var deepOpts = { virtual: false };
    function deepSet(model, value) {
      var dest = model.get(false, deepOpts);

      // if dest doesn't exist, just set it
      if (dest == null || !isObjectType(value) || isDate(value)) { return model.set(value); }
      if (!isObjectType(dest)) { return model.set(value); }

      for (var k in value) {
        if (hasOwn(value, k)) {
          deepSet(model.joinKey(k), value[k]);
        }
      }
    }

    var comparators = {};
    function getComparator(option) {
      if (option === true) { return null; } // use existing arrays
      if (isFunction(option)) { return option; }

      if (isString(option)) {
        return comparators[option] || (comparators[option] = function (thing) { return thing[option]; });
      }

      throw new Error('If supplied, options.compare must be a string, function, or true'); // TODO link to docs
    }

    var errorMessage = 'Cannot add to a non-numeric value';

    function add(ractive, keypath, d, options) {
      if (!isString(keypath) || !isNumeric(d)) {
        throw new Error('Bad arguments');
      }

      var sets = build(ractive, keypath, d, options && options.isolated);

      return set(
        sets.map(function (pair) {
          var model = pair[0];
          var add = pair[1];
          var value = model.get();
          if (!isNumeric(add) || !isNumeric(value)) { throw new Error(errorMessage); }
          return [model, value + add];
        })
      );
    }

    function Ractive$add(keypath, d, options) {
      var num = isNumber(d) ? d : 1;
      var opts = isObjectType(d) ? d : options;
      return add(this, keypath, num, opts);
    }

    function immediate(value) {
      var result = Promise.resolve(value);
      defineProperty(result, 'stop', { value: noop });
      return result;
    }

    var linear = easing.linear;

    function getOptions(options, instance) {
      options = options || {};

      var easing$$1;
      if (options.easing) {
        easing$$1 = isFunction(options.easing) ? options.easing : instance.easing[options.easing];
      }

      return {
        easing: easing$$1 || linear,
        duration: 'duration' in options ? options.duration : 400,
        complete: options.complete || noop,
        step: options.step || noop,
        interpolator: options.interpolator
      };
    }

    function animate(ractive, model, to, options) {
      options = getOptions(options, ractive);
      var from = model.get();

      // don't bother animating values that stay the same
      if (isEqual(from, to)) {
        options.complete(options.to);
        return immediate(to);
      }

      var interpolator = interpolate(from, to, ractive, options.interpolator);

      // if we can't interpolate the value, set it immediately
      if (!interpolator) {
        runloop.start();
        model.set(to);
        runloop.end();

        return immediate(to);
      }

      return model.animate(from, to, options, interpolator);
    }

    function Ractive$animate(keypath, to, options) {
      if (isObjectType(keypath)) {
        var keys$$1 = keys(keypath);

        throw new Error(("ractive.animate(...) no longer supports objects. Instead of ractive.animate({\n  " + (keys$$1.map(function (key) { return ("'" + key + "': " + (keypath[key])); }).join('\n  ')) + "\n}, {...}), do\n\n" + (keys$$1.map(function (key) { return ("ractive.animate('" + key + "', " + (keypath[key]) + ", {...});"); }).join('\n')) + "\n"));
      }

      return animate(this, this.viewmodel.joinAll(splitKeypath(keypath)), to, options);
    }

    function enqueue(ractive, event) {
      if (ractive.event) {
        ractive._eventQueue.push(ractive.event);
      }

      ractive.event = event;
    }

    function dequeue(ractive) {
      if (ractive._eventQueue.length) {
        ractive.event = ractive._eventQueue.pop();
      } else {
        ractive.event = null;
      }
    }

    var initStars = {};
    var bubbleStars = {};

    // cartesian product of name parts and stars
    // adjusted appropriately for special cases
    function variants(name, initial) {
      var map = initial ? initStars : bubbleStars;
      if (map[name]) { return map[name]; }

      var parts = name.split('.');
      var result = [];
      var base = false;

      // initial events the implicit namespace of 'this'
      if (initial) {
        parts.unshift('this');
        base = true;
      }

      // use max - 1 bits as a bitmap to pick a part or a *
      // need to skip the full star case if the namespace is synthetic
      var max = Math.pow(2, parts.length) - (initial ? 1 : 0);
      for (var i = 0; i < max; i++) {
        var join = [];
        for (var j = 0; j < parts.length; j++) {
          join.push(1 & (i >> j) ? '*' : parts[j]);
        }
        result.unshift(join.join('.'));
      }

      if (base) {
        // include non-this-namespaced versions
        if (parts.length > 2) {
          result.push.apply(result, variants(name, false));
        } else {
          result.push('*');
          result.push(name);
        }
      }

      map[name] = result;
      return result;
    }

    function fireEvent(ractive, eventName, context, args) {
      if ( args === void 0 ) args = [];

      if (!eventName) {
        return;
      }

      context.name = eventName;
      args.unshift(context);

      var eventNames = ractive._nsSubs ? variants(eventName, true) : ['*', eventName];

      return fireEventAs(ractive, eventNames, context, args, true);
    }

    function fireEventAs(ractive, eventNames, context, args, initialFire) {
      if ( initialFire === void 0 ) initialFire = false;

      var bubble = true;

      if (initialFire || ractive._nsSubs) {
        enqueue(ractive, context);

        var i = eventNames.length;
        while (i--) {
          if (eventNames[i] in ractive._subs) {
            bubble = notifySubscribers(ractive, ractive._subs[eventNames[i]], context, args) && bubble;
          }
        }

        dequeue(ractive);
      }

      if (ractive.parent && bubble) {
        if (initialFire && ractive.component) {
          var fullName = ractive.component.name + '.' + eventNames[eventNames.length - 1];
          eventNames = variants(fullName, false);

          if (context && !context.component) {
            context.component = ractive;
          }
        }

        bubble = fireEventAs(ractive.parent, eventNames, context, args);
      }

      return bubble;
    }

    function notifySubscribers(ractive, subscribers, context, args) {
      var originalEvent = null;
      var stopEvent = false;

      // subscribers can be modified inflight, e.g. "once" functionality
      // so we need to copy to make sure everyone gets called
      subscribers = subscribers.slice();

      for (var i = 0, len = subscribers.length; i < len; i += 1) {
        if (!subscribers[i].off && subscribers[i].handler.apply(ractive, args) === false) {
          stopEvent = true;
        }
      }

      if (context && stopEvent && (originalEvent = context.event)) {
        originalEvent.preventDefault && originalEvent.preventDefault();
        originalEvent.stopPropagation && originalEvent.stopPropagation();
      }

      return !stopEvent;
    }

    var Hook = function Hook(event) {
      this.event = event;
      this.method = 'on' + event;
    };

    Hook.prototype.fire = function fire (ractive, arg) {
      var context = getRactiveContext(ractive);
      var method = this.method;

      if (ractive[method]) {
        arg ? ractive[method](context, arg) : ractive[method](context);
      }

      fireEvent(ractive, this.event, context, arg ? [arg, ractive] : [ractive]);
    };

    function getChildQueue(queue, ractive) {
      return queue[ractive._guid] || (queue[ractive._guid] = []);
    }

    function fire(hookQueue, ractive) {
      var childQueue = getChildQueue(hookQueue.queue, ractive);

      hookQueue.hook.fire(ractive);

      // queue is "live" because components can end up being
      // added while hooks fire on parents that modify data values.
      while (childQueue.length) {
        fire(hookQueue, childQueue.shift());
      }

      delete hookQueue.queue[ractive._guid];
    }

    var HookQueue = function HookQueue(event) {
      this.hook = new Hook(event);
      this.inProcess = {};
      this.queue = {};
    };
    var HookQueue__proto__ = HookQueue.prototype;

    HookQueue__proto__.begin = function begin (ractive) {
      this.inProcess[ractive._guid] = true;
    };

    HookQueue__proto__.end = function end (ractive) {
      var parent = ractive.parent;

      // If this is *isn't* a child of a component that's in process,
      // it should call methods or fire at this point
      if (!parent || !this.inProcess[parent._guid]) {
        fire(this, ractive);
      } else {
        // elsewise, handoff to parent to fire when ready
        getChildQueue(this.queue, parent).push(ractive);
      }

      delete this.inProcess[ractive._guid];
    };

    var hooks = {};
    [
      'construct',
      'config',
      'attachchild',
      'detach',
      'detachchild',
      'insert',
      'complete',
      'reset',
      'render',
      'unrendering',
      'unrender',
      'teardown',
      'destruct',
      'update'
    ].forEach(function (hook) {
      hooks[hook] = new Hook(hook);
    });
    hooks.init = new HookQueue('init');

    function findAnchors(fragment, name) {
      if ( name === void 0 ) name = null;

      var res = [];

      findAnchorsIn(fragment, name, res, fragment.ractive);

      return res;
    }

    function findAnchorsIn(item, name, result, instance) {
      if (item.isAnchor) {
        if (!name || item.name === name) {
          result.push(item);
        }
      } else if (item.items) {
        item.items.forEach(function (i) { return findAnchorsIn(i, name, result, instance); });
      } else if (item.iterations) {
        item.iterations.forEach(function (i) { return findAnchorsIn(i, name, result, instance); });
      } else if (item.fragment && (!item.component || item.fragment.ractive === instance)) {
        findAnchorsIn(item.fragment, name, result, instance);
      } else if (item.instance && item.instance.fragment) {
        var anchors = [];
        findAnchorsIn(item.instance.fragment, name, anchors, instance);
        anchors.forEach(function (a) { return a.ractive === instance && result.push(a); });
      }
    }

    function updateAnchors(instance, name) {
      if ( name === void 0 ) name = null;

      var anchors = findAnchors(instance.fragment, name);
      var idxs = {};
      var children = instance._children.byName;

      anchors.forEach(function (a) {
        var name = a.name;
        if (!(name in idxs)) { idxs[name] = 0; }
        var idx = idxs[name];
        var child = (children[name] || [])[idx];

        if (child && child.lastBound !== a) {
          if (child.lastBound) { child.lastBound.removeChild(child); }
          a.addChild(child);
        }

        idxs[name]++;
      });
    }

    function unrenderChild(meta) {
      if (meta.instance.fragment.rendered) {
        meta.shouldDestroy = true;
        meta.instance.unrender();
      }
      meta.instance.el = null;
    }

    function attachChild(child, options) {
      if ( options === void 0 ) options = {};

      var children = this._children;
      var idx;

      if (child.parent && child.parent !== this)
        { throw new Error(
          ("Instance " + (child._guid) + " is already attached to a different instance " + (child.parent._guid) + ". Please detach it from the other instance using detachChild first.")
        ); }
      else if (child.parent)
        { throw new Error(("Instance " + (child._guid) + " is already attached to this instance.")); }

      var meta = {
        instance: child,
        ractive: this,
        name: options.name || child.constructor.name || 'Ractive',
        target: options.target || false,
        bubble: bubble,
        findNextNode: findNextNode
      };
      meta.nameOption = options.name;

      // child is managing itself
      if (!meta.target) {
        meta.up = this.fragment;
        meta.external = true;
      } else {
        var list;
        if (!(list = children.byName[meta.target])) {
          list = [];
          this.set(("@this.children.byName." + (meta.target)), list);
        }
        idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;
      }

      child.parent = this;
      child.root = this.root;
      child.component = meta;
      children.push(meta);

      var promise = runloop.start();

      var rm = child.viewmodel.getRactiveModel();
      rm.joinKey('parent', { lastLink: false }).link(this.viewmodel.getRactiveModel());
      rm.joinKey('root', { lastLink: false }).link(this.root.viewmodel.getRactiveModel());

      hooks.attachchild.fire(child);

      if (meta.target) {
        unrenderChild(meta);
        this.splice(("@this.children.byName." + (meta.target)), idx, 0, meta);
        updateAnchors(this, meta.target);
      } else {
        if (!child.isolated) { child.viewmodel.attached(this.fragment); }
      }

      runloop.end();

      promise.ractive = child;
      return promise.then(function () { return child; });
    }

    function bubble() {
      runloop.addFragment(this.instance.fragment);
    }

    function findNextNode() {
      if (this.anchor) { return this.anchor.findNextNode(); }
    }

    function compute(path, computed) {
      this.computed[path] = computed;
      if (isString(computed) || isFunction(computed))
        { computed = this.computed[path] = { get: computed }; }

      var keys = splitKeypath(path);
      if (!~path.indexOf('*')) {
        var last = keys.pop();
        return this.viewmodel.joinAll(keys).compute(last, computed);
      } else {
        computed.pattern = new RegExp(
          '^' +
            keys
              .map(function (k) { return k.replace(/\*\*/g, '(.+)').replace(/\*/g, '((?:\\\\.|[^\\.])+)'); })
              .join('\\.') +
            '$'
        );
      }
    }

    function Ractive$compute(path, computed) {
      var promise = runloop.start();
      var comp = compute.call(this, path, computed);

      if (comp) {
        var keys = splitKeypath(path);
        if (keys.length === 1 && !comp.isReadonly) {
          comp.set(this.viewmodel.value[keys[0]]);
        }

        var first = keys.reduce(function (a, c) { return a && a.childByKey[c]; }, this.viewmodel);
        if (first) {
          first.rebind(comp, first, false);
          if (first.parent) { delete first.parent.childByKey[first.key]; }
          fireShuffleTasks();
        }
      }

      runloop.end();

      return promise;
    }

    function Ractive$detach() {
      if (this.isDetached) {
        return this.el;
      }

      if (this.el) {
        removeFromArray(this.el.__ractive_instances__, this);
      }

      this.el = this.fragment.detach();
      this.isDetached = true;

      hooks.detach.fire(this);
      return this.el;
    }

    function detachChild(child) {
      var children = this._children;
      var meta, index;

      var i = children.length;
      while (i--) {
        if (children[i].instance === child) {
          index = i;
          meta = children[i];
          break;
        }
      }

      if (!meta || child.parent !== this)
        { throw new Error(("Instance " + (child._guid) + " is not attached to this instance.")); }

      var promise = runloop.start();

      if (meta.anchor) { meta.anchor.removeChild(meta); }
      if (!child.isolated) { child.viewmodel.detached(); }

      children.splice(index, 1);
      if (meta.target) {
        this.splice(
          ("@this.children.byName." + (meta.target)),
          children.byName[meta.target].indexOf(meta),
          1
        );
        updateAnchors(this, meta.target);
      }
      var rm = child.viewmodel.getRactiveModel();
      rm.joinKey('parent', { lastLink: false }).unlink();
      rm.joinKey('root', { lastLink: false }).link(rm);
      child.root = child;
      child.parent = null;
      child.component = null;

      hooks.detachchild.fire(child);

      runloop.end();

      promise.ractive = child;
      return promise.then(function () { return child; });
    }

    function Ractive$find(selector, options) {
      var this$1 = this;
      if ( options === void 0 ) options = {};

      if (!this.rendered)
        { throw new Error(
          ("Cannot call ractive.find('" + selector + "') unless instance is rendered to the DOM")
        ); }

      var node = this.fragment.find(selector, options);
      if (node) { return node; }

      if (options.remote) {
        for (var i = 0; i < this._children.length; i++) {
          if (!this$1._children[i].instance.fragment.rendered) { continue; }
          node = this$1._children[i].instance.find(selector, options);
          if (node) { return node; }
        }
      }
    }

    function Ractive$findAll(selector, options) {
      if ( options === void 0 ) options = {};

      if (!this.rendered)
        { throw new Error(
          ("Cannot call ractive.findAll('" + selector + "', ...) unless instance is rendered to the DOM")
        ); }

      if (!isArray(options.result)) { options.result = []; }

      this.fragment.findAll(selector, options);

      if (options.remote) {
        // seach non-fragment children
        this._children.forEach(function (c) {
          if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {
            c.instance.findAll(selector, options);
          }
        });
      }

      return options.result;
    }

    function Ractive$findAllComponents(selector, options) {
      if (!options && isObjectType(selector)) {
        options = selector;
        selector = '';
      }

      options = options || {};

      if (!isArray(options.result)) { options.result = []; }

      this.fragment.findAllComponents(selector, options);

      if (options.remote) {
        // search non-fragment children
        this._children.forEach(function (c) {
          if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {
            if (!selector || c.name === selector) {
              options.result.push(c.instance);
            }

            c.instance.findAllComponents(selector, options);
          }
        });
      }

      return options.result;
    }

    function Ractive$findComponent(selector, options) {
      var this$1 = this;
      if ( options === void 0 ) options = {};

      if (isObjectType(selector)) {
        options = selector;
        selector = '';
      }

      var child = this.fragment.findComponent(selector, options);
      if (child) { return child; }

      if (options.remote) {
        if (!selector && this._children.length) { return this._children[0].instance; }
        for (var i = 0; i < this._children.length; i++) {
          // skip children that are or should be in an anchor
          if (this$1._children[i].target) { continue; }
          if (this$1._children[i].name === selector) { return this$1._children[i].instance; }
          child = this$1._children[i].instance.findComponent(selector, options);
          if (child) { return child; }
        }
      }
    }

    function Ractive$findContainer(selector) {
      if (this.container) {
        if (this.container.component && this.container.component.name === selector) {
          return this.container;
        } else {
          return this.container.findContainer(selector);
        }
      }

      return null;
    }

    function Ractive$findParent(selector) {
      if (this.parent) {
        if (this.parent.component && this.parent.component.name === selector) {
          return this.parent;
        } else {
          return this.parent.findParent(selector);
        }
      }

      return null;
    }

    function findElement(start, orComponent, name) {
      if ( orComponent === void 0 ) orComponent = true;

      while (
        start &&
        (start.type !== ELEMENT || (name && start.name !== name)) &&
        (!orComponent || (start.type !== COMPONENT && start.type !== ANCHOR))
      ) {
        // start is a fragment - look at the owner
        if (start.owner) { start = start.owner; }
        else if (start.component || start.yield)
          // start is a component or yielder - look at the container
          { start = start.containerFragment || start.component.up; }
        else if (start.parent)
          // start is an item - look at the parent
          { start = start.parent; }
        else if (start.up)
          // start is an item without a parent - look at the parent fragment
          { start = start.up; }
        else { start = undefined; }
      }

      return start;
    }

    // This function takes an array, the name of a mutator method, and the
    // arguments to call that mutator method with, and returns an array that
    // maps the old indices to their new indices.

    // So if you had something like this...
    //
    //     array = [ 'a', 'b', 'c', 'd' ];
    //     array.push( 'e' );
    //
    // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
    // have changed. If you then did this...
    //
    //     array.unshift( 'z' );
    //
    // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
    // one higher to make room for the 'z'. If you removed an item, the new index
    // would be -1...
    //
    //     array.splice( 2, 2 );
    //
    // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
    //
    // This information is used to enable fast, non-destructive shuffling of list
    // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

    function getNewIndices(length, methodName, args) {
      var newIndices = [];

      var spliceArguments = getSpliceEquivalent(length, methodName, args);

      if (!spliceArguments) {
        return null; // TODO support reverse and sort?
      }

      var balance = spliceArguments.length - 2 - spliceArguments[1];

      var removeStart = Math.min(length, spliceArguments[0]);
      var removeEnd = removeStart + spliceArguments[1];
      newIndices.startIndex = removeStart;

      var i;
      for (i = 0; i < removeStart; i += 1) {
        newIndices.push(i);
      }

      for (; i < removeEnd; i += 1) {
        newIndices.push(-1);
      }

      for (; i < length; i += 1) {
        newIndices.push(i + balance);
      }

      // there is a net shift for the rest of the array starting with index + balance
      if (balance !== 0) {
        newIndices.touchedFrom = spliceArguments[0];
      } else {
        newIndices.touchedFrom = length;
      }

      return newIndices;
    }

    // The pop, push, shift an unshift methods can all be represented
    // as an equivalent splice
    function getSpliceEquivalent(length, methodName, args) {
      switch (methodName) {
        case 'splice':
          if (args[0] !== undefined && args[0] < 0) {
            args[0] = length + Math.max(args[0], -length);
          }

          if (isUndefined(args[0])) { args[0] = 0; }

          while (args.length < 2) {
            args.push(length - args[0]);
          }

          if (!isNumber(args[1])) {
            args[1] = length - args[0];
          }

          // ensure we only remove elements that exist
          args[1] = Math.min(args[1], length - args[0]);

          return args;

        case 'sort':
        case 'reverse':
          return null;

        case 'pop':
          if (length) {
            return [length - 1, 1];
          }
          return [0, 0];

        case 'push':
          return [length, 0].concat(args);

        case 'shift':
          return [0, length ? 1 : 0];

        case 'unshift':
          return [0, 0].concat(args);
      }
    }

    var arrayProto = Array.prototype;

    function makeArrayMethod(methodName) {
      function path(keypath) {
        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

        return model(this.viewmodel.joinAll(splitKeypath(keypath)), args);
      }

      function model(mdl, args) {
        var array = mdl.get();

        if (!isArray(array)) {
          if (isUndefined(array)) {
            array = [];
            var result$1 = arrayProto[methodName].apply(array, args);
            var promise$1 = runloop.start().then(function () { return result$1; });
            mdl.set(array);
            runloop.end();
            return promise$1;
          } else {
            throw new Error(
              ("shuffle array method " + methodName + " called on non-array at " + (mdl.getKeypath()))
            );
          }
        }

        var newIndices = getNewIndices(array.length, methodName, args);
        var result = arrayProto[methodName].apply(array, args);

        var promise = runloop.start().then(function () { return result; });
        promise.result = result;

        if (newIndices) {
          if (mdl.shuffle) {
            mdl.shuffle(newIndices);
          } else {
            // it's a computation, which don't have a shuffle, so just invalidate
            mdl.mark();
          }
        } else {
          mdl.set(result);
        }

        runloop.end();

        return promise;
      }

      return { path: path, model: model };
    }

    function update$1(ractive, model, options) {
      // if the parent is wrapped, the adaptor will need to be updated before
      // updating on this keypath
      if (model.parent && model.parent.wrapper) {
        model.parent.adapt();
      }

      var promise = runloop.start();

      model.mark(options && options.force);

      // notify upstream of changes
      model.notifyUpstream();

      runloop.end();

      hooks.update.fire(ractive, model);

      return promise;
    }

    function Ractive$update(keypath, options) {
      var opts, path;

      if (isString(keypath)) {
        path = splitKeypath(keypath);
        opts = options;
      } else {
        opts = keypath;
      }

      return update$1(this, path ? this.viewmodel.joinAll(path) : this.viewmodel, opts);
    }

    var modelPush = makeArrayMethod('push').model;
    var modelPop = makeArrayMethod('pop').model;
    var modelShift = makeArrayMethod('shift').model;
    var modelUnshift = makeArrayMethod('unshift').model;
    var modelSort = makeArrayMethod('sort').model;
    var modelSplice = makeArrayMethod('splice').model;
    var modelReverse = makeArrayMethod('reverse').model;

    var localFragment = {};

    var ContextData = (function (Model) {
      function ContextData(options) {
        Model.call(this, null, null);

        this.isRoot = true;
        this.root = this;
        this.value = {};
        this.ractive = options.ractive;
        this.adaptors = [];
        this.context = options.context;
      }

      if ( Model ) ContextData.__proto__ = Model;
      var ContextData__proto__ = ContextData.prototype = Object.create( Model && Model.prototype );
      ContextData__proto__.constructor = ContextData;

      ContextData__proto__.getKeypath = function getKeypath () {
        return '@context.data';
      };

      ContextData__proto__.rebound = function rebound () {};

      return ContextData;
    }(Model));

    var Context = function Context(fragment, element) {
      this.fragment = fragment;
      this.element = element || findElement(fragment);
      this.node = this.element && this.element.node;
      this.ractive = fragment.ractive;
      this.root = this;
    };
    var Context__proto__ = Context.prototype;

    var prototypeAccessors = { decorators: {},_data: {} };

    prototypeAccessors.decorators.get = function () {
      var items = {};
      if (!this.element) { return items; }
      this.element.decorators.forEach(function (d) { return (items[d.name] = d.handle); });
      return items;
    };

    prototypeAccessors._data.get = function () {
      return (
        this.model ||
        (this.root.model = new ContextData({
          ractive: this.ractive,
          context: this.root
        }))
      );
    };

    // the usual mutation suspects
    Context__proto__.add = function add (keypath, d, options) {
      var num = isNumber(d) ? +d : 1;
      var opts = isObjectType(d) ? d : options;
      return set(
        build$1(this, keypath, num).map(function (pair) {
          var model = pair[0];
            var val = pair[1];
          var value = model.get();
          if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }
          return [model, value + val];
        }),
        opts
      );
    };

    Context__proto__.animate = function animate$1 (keypath, value, options) {
      var model = findModel(this, keypath).model;
      return animate(this.ractive, model, value, options);
    };

    Context__proto__.find = function find (selector, opts) {
      return this.fragment.find(selector, opts);
    };

    Context__proto__.findAll = function findAll (selector, opts) {
      var result = [];
      opts = opts || {};
      opts.result = result;
      this.fragment.findAll(selector, opts);
      return result;
    };

    Context__proto__.findAllComponents = function findAllComponents (selector, opts) {
      var result = [];
      opts = opts || {};
      opts.result = result;
      this.fragment.findAllComponents(selector, opts);
      return result;
    };

    Context__proto__.findComponent = function findComponent (selector, opts) {
      return this.fragment.findComponent(selector, opts);
    };

    // get relative keypaths and values
    Context__proto__.get = function get (keypath) {
      if (!keypath) { return this.fragment.findContext().get(true); }

      var ref = findModel(this, keypath);
        var model = ref.model;

      return model ? model.get(true) : undefined;
    };

    Context__proto__.getParent = function getParent (component) {
      var fragment = this.fragment;

      if (!fragment.parent && component) { fragment = fragment.componentParent; }
      else {
        if (fragment.context) { fragment = findParentWithContext(fragment.parent); }
        else {
          fragment = findParentWithContext(fragment.parent);
          if (fragment) {
            if (!fragment.parent && component) { fragment = fragment.componentParent; }
            else { fragment = findParentWithContext(fragment.parent); }
          }
        }
      }

      if (!fragment || fragment === this.fragment) { return; }
      else { return fragment.getContext(); }
    };

    Context__proto__.hasListener = function hasListener (name, bubble) {
      // if the owner is a component, start there because the nearest element
      // may exist outside of the immediate context (yield)
      var el = this.fragment.owner.component
        ? this.fragment.owner
        : this.element || this.fragment.owner;
      var base;

      do {
        base = el.component || el;
        if (base.template.t === ELEMENT) {
          if (findEvent(base, name)) { return true; }
        }
        el = el.up && el.up.owner;
        if (el && el.component) { el = el.component; }
      } while (el && bubble);
    };

    Context__proto__.link = function link (source, dest) {
      var there = findModel(this, source).model;
      var here = findModel(this, dest).model;
      var promise = runloop.start();
      here.link(there, source);
      runloop.end();
      return promise;
    };

    Context__proto__.listen = function listen (event, handler) {
      var el = this.element;
      el.on(event, handler);
      return {
        cancel: function cancel() {
          el.off(event, handler);
        }
      };
    };

    Context__proto__.observe = function observe (keypath, callback, options) {
        if ( options === void 0 ) options = {};

      if (isObject(keypath)) { options = callback || {}; }
      options.fragment = this.fragment;
      return this.ractive.observe(keypath, callback, options);
    };

    Context__proto__.observeOnce = function observeOnce (keypath, callback, options) {
        if ( options === void 0 ) options = {};

      if (isObject(keypath)) { options = callback || {}; }
      options.fragment = this.fragment;
      return this.ractive.observeOnce(keypath, callback, options);
    };

    Context__proto__.pop = function pop (keypath) {
      return modelPop(findModel(this, keypath).model, []);
    };

    Context__proto__.push = function push (keypath) {
        var values = [], len = arguments.length - 1;
        while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

      return modelPush(findModel(this, keypath).model, values);
    };

    Context__proto__.raise = function raise (name, event) {
        var args = [], len = arguments.length - 2;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

      var el = this.element;
      var ev;

      while (el) {
        if (el.component) { el = el.component; }
        ev = findEvent(el, name);
        if (ev) {
          return ev.fire(
            ev.element.getContext(
              event || {},
              event && !('original' in event) ? { original: {} } : {}
            ),
            args
          );
        }

        el = el.up && el.up.owner;
      }
    };

    Context__proto__.readLink = function readLink (keypath, options) {
      return this.ractive.readLink(this.resolve(keypath), options);
    };

    Context__proto__.resolve = function resolve (path, ractive) {
      var ref = findModel(this, path);
        var model = ref.model;
        var instance = ref.instance;
      return model ? model.getKeypath(ractive || instance) : path;
    };

    Context__proto__.reverse = function reverse (keypath) {
      return modelReverse(findModel(this, keypath).model, []);
    };

    Context__proto__.set = function set$2 (keypath, value, options) {
      return set(build$1(this, keypath, value), options);
    };

    Context__proto__.shift = function shift (keypath) {
      return modelShift(findModel(this, keypath).model, []);
    };

    Context__proto__.splice = function splice (keypath, index, drop) {
        var add = [], len = arguments.length - 3;
        while ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];

      add.unshift(index, drop);
      return modelSplice(findModel(this, keypath).model, add);
    };

    Context__proto__.sort = function sort (keypath) {
      return modelSort(findModel(this, keypath).model, []);
    };

    Context__proto__.subtract = function subtract (keypath, d, options) {
      var num = isNumber(d) ? d : 1;
      var opts = isObjectType(d) ? d : options;
      return set(
        build$1(this, keypath, num).map(function (pair) {
          var model = pair[0];
            var val = pair[1];
          var value = model.get();
          if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }
          return [model, value - val];
        }),
        opts
      );
    };

    Context__proto__.toggle = function toggle (keypath, options) {
      var ref = findModel(this, keypath);
        var model = ref.model;
      return set([[model, !model.get()]], options);
    };

    Context__proto__.unlink = function unlink (dest) {
      var here = findModel(this, dest).model;
      var promise = runloop.start();
      if (here.owner && here.owner._link) { here.owner.unlink(); }
      runloop.end();
      return promise;
    };

    Context__proto__.unlisten = function unlisten (event, handler) {
      this.element.off(event, handler);
    };

    Context__proto__.unshift = function unshift (keypath) {
        var add = [], len = arguments.length - 1;
        while ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];

      return modelUnshift(findModel(this, keypath).model, add);
    };

    Context__proto__.update = function update (keypath, options) {
      return update$1(this.ractive, findModel(this, keypath).model, options);
    };

    Context__proto__.updateModel = function updateModel (keypath, cascade) {
      var ref = findModel(this, keypath);
        var model = ref.model;
      var promise = runloop.start();
      model.updateFromBindings(cascade);
      runloop.end();
      return promise;
    };

    // two-way binding related helpers
    Context__proto__.isBound = function isBound () {
      var ref = this.getBindingModel(this);
        var model = ref.model;
      return !!model;
    };

    Context__proto__.getBindingPath = function getBindingPath (ractive) {
      var ref = this.getBindingModel(this);
        var model = ref.model;
        var instance = ref.instance;
      if (model) { return model.getKeypath(ractive || instance); }
    };

    Context__proto__.getBinding = function getBinding () {
      var ref = this.getBindingModel(this);
        var model = ref.model;
      if (model) { return model.get(true); }
    };

    Context__proto__.getBindingModel = function getBindingModel (ctx) {
      var el = ctx.element;
      return { model: el.binding && el.binding.model, instance: el.up.ractive };
    };

    Context__proto__.setBinding = function setBinding (value) {
      var ref = this.getBindingModel(this);
        var model = ref.model;
      return set([[model, value]]);
    };

    Object.defineProperties( Context__proto__, prototypeAccessors );

    Context.forRactive = getRactiveContext;
    // circular deps are fun
    extern.Context = Context;

    // TODO: at some point perhaps this could support relative * keypaths?
    function build$1(ctx, keypath, value) {
      var sets = [];

      // set multiple keypaths in one go
      if (isObject(keypath)) {
        for (var k in keypath) {
          if (hasOwn(keypath, k)) {
            sets.push([findModel(ctx, k).model, keypath[k]]);
          }
        }
      } else {
        // set a single keypath
        sets.push([findModel(ctx, keypath).model, value]);
      }

      return sets;
    }

    function findModel(ctx, path) {
      var frag = ctx.fragment;

      if (!isString(path)) {
        return { model: frag.findContext(), instance: path };
      }

      return { model: resolveReference(frag, path), instance: frag.ractive };
    }

    function findEvent(el, name) {
      return el.events && el.events.find && el.events.find(function (e) { return ~e.template.n.indexOf(name); });
    }

    function Ractive$fire(eventName) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      var ctx;

      // watch for reproxy
      if (args[0] instanceof Context) {
        var proto = args.shift();
        ctx = create(proto);
        assign(ctx, proto);
      } else if (isObjectType(args[0]) && (args[0] === null || args[0].constructor === Object)) {
        ctx = Context.forRactive(this, args.shift());
      } else {
        ctx = Context.forRactive(this);
      }

      return fireEvent(this, eventName, ctx, args);
    }

    function Ractive$get(keypath, opts) {
      if (!isString(keypath)) { return this.viewmodel.get(true, keypath); }

      var keys = splitKeypath(keypath);
      var key = keys[0];

      var model;

      if (!this.viewmodel.has(key)) {
        // if this is an inline component, we may need to create
        // an implicit mapping
        if (this.component && !this.isolated) {
          model = resolveReference(this.fragment || new FakeFragment(this), key);
        }
      }

      model = this.viewmodel.joinAll(keys);
      return model.get(true, opts);
    }

    function getLocalContext() {
      if (localFragment.f) { return localFragment.f.getContext(); }
    }

    var query = doc && doc.querySelector;

    function getContext$1(node) {
      if (isString(node) && query) {
        node = query.call(document, node);
      }

      var instances;
      if (node) {
        if (node._ractive) {
          return node._ractive.proxy.getContext();
        } else if ((instances = node.__ractive_instances__)) {
          if (instances.length === 1) { return getRactiveContext(instances[0]); }
        } else { return getContext$1(node.parentNode); }
      }
    }

    function getContext$2(node, options) {
      if (!node) { return getRactiveContext(this); }

      if (isString(node)) {
        node = this.find(node, options);
      }

      return getContext$1(node);
    }

    var html = 'http://www.w3.org/1999/xhtml';
    var mathml = 'http://www.w3.org/1998/Math/MathML';
    var svg$1 = 'http://www.w3.org/2000/svg';
    var xlink = 'http://www.w3.org/1999/xlink';
    var xml = 'http://www.w3.org/XML/1998/namespace';
    var xmlns = 'http://www.w3.org/2000/xmlns';

    var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };

    var createElement;
    var matches;
    var div;
    var methodNames;
    var unprefixed;
    var prefixed;
    var i;
    var j;
    var makeFunction;

    var customStr = isClient && 'registerElement' in doc;
    function wrap(is) {
      return customStr ? is : { is: is };
    }

    // Test for SVG support
    if (!svg) {
      /* istanbul ignore next */
      createElement = function (type, ns, is) {
        if (ns && ns !== html) {
          throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://ractive.js.org/support/#svgs for more information";
        }

        return is ? doc.createElement(type, wrap(is)) : doc.createElement(type);
      };
    } else {
      createElement = function (type, ns, is) {
        if (!ns || ns === html) {
          return is ? doc.createElement(type, wrap(is)) : doc.createElement(type);
        }

        return is ? doc.createElementNS(ns, type, wrap(is)) : doc.createElementNS(ns, type);
      };
    }

    function createDocumentFragment() {
      return doc.createDocumentFragment();
    }

    function getElement(input) {
      var output;

      if (!input || typeof input === 'boolean') {
        return;
      }

      /* istanbul ignore next */
      if (!win || !doc || !input) {
        return null;
      }

      // We already have a DOM node - no work to do. (Duck typing alert!)
      if (input.nodeType) {
        return input;
      }

      // Get node from string
      if (isString(input)) {
        // try ID first
        output = doc.getElementById(input);

        // then as selector, if possible
        if (!output && doc.querySelector) {
          try {
            output = doc.querySelector(input);
          } catch (e) {
            /* this space intentionally left blank */
          }
        }

        // did it work?
        if (output && output.nodeType) {
          return output;
        }
      }

      // If we've been given a collection (jQuery, Zepto etc), extract the first item
      if (input[0] && input[0].nodeType) {
        return input[0];
      }

      return null;
    }

    if (!isClient) {
      matches = null;
    } else {
      div = createElement('div');
      methodNames = ['matches', 'matchesSelector'];

      makeFunction = function(methodName) {
        return function(node, selector) {
          return node[methodName](selector);
        };
      };

      i = methodNames.length;

      while (i-- && !matches) {
        unprefixed = methodNames[i];

        if (div[unprefixed]) {
          matches = makeFunction(unprefixed);
        } else {
          j = vendors.length;
          while (j--) {
            prefixed = vendors[i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);

            if (div[prefixed]) {
              matches = makeFunction(prefixed);
              break;
            }
          }
        }
      }

      // IE8... and apparently phantom some?
      /* istanbul ignore next */
      if (!matches) {
        matches = function(node, selector) {
          var parentNode, i;

          parentNode = node.parentNode;

          if (!parentNode) {
            // empty dummy <div>
            div.innerHTML = '';

            parentNode = div;
            node = node.cloneNode();

            div.appendChild(node);
          }

          var nodes = parentNode.querySelectorAll(selector);

          i = nodes.length;
          while (i--) {
            if (nodes[i] === node) {
              return true;
            }
          }

          return false;
        };
      }
    }

    function detachNode(node) {
      // stupid ie
      // eslint-disable-next-line valid-typeof
      if (node && typeof node.parentNode !== 'unknown' && node.parentNode) {
        node.parentNode.removeChild(node);
      }

      return node;
    }

    function safeToStringValue(value) {
      return value == null || (isNumber(value) && isNaN(value)) || !value.toString ? '' : '' + value;
    }

    function safeAttributeString(string) {
      return safeToStringValue(string)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function Ractive$insert(target, anchor) {
      if (!this.fragment.rendered) {
        // TODO create, and link to, documentation explaining this
        throw new Error(
          'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.'
        );
      }

      target = getElement(target);
      anchor = getElement(anchor) || null;

      if (!target) {
        throw new Error('You must specify a valid target to insert into');
      }

      target.insertBefore(this.detach(), anchor);
      this.el = target;

      (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);
      this.isDetached = false;

      fireInsertHook(this);
    }

    function fireInsertHook(ractive) {
      hooks.insert.fire(ractive);

      ractive.findAllComponents('*').forEach(function (child) {
        fireInsertHook(child.instance);
      });
    }

    function link(there, here, options) {
      var model;
      var target = (options && (options.ractive || options.instance)) || this;

      // may need to allow a mapping to resolve implicitly
      var sourcePath = splitKeypath(there);
      if (!target.viewmodel.has(sourcePath[0]) && target.component) {
        model = resolveReference(target.component.up, sourcePath[0]);
        model = model.joinAll(sourcePath.slice(1));
      }

      var src = model || target.viewmodel.joinAll(sourcePath);
      var dest = this.viewmodel.joinAll(splitKeypath(here), { lastLink: false });

      if (isUpstream(src, dest) || isUpstream(dest, src)) {
        throw new Error('A keypath cannot be linked to itself.');
      }

      var promise = runloop.start();

      dest.link(src, (options && options.keypath) || there);

      runloop.end();

      return promise;
    }

    function isUpstream(check, start) {
      var model = start;
      while (model) {
        if (model === check || model.owner === check) { return true; }
        model = model.target || model.parent;
      }
    }

    var Observer = function Observer(ractive, model, callback, options) {
      this.context = options.context || ractive;
      this.callback = callback;
      this.ractive = ractive;
      this.keypath = options.keypath;
      this.options = options;

      if (model) { this.resolved(model); }

      if (isFunction(options.old)) {
        this.oldContext = create(ractive);
        this.oldFn = options.old;
      }

      if (options.init !== false) {
        this.dirty = true;
        this.dispatch();
      } else {
        updateOld(this);
      }

      this.dirty = false;
    };
    var Observer__proto__ = Observer.prototype;

    Observer__proto__.cancel = function cancel () {
      this.cancelled = true;
      if (this.model) {
        this.model.unregister(this);
      } else {
        this.resolver.unbind();
      }
      removeFromArray(this.ractive._observers, this);
    };

    Observer__proto__.dispatch = function dispatch () {
      if (!this.cancelled) {
        try {
          this.callback.call(this.context, this.newValue, this.oldValue, this.keypath);
        } catch (err) {
          warnIfDebug(
            ("Failed to execute observer callback for '" + (this.keypath) + "': " + (err.message || err))
          );
        }
        updateOld(this, true);
        this.dirty = false;
      }
    };

    Observer__proto__.handleChange = function handleChange () {
        var this$1 = this;

      if (!this.dirty) {
        var newValue = this.model.get();
        if (isEqual(newValue, this.oldValue)) { return; }

        this.newValue = newValue;

        if (this.options.strict && this.newValue === this.oldValue) { return; }

        runloop.addObserver(this, this.options.defer);
        this.dirty = true;

        if (this.options.once) { runloop.scheduleTask(function () { return this$1.cancel(); }); }
      } else {
        // make sure the newValue stays updated in case this observer gets touched multiple times in one loop
        this.newValue = this.model.get();
      }
    };

    Observer__proto__.rebind = function rebind (next, previous) {
        var this$1 = this;

      next = rebindMatch(this.keypath, next, previous);
      if (next === this.model) { return false; }

      if (this.model) { this.model.unregister(this); }
      if (next) { next.addShuffleTask(function () { return this$1.resolved(next); }); }
    };

    Observer__proto__.resolved = function resolved (model) {
      this.model = model;

      this.oldValue = undefined;
      this.newValue = model.get();

      model.register(this);
    };

    function updateOld(observer, fresh) {
      var next = fresh
        ? observer.model
          ? observer.model.get()
          : observer.newValue
        : observer.newValue;
      try {
        observer.oldValue = observer.oldFn
          ? observer.oldFn.call(observer.oldContext, undefined, next, observer.keypath)
          : next;
      } catch (err) {
        warnIfDebug(
          ("Failed to execute observer oldValue callback for '" + (this.keypath) + "': " + (err.message || err))
        );
        observer.oldValue = next;
      }
    }

    function joinKeys() {
      var keys = [], len = arguments.length;
      while ( len-- ) keys[ len ] = arguments[ len ];

      return keys.map(escapeKey).join('.');
    }

    function splitKeypath$1(keypath) {
      return splitKeypath(keypath).map(unescapeKey);
    }

    var star$1 = /\*+/g;

    var PatternObserver = function PatternObserver(ractive, baseModel, keys$$1, callback, options) {
      var this$1 = this;

      this.context = options.context || ractive;
      this.ractive = ractive;
      this.baseModel = baseModel;
      this.keys = keys$$1;
      this.callback = callback;

      var pattern = keys$$1.join('\\.').replace(star$1, '(.+)');
      var baseKeypath = (this.baseKeypath = baseModel.getKeypath(ractive));
      this.pattern = new RegExp(("^" + (baseKeypath ? baseKeypath + '\\.' : '') + pattern + "$"));
      this.recursive = keys$$1.length === 1 && keys$$1[0] === '**';
      if (this.recursive) { this.keys = ['*']; }
      if (options.old) {
        this.oldContext = create(ractive);
        this.oldFn = options.old;
      }

      this.oldValues = {};
      this.newValues = {};

      this.defer = options.defer;
      this.once = options.once;
      this.strict = options.strict;

      this.dirty = false;
      this.changed = [];
      this.cache = [];
      this.partial = false;
      this.links = options.links;

      var models = baseModel.findMatches(this.keys);

      models.forEach(function (model) {
        this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();
      });

      if (options.init !== false) {
        this.dispatch();
      } else {
        updateOld$1(this, this.newValues);
      }

      baseModel.registerPatternObserver(this);
    };
    var PatternObserver__proto__ = PatternObserver.prototype;

    PatternObserver__proto__.cancel = function cancel () {
      this.baseModel.unregisterPatternObserver(this);
      removeFromArray(this.ractive._observers, this);
    };

    PatternObserver__proto__.dispatch = function dispatch () {
        var this$1 = this;

      var newValues = this.newValues;
      this.newValues = {};
      keys(newValues).forEach(function (keypath) {
        var newValue = newValues[keypath];
        var oldValue = this$1.oldValues[keypath];

        if (this$1.strict && newValue === oldValue) { return; }
        if (isEqual(newValue, oldValue)) { return; }

        var args = [newValue, oldValue, keypath];
        if (keypath) {
          var wildcards = this$1.pattern.exec(keypath);
          if (wildcards) {
            args = args.concat(wildcards.slice(1));
          }
        }

        try {
          this$1.callback.apply(this$1.context, args);
        } catch (err) {
          warnIfDebug(
            ("Failed to execute pattern observer callback for '" + (this$1.keypath) + "': " + (err.message || err))
          );
        }
      });

      updateOld$1(this, newValues, this.partial);

      this.dirty = false;
    };

    PatternObserver__proto__.notify = function notify (keys$$1) {
      var path = joinKeys(keys$$1);
      if (!~this.cache.indexOf(path)) {
        this.cache.push(path);
        this.changed.push(keys$$1);
      }
    };

    PatternObserver__proto__.shuffle = function shuffle (newIndices) {
        var this$1 = this;

      if (!isArray(this.baseModel.value)) { return; }

      var max = this.baseModel.value.length;

      for (var i = 0; i < newIndices.length; i++) {
        if (newIndices[i] === -1 || newIndices[i] === i) { continue; }
        this$1.changed.push([i]);
      }

      for (var i$1 = newIndices.touchedFrom; i$1 < max; i$1++) {
        this$1.changed.push([i$1]);
      }
    };

    PatternObserver__proto__.handleChange = function handleChange () {
        var this$1 = this;

      if (!this.dirty || this.changed.length) {
        if (!this.dirty) { this.newValues = {}; }

        if (!this.changed.length) {
          this.baseModel.findMatches(this.keys).forEach(function (model) {
            var keypath = model.getKeypath(this$1.ractive);
            this$1.newValues[keypath] = model.get();
          });
          this.partial = false;
        } else {
          var count = 0;

          if (this.recursive) {
            var changed = this.changed.slice();
            this.changed.length = 0;
            this.dirty = true;
            changed.forEach(function (keys$$1) {
              var model = this$1.baseModel.joinAll(keys$$1);
              if (model.isLink && !this$1.links) { return; }
              count++;
              this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();
            });
            this.dirty = false;
          } else {
            var ok = this.baseModel.isRoot
              ? this.changed.map(function (keys$$1) { return keys$$1.map(escapeKey).join('.'); })
              : this.changed.map(function (keys$$1) { return this$1.baseKeypath + '.' + keys$$1.map(escapeKey).join('.'); });

            this.baseModel.findMatches(this.keys).forEach(function (model) {
              var keypath = model.getKeypath(this$1.ractive);
              var check = function (k) {
                return (
                  (k.indexOf(keypath) === 0 &&
                    (k.length === keypath.length || k[keypath.length] === '.')) ||
                  (keypath.indexOf(k) === 0 &&
                    (k.length === keypath.length || keypath[k.length] === '.'))
                );
              };

              // is this model on a changed keypath?
              if (ok.filter(check).length) {
                count++;
                this$1.newValues[keypath] = model.get();
              }
            });
          }

          // no valid change triggered, so bail to avoid breakage
          if (!count) { return; }

          this.partial = true;
        }

        runloop.addObserver(this, this.defer);
        this.dirty = true;
        this.changed.length = 0;
        this.cache = [];

        if (this.once) { this.cancel(); }
      }
    };

    function updateOld$1(observer, vals, partial) {
      var olds = observer.oldValues;

      if (observer.oldFn) {
        if (!partial) { observer.oldValues = {}; }

        keys(vals).forEach(function (k) {
          var args = [olds[k], vals[k], k];
          var parts = observer.pattern.exec(k);
          if (parts) {
            args.push.apply(args, parts.slice(1));
          }
          observer.oldValues[k] = observer.oldFn.apply(observer.oldContext, args);
        });
      } else {
        if (partial) {
          keys(vals).forEach(function (k) { return (olds[k] = vals[k]); });
        } else {
          observer.oldValues = vals;
        }
      }
    }

    function negativeOne() {
      return -1;
    }

    var ArrayObserver = function ArrayObserver(ractive, model, callback, options) {
      this.ractive = ractive;
      this.model = model;
      this.keypath = model.getKeypath();
      this.callback = callback;
      this.options = options;

      this.pending = null;

      model.register(this);

      if (options.init !== false) {
        this.sliced = [];
        this.shuffle([]);
        this.dispatch();
      } else {
        this.sliced = this.slice();
      }
    };
    var ArrayObserver__proto__ = ArrayObserver.prototype;

    ArrayObserver__proto__.cancel = function cancel () {
      this.model.unregister(this);
      removeFromArray(this.ractive._observers, this);
    };

    ArrayObserver__proto__.dispatch = function dispatch () {
      try {
        this.callback(this.pending);
      } catch (err) {
        warnIfDebug(
          ("Failed to execute array observer callback for '" + (this.keypath) + "': " + (err.message || err))
        );
      }
      this.pending = null;
      if (this.options.once) { this.cancel(); }
    };

    ArrayObserver__proto__.handleChange = function handleChange (path) {
      if (this.pending) {
        // post-shuffle
        runloop.addObserver(this, this.options.defer);
      } else if (!path) {
        // entire array changed
        this.shuffle(this.sliced.map(negativeOne));
        this.handleChange();
      }
    };

    ArrayObserver__proto__.shuffle = function shuffle (newIndices) {
        var this$1 = this;

      var newValue = this.slice();

      var inserted = [];
      var deleted = [];
      var start;

      var hadIndex = {};

      newIndices.forEach(function (newIndex, oldIndex) {
        hadIndex[newIndex] = true;

        if (newIndex !== oldIndex && isUndefined(start)) {
          start = oldIndex;
        }

        if (newIndex === -1) {
          deleted.push(this$1.sliced[oldIndex]);
        }
      });

      if (isUndefined(start)) { start = newIndices.length; }

      var len = newValue.length;
      for (var i = 0; i < len; i += 1) {
        if (!hadIndex[i]) { inserted.push(newValue[i]); }
      }

      this.pending = { inserted: inserted, deleted: deleted, start: start };
      this.sliced = newValue;
    };

    ArrayObserver__proto__.slice = function slice () {
      var value = this.model.get();
      return isArray(value) ? value.slice() : [];
    };

    function observe(keypath, callback, options) {
      var this$1 = this;

      var observers = [];
      var map;
      var opts;

      if (isObject(keypath)) {
        map = keypath;
        opts = callback || {};
      } else {
        if (isFunction(keypath)) {
          map = { '': keypath };
          opts = callback || {};
        } else {
          map = {};
          map[keypath] = callback;
          opts = options || {};
        }
      }

      var silent = false;
      keys(map).forEach(function (keypath) {
        var callback = map[keypath];
        var caller = function() {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];

          if (silent) { return; }
          return callback.apply(this, args);
        };

        var keypaths = keypath.split(' ');
        if (keypaths.length > 1) { keypaths = keypaths.filter(function (k) { return k; }); }

        keypaths.forEach(function (keypath) {
          opts.keypath = keypath;
          var observer = createObserver(this$1, keypath, caller, opts);
          if (observer) { observers.push(observer); }
        });
      });

      // add observers to the Ractive instance, so they can be
      // cancelled on ractive.teardown()
      this._observers.push.apply(this._observers, observers);

      return {
        cancel: function () { return observers.forEach(function (o) { return o.cancel(); }); },
        isSilenced: function () { return silent; },
        silence: function () { return (silent = true); },
        resume: function () { return (silent = false); }
      };
    }

    function createObserver(ractive, keypath, callback, options) {
      var keys$$1 = splitKeypath(keypath);
      var wildcardIndex = keys$$1.indexOf('*');
      if (!~wildcardIndex) { wildcardIndex = keys$$1.indexOf('**'); }

      options.fragment = options.fragment || ractive.fragment;

      var model;
      if (!options.fragment) {
        model = ractive.viewmodel.joinKey(keys$$1[0]);
      } else {
        // .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .
        if (~keys$$1[0].indexOf('.*')) {
          model = options.fragment.findContext();
          wildcardIndex = 0;
          keys$$1[0] = keys$$1[0].slice(1);
        } else {
          model =
            wildcardIndex === 0
              ? options.fragment.findContext()
              : resolveReference(options.fragment, keys$$1[0]);
        }
      }

      // the model may not exist key
      if (!model) { model = ractive.viewmodel.joinKey(keys$$1[0]); }

      if (!~wildcardIndex) {
        model = model.joinAll(keys$$1.slice(1));
        if (options.array) {
          return new ArrayObserver(ractive, model, callback, options);
        } else {
          return new Observer(ractive, model, callback, options);
        }
      } else {
        var double = keys$$1.indexOf('**');
        if (~double) {
          if (double + 1 !== keys$$1.length || ~keys$$1.indexOf('*')) {
            warnOnceIfDebug(
              "Recursive observers may only specify a single '**' at the end of the path."
            );
            return;
          }
        }

        model = model.joinAll(keys$$1.slice(1, wildcardIndex));

        return new PatternObserver(ractive, model, keys$$1.slice(wildcardIndex), callback, options);
      }
    }

    var onceOptions = { init: false, once: true };

    function observeOnce(keypath, callback, options) {
      if (isObject(keypath) || isFunction(keypath)) {
        options = assign(callback || {}, onceOptions);
        return this.observe(keypath, options);
      }

      options = assign(options || {}, onceOptions);
      return this.observe(keypath, callback, options);
    }

    var trim = function (str) { return str.trim(); };

    var notEmptyString = function (str) { return str !== ''; };

    function Ractive$off(eventName, callback) {
      var this$1 = this;

      // if no event is specified, remove _all_ event listeners
      if (!eventName) {
        this._subs = {};
      } else {
        // Handle multiple space-separated event names
        var eventNames = eventName
          .split(' ')
          .map(trim)
          .filter(notEmptyString);

        eventNames.forEach(function (event) {
          var subs = this$1._subs[event];
          // if given a specific callback to remove, remove only it
          if (subs && callback) {
            var entry = subs.find(function (s) { return s.callback === callback; });
            if (entry) {
              removeFromArray(subs, entry);
              entry.off = true;

              if (event.indexOf('.')) { this$1._nsSubs--; }
            }
          } else if (subs) {
            // otherwise, remove all listeners for this event
            if (event.indexOf('.')) { this$1._nsSubs -= subs.length; }
            subs.length = 0;
          }
        });
      }

      return this;
    }

    function Ractive$on(eventName, callback) {
      var this$1 = this;

      // eventName may already be a map
      var map = isObjectType(eventName) ? eventName : {};
      // or it may be a string along with a callback
      if (isString(eventName)) { map[eventName] = callback; }

      var silent = false;
      var events = [];

      var loop = function ( k ) {
        var callback$1 = map[k];
        var caller = function() {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];

          if (!silent) { return callback$1.apply(this, args); }
        };
        var entry = {
          callback: callback$1,
          handler: caller
        };

        if (hasOwn(map, k)) {
          var names = k
            .split(' ')
            .map(trim)
            .filter(notEmptyString);
          names.forEach(function (n) {
            (this$1._subs[n] || (this$1._subs[n] = [])).push(entry);
            if (n.indexOf('.')) { this$1._nsSubs++; }
            events.push([n, entry]);
          });
        }
      };

      for (var k in map) loop( k );

      return {
        cancel: function () { return events.forEach(function (e) { return this$1.off(e[0], e[1].callback); }); },
        isSilenced: function () { return silent; },
        silence: function () { return (silent = true); },
        resume: function () { return (silent = false); }
      };
    }

    function Ractive$once(eventName, handler) {
      var listener = this.on(eventName, function() {
        handler.apply(this, arguments);
        listener.cancel();
      });

      // so we can still do listener.cancel() manually
      return listener;
    }

    var pop = makeArrayMethod('pop').path;

    var push = makeArrayMethod('push').path;

    function readLink(keypath, options) {
      if ( options === void 0 ) options = {};

      var path = splitKeypath(keypath);

      if (this.viewmodel.has(path[0])) {
        var model = this.viewmodel.joinAll(path);

        if (!model.isLink) { return; }

        while ((model = model.target) && options.canonical !== false) {
          if (!model.isLink) { break; }
        }

        if (model) { return { ractive: model.root.ractive, keypath: model.getKeypath() }; }
      }
    }

    var PREFIX = '/* Ractive.js component styles */';

    // Holds current definitions of styles.
    var styleDefinitions = [];

    // Flag to tell if we need to update the CSS
    var isDirty = false;

    // These only make sense on the browser. See additional setup below.
    var styleElement = null;
    var useCssText = null;

    // flag to use multiple style tags
    var _splitTag = false;
    function splitTag(v) {
      return v === undefined ? _splitTag : (_splitTag = v);
    }

    function addCSS(styleDefinition) {
      styleDefinitions.push(styleDefinition);
      isDirty = true;
    }

    function applyCSS(force) {
      var styleElement = style();

      // Apply only seems to make sense when we're in the DOM. Server-side renders
      // can call toCSS to get the updated CSS.
      if (!styleElement || (!force && !isDirty)) { return; }

      if (_splitTag) {
        styleDefinitions.forEach(function (s) {
          var el = getStyle(s.id);
          if (el) {
            var css = getCSS(s.id);
            if (useCssText) {
              el.styleSheet.cssText !== css && (el.styleSheet.cssText = css);
            } else {
              el.innerHTML !== css && (el.innerHTML = css);
            }
          }
        });
      } else {
        if (useCssText) {
          styleElement.styleSheet.cssText = getCSS(null);
        } else {
          styleElement.innerHTML = getCSS(null);
        }
      }

      isDirty = false;
    }

    function getCSS(cssIds) {
      if (cssIds && !isArray(cssIds)) { cssIds = [cssIds]; }
      var filteredStyleDefinitions = cssIds
        ? styleDefinitions.filter(function (style) { return ~cssIds.indexOf(style.id); })
        : styleDefinitions;

      filteredStyleDefinitions.forEach(function (d) { return (d.applied = true); });

      return filteredStyleDefinitions.reduce(
        function (styles, style) { return ("" + (styles ? (styles + "\n\n/* {" + (style.id) + "} */\n" + (style.styles)) : '')); },
        PREFIX
      );
    }

    function getStyle(id) {
      return doc && (doc.querySelector(("[data-ractive-css=\"" + id + "\"]")) || makeStyle(id));
    }

    function makeStyle(id) {
      if (doc) {
        var el = doc.createElement('style');
        el.type = 'text/css';
        el.setAttribute('data-ractive-css', id || '');

        doc.getElementsByTagName('head')[0].appendChild(el);

        if (useCssText === null) { useCssText = !!el.styleSheet; }

        return el;
      }
    }

    function style() {
      if (!styleElement) { styleElement = makeStyle(); }

      return styleElement;
    }

    var adaptConfigurator = {
      extend: function (Parent, proto, options) {
        proto.adapt = combine(proto.adapt, ensureArray(options.adapt));
      },

      init: function init() {}
    };

    var remove = /\/\*(?:[\s\S]*?)\*\//g;
    var escape = /url\(\s*(['"])(?:\\[\s\S]|(?!\1).)*\1\s*\)|url\((?:\\[\s\S]|[^)])*\)|(['"])(?:\\[\s\S]|(?!\2).)*\2/gi;
    var value = /\0(\d+)/g;

    // Removes comments and strings from the given CSS to make it easier to parse.
    // Callback receives the cleaned CSS and a function which can be used to put
    // the removed strings back in place after parsing is done.
    function cleanCss(css, callback, additionalReplaceRules) {
      if ( additionalReplaceRules === void 0 ) additionalReplaceRules = [];

      var values = [];
      var reconstruct = function (css) { return css.replace(value, function (match, n) { return values[n]; }); };
      css = css.replace(escape, function (match) { return ("\u0000" + (values.push(match) - 1)); }).replace(remove, '');

      additionalReplaceRules.forEach(function (pattern) {
        css = css.replace(pattern, function (match) { return ("\u0000" + (values.push(match) - 1)); });
      });

      return callback(css, reconstruct);
    }

    var selectorsPattern = /(?:^|\}|\{|\x01)\s*([^\{\}\0\x01]+)\s*(?=\{)/g;
    var importPattern = /@import\s*\([^)]*\)\s*;?/gi;
    var importEndPattern = /\x01/g;
    var keyframesDeclarationPattern = /@keyframes\s+[^\{\}]+\s*\{(?:[^{}]+|\{[^{}]+})*}/gi;
    var selectorUnitPattern = /((?:(?:\[[^\]]+\])|(?:[^\s\+\>~:]))+)((?:::?[^\s\+\>\~\(:]+(?:\([^\)]+\))?)*\s*[\s\+\>\~]?)\s*/g;
    var excludePattern = /^(?:@|\d+%)/;
    var dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;

    function trim$1(str) {
      return str.trim();
    }

    function extractString(unit) {
      return unit.str;
    }

    function transformSelector(selector, parent) {
      var selectorUnits = [];
      var match;

      while ((match = selectorUnitPattern.exec(selector))) {
        selectorUnits.push({
          str: match[0],
          base: match[1],
          modifiers: match[2]
        });
      }

      // For each simple selector within the selector, we need to create a version
      // that a) combines with the id, and b) is inside the id
      var base = selectorUnits.map(extractString);

      var transformed = [];
      var i = selectorUnits.length;

      while (i--) {
        var appended = base.slice();

        // Pseudo-selectors should go after the attribute selector
        var unit = selectorUnits[i];
        appended[i] = unit.base + parent + unit.modifiers || '';

        var prepended = base.slice();
        prepended[i] = parent + ' ' + prepended[i];

        transformed.push(appended.join(' '), prepended.join(' '));
      }

      return transformed.join(', ');
    }

    function transformCss(css, id) {
      var dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

      var transformed;

      if (dataRvcGuidPattern.test(css)) {
        transformed = css.replace(dataRvcGuidPattern, dataAttr);
      } else {
        transformed = cleanCss(
          css,
          function (css, reconstruct) {
            css = css
              .replace(importPattern, '$&\x01')
              .replace(selectorsPattern, function (match, $1) {
                // don't transform at-rules and keyframe declarations
                if (excludePattern.test($1)) { return match; }

                var selectors = $1.split(',').map(trim$1);
                var transformed =
                  selectors.map(function (selector) { return transformSelector(selector, dataAttr); }).join(', ') + ' ';

                return match.replace($1, transformed);
              })
              .replace(importEndPattern, '');

            return reconstruct(css);
          },
          [keyframesDeclarationPattern]
        );
      }

      return transformed;
    }

    function s4() {
      return Math.floor((1 + Math.random()) * 0x10000)
        .toString(16)
        .substring(1);
    }

    function uuid() {
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }

    function setCSSData(keypath, value, options) {
      var opts = isObjectType(keypath) ? value : options;
      var model = this._cssModel;

      model.locked = true;
      var promise = set(build({ viewmodel: model }, keypath, value, true), opts);
      model.locked = false;

      var cascade = runloop.start();
      this.extensions.forEach(function (e) {
        var model = e._cssModel;
        model.mark();
        model.downstreamChanged('', 1);
      });
      runloop.end();

      applyChanges(this, !opts || opts.apply !== false);

      return promise.then(function () { return cascade; });
    }

    function applyChanges(component, apply) {
      var local = recomputeCSS(component);
      var child = component.extensions
        .map(function (e) { return applyChanges(e, false); })
        .reduce(function (a, c) { return c || a; }, false);

      if (apply && (local || child)) {
        var def = component._cssDef;
        if (!def || (def && def.applied)) { applyCSS(true); }
      }

      return local || child;
    }

    function recomputeCSS(component) {
      var css = component.css;

      if (!isFunction(css)) { return; }

      var def = component._cssDef;
      var result = evalCSS(component, css);
      var styles = def.transform ? transformCss(result, def.id) : result;

      if (def.styles === styles) { return; }

      def.styles = styles;

      return true;
    }

    var CSSModel = (function (SharedModel) {
      function CSSModel(component) {
        SharedModel.call(this, component.cssData, '@style');
        this.component = component;
      }

      if ( SharedModel ) CSSModel.__proto__ = SharedModel;
      var CSSModel__proto__ = CSSModel.prototype = Object.create( SharedModel && SharedModel.prototype );
      CSSModel__proto__.constructor = CSSModel;

      CSSModel__proto__.downstreamChanged = function downstreamChanged (path, depth) {
        if (this.locked) { return; }

        var component = this.component;

        component.extensions.forEach(function (e) {
          var model = e._cssModel;
          model.mark();
          model.downstreamChanged(path, depth || 1);
        });

        if (!depth) {
          applyChanges(component, true);
        }
      };

      return CSSModel;
    }(SharedModel));

    var hasCurly = /\{/;
    var cssConfigurator = {
      name: 'css',

      // Called when creating a new component definition
      extend: function (Parent, proto, options, Child) {
        Child._cssIds = gatherIds(Parent);

        defineProperty(Child, 'cssData', {
          configurable: true,
          value: assign(create(Parent.cssData), options.cssData || {})
        });

        defineProperty(Child, '_cssModel', {
          configurable: true,
          value: new CSSModel(Child)
        });

        if (options.css) { initCSS(options, Child, proto); }
      },

      // Called when creating a new component instance
      init: function (Parent, target, options) {
        if (!options.css) { return; }

        warnIfDebug("\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\n\nconst Component = Ractive.extend({\n\t...\n\tcss: '/* your css */',\n\t...\n});\n\nconst componentInstance = new Component({ ... })\n\t\t");
      }
    };

    function gatherIds(start) {
      var cmp = start;
      var ids = [];

      while (cmp) {
        if (cmp.prototype.cssId) { ids.push(cmp.prototype.cssId); }
        cmp = cmp.Parent;
      }

      return ids;
    }

    function evalCSS(component, css) {
      if (isString(css)) { return css; }

      var cssData = component.cssData;
      var model = component._cssModel;
      var data = function data(path) {
        return model.joinAll(splitKeypath(path)).get();
      };
      data.__proto__ = cssData;

      var result = css.call(component, data);
      return isString(result) ? result : '';
    }

    function initCSS(options, target, proto) {
      var css =
        options.css === true
          ? ''
          : isString(options.css) && !hasCurly.test(options.css)
          ? getElement(options.css) || options.css
          : options.css;
      var cssProp = css;

      var id = options.cssId || uuid();

      if (isObjectType(css)) {
        css = 'textContent' in css ? css.textContent : css.innerHTML;
        cssProp = css;
      } else if (isFunction(css)) {
        cssProp = css;
        css = evalCSS(target, css);
      }

      var def = {
        transform: 'noCSSTransform' in options ? !options.noCSSTransform : !options.noCssTransform
      };

      defineProperty(target, '_cssDef', { configurable: true, value: def });

      defineProperty(target, 'css', {
        get: function get() {
          return cssProp;
        },
        set: function set(next) {
          cssProp = next;
          var css = evalCSS(target, cssProp);
          var styles = def.styles;
          def.styles = def.transform ? transformCss(css, id) : css;
          if (def.applied && styles !== def.styles) { applyCSS(true); }
        }
      });

      def.styles = def.transform ? transformCss(css, id) : css;
      def.id = proto.cssId = id;
      target._cssIds.push(id);

      addCSS(target._cssDef);
    }

    function validate(data) {
      // Warn if userOptions.data is a non-POJO
      if (data && data.constructor !== Object) {
        if (isFunction(data)) ; else if (!isObjectType(data)) {
          fatal(("data option must be an object or a function, `" + data + "` is not valid"));
        } else {
          warnIfDebug(
            'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged'
          );
        }
      }
    }

    var dataConfigurator = {
      name: 'data',

      extend: function (Parent, proto, options) {
        var key;
        var value;

        // check for non-primitives, which could cause mutation-related bugs
        if (options.data && isObject(options.data)) {
          for (key in options.data) {
            value = options.data[key];

            if (value && isObjectType(value)) {
              if (isObject(value) || isArray(value)) {
                warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }");
              }
            }
          }
        }

        proto.data = combine$1(proto.data, options.data);
      },

      init: function (Parent, ractive, options) {
        var result = combine$1(Parent.prototype.data, options.data);

        if (isFunction(result)) { result = result.call(ractive); }

        // bind functions to the ractive instance at the top level,
        // unless it's a non-POJO (in which case alarm bells should ring)
        if (result && result.constructor === Object) {
          for (var prop in result) {
            if (isFunction(result[prop])) {
              var value = result[prop];
              result[prop] = bind(value, ractive);
              result[prop]._r_unbound = value;
            }
          }
        }

        return result || {};
      },

      reset: function reset(ractive) {
        var result = this.init(ractive.constructor, ractive, ractive.viewmodel);
        ractive.viewmodel.root.set(result);
        return true;
      }
    };

    function emptyData() {
      return {};
    }

    function combine$1(parentValue, childValue) {
      validate(childValue);

      var parentIsFn = isFunction(parentValue);

      // Very important, otherwise child instance can become
      // the default data object on Ractive or a component.
      // then ractive.set() ends up setting on the prototype!
      if (!childValue && !parentIsFn) {
        // this needs to be a function so that it can still inherit parent defaults
        childValue = emptyData;
      }

      var childIsFn = isFunction(childValue);

      // Fast path, where we just need to copy properties from
      // parent to child
      if (!parentIsFn && !childIsFn) {
        return fromProperties(childValue, parentValue);
      }

      return function() {
        var child = childIsFn ? callDataFunction(childValue, this) : childValue;
        var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;

        return fromProperties(child, parent);
      };
    }

    function callDataFunction(fn, context) {
      var data = fn.call(context);

      if (!data) { return; }

      if (!isObjectType(data)) {
        fatal('Data function must return an object');
      }

      if (data.constructor !== Object) {
        warnOnceIfDebug(
          'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged'
        );
      }

      return data;
    }

    function fromProperties(primary, secondary) {
      if (primary && secondary) {
        for (var key in secondary) {
          if (!(key in primary)) {
            primary[key] = secondary[key];
          }
        }

        return primary;
      }

      return primary || secondary;
    }

    var templateConfigurator = {
      name: 'template',

      extend: function extend(Parent, proto, options) {
        // only assign if exists
        if ('template' in options) {
          var template = options.template;

          if (isFunction(template)) {
            proto.template = template;
          } else {
            proto.template = parseTemplate(template, proto);
          }
        }
      },

      init: function init(Parent, ractive, options) {
        // TODO because of prototypal inheritance, we might just be able to use
        // ractive.template, and not bother passing through the Parent object.
        // At present that breaks the test mocks' expectations
        var template = 'template' in options ? options.template : Parent.prototype.template;
        template = template || { v: TEMPLATE_VERSION, t: [] };

        if (isFunction(template)) {
          var fn = template;
          template = getDynamicTemplate(ractive, fn);

          ractive._config.template = {
            fn: fn,
            result: template
          };
        }

        template = parseTemplate(template, ractive);

        // TODO the naming of this is confusing - ractive.template refers to [...],
        // but Component.prototype.template refers to {v:1,t:[],p:[]}...
        // it's unnecessary, because the developer never needs to access
        // ractive.template
        ractive.template = template.t;

        if (template.p) {
          extendPartials(ractive.partials, template.p);
        }
      },

      reset: function reset(ractive) {
        var result = resetValue(ractive);

        if (result) {
          var parsed = parseTemplate(result, ractive);

          ractive.template = parsed.t;
          extendPartials(ractive.partials, parsed.p, true);

          return true;
        }
      }
    };

    function resetValue(ractive) {
      var initial = ractive._config.template;

      // If this isn't a dynamic template, there's nothing to do
      if (!initial || !initial.fn) {
        return;
      }

      var result = getDynamicTemplate(ractive, initial.fn);

      // TODO deep equality check to prevent unnecessary re-rendering
      // in the case of already-parsed templates
      if (result !== initial.result) {
        initial.result = result;
        return result;
      }
    }

    function getDynamicTemplate(ractive, fn) {
      return fn.call(ractive, {
        fromId: parser.fromId,
        isParsed: parser.isParsed,
        parse: function parse(template, options) {
          if ( options === void 0 ) options = parser.getParseOptions(ractive);

          return parser.parse(template, options);
        }
      });
    }

    function parseTemplate(template, ractive) {
      if (isString(template)) {
        // parse will validate and add expression functions
        template = parseAsString(template, ractive);
      } else {
        // need to validate and add exp for already parsed template
        validate$1(template);
        addFunctions(template);
      }

      return template;
    }

    function parseAsString(template, ractive) {
      // ID of an element containing the template?
      if (template[0] === '#') {
        template = parser.fromId(template);
      }

      return parser.parseFor(template, ractive);
    }

    function validate$1(template) {
      // Check that the template even exists
      if (template == undefined) {
        throw new Error(("The template cannot be " + template + "."));
      } else if (!isNumber(template.v)) {
        // Check the parsed template has a version at all
        throw new Error(
          "The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are."
        );
      } else if (template.v !== TEMPLATE_VERSION) {
        // Check we're using the correct version
        throw new Error(
          ("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + (template.v) + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app")
        );
      }
    }

    function extendPartials(existingPartials, newPartials, overwrite) {
      if (!newPartials) { return; }

      // TODO there's an ambiguity here - we need to overwrite in the `reset()`
      // case, but not initially...

      for (var key in newPartials) {
        if (overwrite || !hasOwn(existingPartials, key)) {
          existingPartials[key] = newPartials[key];
        }
      }
    }

    var registryNames = [
      'adaptors',
      'components',
      'computed',
      'decorators',
      'easing',
      'events',
      'helpers',
      'interpolators',
      'partials',
      'transitions'
    ];

    var registriesOnDefaults = ['computed', 'helpers'];

    var Registry = function Registry(name, useDefaults) {
      this.name = name;
      this.useDefaults = useDefaults;
    };
    var Registry__proto__ = Registry.prototype;

    Registry__proto__.extend = function extend (Parent, proto, options) {
      var parent = this.useDefaults ? Parent.defaults : Parent;
      var target = this.useDefaults ? proto : proto.constructor;
      this.configure(parent, target, options);
    };

    Registry__proto__.init = function init () {
      // noop
    };

    Registry__proto__.configure = function configure (Parent, target, options) {
      var name = this.name;
      var option = options[name];

      var registry = create(Parent[name]);

      assign(registry, option);

      target[name] = registry;

      if (name === 'partials' && target[name]) {
        keys(target[name]).forEach(function (key) {
          addFunctions(target[name][key]);
        });
      }
    };

    Registry__proto__.reset = function reset (ractive) {
      var registry = ractive[this.name];
      var changed = false;

      keys(registry).forEach(function (key) {
        var item = registry[key];

        if (item._fn) {
          if (item._fn.isOwner) {
            registry[key] = item._fn;
          } else {
            delete registry[key];
          }
          changed = true;
        }
      });

      return changed;
    };

    var registries = registryNames.map(function (name) {
      var putInDefaults = registriesOnDefaults.indexOf(name) > -1;
      return new Registry(name, putInDefaults);
    });

    function wrap$1(parent, name, method) {
      if (!/_super/.test(method)) { return method; }

      function wrapper() {
        var superMethod = getSuperMethod(wrapper._parent, name);
        var hasSuper = '_super' in this;
        var oldSuper = this._super;

        this._super = superMethod;

        var result = method.apply(this, arguments);

        if (hasSuper) {
          this._super = oldSuper;
        } else {
          delete this._super;
        }

        return result;
      }

      wrapper._parent = parent;
      wrapper._method = method;

      return wrapper;
    }

    function getSuperMethod(parent, name) {
      if (name in parent) {
        var value = parent[name];

        return isFunction(value) ? value : function () { return value; };
      }

      return noop;
    }

    function getMessage(deprecated, correct, isError) {
      return (
        "options." + deprecated + " has been deprecated in favour of options." + correct + "." +
        (isError ? (" You cannot specify both options, please use options." + correct + ".") : '')
      );
    }

    function deprecateOption(options, deprecatedOption, correct) {
      if (deprecatedOption in options) {
        if (!(correct in options)) {
          warnIfDebug(getMessage(deprecatedOption, correct));
          options[correct] = options[deprecatedOption];
        } else {
          throw new Error(getMessage(deprecatedOption, correct, true));
        }
      }
    }

    function deprecate(options) {
      deprecateOption(options, 'beforeInit', 'onconstruct');
      deprecateOption(options, 'init', 'onrender');
      deprecateOption(options, 'complete', 'oncomplete');
      deprecateOption(options, 'eventDefinitions', 'events');

      // Using extend with Component instead of options,
      // like Human.extend( Spider ) means adaptors as a registry
      // gets copied to options. So we have to check if actually an array
      if (isArray(options.adaptors)) {
        deprecateOption(options, 'adaptors', 'adapt');
      }
    }

    var config = {
      extend: function (Parent, proto, options, Child) { return configure('extend', Parent, proto, options, Child); },
      init: function (Parent, ractive, options) { return configure('init', Parent, ractive, options); },
      reset: function (ractive) { return order.filter(function (c) { return c.reset && c.reset(ractive); }).map(function (c) { return c.name; }); }
    };

    var custom = {
      adapt: adaptConfigurator,
      computed: config,
      css: cssConfigurator,
      data: dataConfigurator,
      helpers: config,
      template: templateConfigurator
    };

    var defaultKeys = keys(defaults);

    var isStandardKey = makeObj(defaultKeys.filter(function (key) { return !custom[key]; }));

    // blacklisted keys that we don't double extend
    var isBlacklisted = makeObj(
      defaultKeys.concat(registries.map(function (r) { return r.name; }), ['on', 'observe', 'attributes', 'cssData', 'use'])
    );

    var order = [].concat(
      defaultKeys.filter(function (key) { return !registries[key] && !custom[key]; }),
      registries,
      //custom.data,
      custom.template,
      custom.css
    );

    function configure(method, Parent, target, options, Child) {
      deprecate(options);

      for (var key in options) {
        if (hasOwn(isStandardKey, key)) {
          var value = options[key];

          // warn the developer if they passed a function and ignore its value

          // NOTE: we allow some functions on "el" because we duck type element lists
          // and some libraries or ef'ed-up virtual browsers (phantomJS) return a
          // function object as the result of querySelector methods
          if (key !== 'el' && isFunction(value)) {
            warnIfDebug(
              (key + " is a Ractive option that does not expect a function and will be ignored"),
              method === 'init' ? target : null
            );
          } else {
            target[key] = value;
          }
        }
      }

      // disallow combination of `append` and `enhance`
      if (target.append && target.enhance) {
        throw new Error('Cannot use append and enhance at the same time');
      }

      registries.forEach(function (registry) {
        registry[method](Parent, target, options, Child);
      });

      adaptConfigurator[method](Parent, target, options, Child);
      templateConfigurator[method](Parent, target, options, Child);
      cssConfigurator[method](Parent, target, options, Child);

      extendOtherMethods(Parent.prototype, target, options);
    }

    var _super = /\b_super\b/;
    function extendOtherMethods(parent, target, options) {
      for (var key in options) {
        if (!isBlacklisted[key] && hasOwn(options, key)) {
          var member = options[key];

          // if this is a method that overwrites a method, wrap it:
          if (isFunction(member)) {
            if (
              (key in proto$9 ||
                (key.slice(0, 2) === 'on' && key.slice(2) in hooks && key in target)) &&
              !_super.test(member.toString())
            ) {
              warnIfDebug(
                ("Overriding Ractive prototype function '" + key + "' without calling the '" + _super + "' method can be very dangerous.")
              );
            }
            member = wrap$1(parent, key, member);
          }

          target[key] = member;
        }
      }
    }

    function makeObj(array) {
      var obj = {};
      array.forEach(function (x) { return (obj[x] = true); });
      return obj;
    }

    var Item = function Item(options) {
      this.up = options.up;
      this.ractive = options.up.ractive;

      this.template = options.template;
      this.index = options.index;
      this.type = options.template.t;

      this.dirty = false;
    };
    var Item__proto__ = Item.prototype;

    Item__proto__.bubble = function bubble () {
      if (!this.dirty) {
        this.dirty = true;
        this.up.bubble();
      }
    };

    Item__proto__.destroyed = function destroyed () {
      if (this.fragment) { this.fragment.destroyed(); }
    };

    Item__proto__.find = function find () {
      return null;
    };

    Item__proto__.findComponent = function findComponent () {
      return null;
    };

    Item__proto__.findNextNode = function findNextNode () {
      return this.up.findNextNode(this);
    };

    Item__proto__.rebound = function rebound (update) {
      if (this.fragment) { this.fragment.rebound(update); }
    };

    Item__proto__.shuffled = function shuffled () {
      if (this.fragment) { this.fragment.shuffled(); }
    };

    Item__proto__.valueOf = function valueOf () {
      return this.toString();
    };

    Item.prototype.findAll = noop;
    Item.prototype.findAllComponents = noop;

    var ContainerItem = (function (Item) {
      function ContainerItem(options) {
        Item.call(this, options);
      }

      if ( Item ) ContainerItem.__proto__ = Item;
      var ContainerItem__proto__ = ContainerItem.prototype = Object.create( Item && Item.prototype );
      ContainerItem__proto__.constructor = ContainerItem;

      ContainerItem__proto__.detach = function detach () {
        return this.fragment ? this.fragment.detach() : createDocumentFragment();
      };

      ContainerItem__proto__.find = function find (selector) {
        if (this.fragment) {
          return this.fragment.find(selector);
        }
      };

      ContainerItem__proto__.findAll = function findAll (selector, options) {
        if (this.fragment) {
          this.fragment.findAll(selector, options);
        }
      };

      ContainerItem__proto__.findComponent = function findComponent (name) {
        if (this.fragment) {
          return this.fragment.findComponent(name);
        }
      };

      ContainerItem__proto__.findAllComponents = function findAllComponents (name, options) {
        if (this.fragment) {
          this.fragment.findAllComponents(name, options);
        }
      };

      ContainerItem__proto__.firstNode = function firstNode (skipParent) {
        return this.fragment && this.fragment.firstNode(skipParent);
      };

      ContainerItem__proto__.toString = function toString (escape) {
        return this.fragment ? this.fragment.toString(escape) : '';
      };

      return ContainerItem;
    }(Item));

    var space = /\s+/;

    function readStyle(css) {
      if (!isString(css)) { return {}; }

      return cleanCss(css, function (css, reconstruct) {
        return css
          .split(';')
          .filter(function (rule) { return !!rule.trim(); })
          .map(reconstruct)
          .reduce(function (rules, rule) {
            var i = rule.indexOf(':');
            var name = rule.substr(0, i).trim();
            rules[name] = rule.substr(i + 1).trim();
            return rules;
          }, {});
      });
    }

    function readClass(str) {
      var list = str.split(space);

      // remove any empty entries
      var i = list.length;
      while (i--) {
        if (!list[i]) { list.splice(i, 1); }
      }

      return list;
    }

    var textTypes = [
      undefined,
      'text',
      'search',
      'url',
      'email',
      'hidden',
      'password',
      'search',
      'reset',
      'submit'
    ];

    function getUpdateDelegate(attribute) {
      var element = attribute.element;
      var name = attribute.name;

      if (name === 'value') {
        if (attribute.interpolator) { attribute.interpolator.bound = true; }

        // special case - selects
        if (element.name === 'select' && name === 'value') {
          return element.getAttribute('multiple') ? updateMultipleSelectValue : updateSelectValue;
        }

        if (element.name === 'textarea') { return updateStringValue; }

        // special case - contenteditable
        if (element.getAttribute('contenteditable') != null) { return updateContentEditableValue; }

        // special case - <input>
        if (element.name === 'input') {
          var type = element.getAttribute('type');

          // type='file' value='{{fileList}}'>
          if (type === 'file') { return noop; } // read-only

          // type='radio' name='{{twoway}}'
          if (type === 'radio' && element.binding && element.binding.attribute.name === 'name')
            { return updateRadioValue; }

          if (~textTypes.indexOf(type)) { return updateStringValue; }
        }

        return updateValue;
      }

      var node = element.node;

      // special case - <input type='radio' name='{{twoway}}' value='foo'>
      if (attribute.isTwoway && name === 'name') {
        if (node.type === 'radio') { return updateRadioName; }
        if (node.type === 'checkbox') { return updateCheckboxName; }
      }

      if (name === 'style') { return updateStyleAttribute; }

      if (name.indexOf('style-') === 0) { return updateInlineStyle; }

      // special case - class names. IE fucks things up, again
      if (name === 'class' && (!node.namespaceURI || node.namespaceURI === html))
        { return updateClassName; }

      if (name.indexOf('class-') === 0) { return updateInlineClass; }

      if (attribute.isBoolean) {
        var type$1 = element.getAttribute('type');
        if (attribute.interpolator && name === 'checked' && (type$1 === 'checkbox' || type$1 === 'radio'))
          { attribute.interpolator.bound = true; }
        return updateBoolean;
      }

      if (attribute.namespace && attribute.namespace !== attribute.node.namespaceURI)
        { return updateNamespacedAttribute; }

      return updateAttribute;
    }

    function updateMultipleSelectValue(reset) {
      var value = this.getValue();

      if (!isArray(value)) { value = [value]; }

      var options = this.node.options;
      var i = options.length;

      if (reset) {
        while (i--) { options[i].selected = false; }
      } else {
        while (i--) {
          var option = options[i];
          var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive

          option.selected = arrayContains(value, optionValue);
        }
      }
    }

    function updateSelectValue(reset) {
      var value = this.getValue();

      if (!this.locked) {
        // TODO is locked still a thing?
        this.node._ractive.value = value;

        var options = this.node.options;
        var i = options.length;
        var wasSelected = false;

        if (reset) {
          while (i--) { options[i].selected = false; }
        } else {
          while (i--) {
            var option = options[i];
            var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive
            if (option.disabled && option.selected) { wasSelected = true; }

            if (optionValue == value) {
              // double equals as we may be comparing numbers with strings
              option.selected = true;
              return;
            }
          }
        }

        if (!wasSelected) { this.node.selectedIndex = -1; }
      }
    }

    function updateContentEditableValue(reset) {
      var value = this.getValue();

      if (!this.locked) {
        if (reset) { this.node.innerHTML = ''; }
        else { this.node.innerHTML = isUndefined(value) ? '' : value; }
      }
    }

    function updateRadioValue(reset) {
      var node = this.node;
      var wasChecked = node.checked;

      var value = this.getValue();

      if (reset) { return (node.checked = false); }

      //node.value = this.element.getAttribute( 'value' );
      node.value = this.node._ractive.value = value;
      node.checked = this.element.compare(value, this.element.getAttribute('name'));

      // This is a special case - if the input was checked, and the value
      // changed so that it's no longer checked, the twoway binding is
      // most likely out of date. To fix it we have to jump through some
      // hoops... this is a little kludgy but it works
      if (wasChecked && !node.checked && this.element.binding && this.element.binding.rendered) {
        this.element.binding.group.model.set(this.element.binding.group.getValue());
      }
    }

    function updateValue(reset) {
      if (!this.locked) {
        if (reset) {
          this.node.removeAttribute('value');
          this.node.value = this.node._ractive.value = null;
        } else {
          var value = this.getValue();

          this.node.value = this.node._ractive.value = value;
          this.node.setAttribute('value', safeToStringValue(value));
        }
      }
    }

    function updateStringValue(reset) {
      if (!this.locked) {
        if (reset) {
          this.node._ractive.value = '';
          this.node.removeAttribute('value');
        } else {
          var value = this.getValue();

          this.node._ractive.value = value;

          var safeValue = safeToStringValue(value);

          // fixes #3281 – Safari moves caret position when setting an input value to the same value
          if (this.node.value !== safeValue) {
            this.node.value = safeValue;
          }

          this.node.setAttribute('value', safeValue);
        }
      }
    }

    function updateRadioName(reset) {
      if (reset) { this.node.checked = false; }
      else { this.node.checked = this.element.compare(this.getValue(), this.element.binding.getValue()); }
    }

    function updateCheckboxName(reset) {
      var ref = this;
      var element = ref.element;
      var node = ref.node;
      var binding = element.binding;

      var value = this.getValue();
      var valueAttribute = element.getAttribute('value');

      if (!isArray(value)) {
        binding.isChecked = node.checked = element.compare(value, valueAttribute);
      } else {
        var i = value.length;
        while (i--) {
          if (element.compare(valueAttribute, value[i])) {
            binding.isChecked = node.checked = true;
            return;
          }
        }
        binding.isChecked = node.checked = false;
      }
    }

    function updateStyleAttribute(reset) {
      var props = reset ? {} : readStyle(this.getValue() || '');
      var style = this.node.style;
      var keys$$1 = keys(props);
      var prev = this.previous || [];

      var i = 0;
      while (i < keys$$1.length) {
        if (keys$$1[i] in style) {
          var safe = props[keys$$1[i]].replace('!important', '');
          style.setProperty(keys$$1[i], safe, safe.length !== props[keys$$1[i]].length ? 'important' : '');
        }
        i++;
      }

      // remove now-missing attrs
      i = prev.length;
      while (i--) {
        if (!~keys$$1.indexOf(prev[i]) && prev[i] in style) { style.setProperty(prev[i], '', ''); }
      }

      this.previous = keys$$1;
    }

    function updateInlineStyle(reset) {
      if (!this.style) {
        this.style = hyphenateCamel(this.name.substr(6));
      }

      if (reset && this.node.style.getPropertyValue(this.style) !== this.last) { return; }

      var value = reset ? '' : safeToStringValue(this.getValue());
      var safe = value.replace('!important', '');
      this.node.style.setProperty(this.style, safe, safe.length !== value.length ? 'important' : '');
      this.last = this.node.style.getPropertyValue(this.style);
    }

    function updateClassName(reset) {
      var value = reset ? [] : readClass(safeToStringValue(this.getValue()));

      // watch out for weirdo svg elements
      var cls = this.node.className;
      cls = cls.baseVal !== undefined ? cls.baseVal : cls;

      var attr = readClass(cls);
      var prev = this.previous || [];

      var className = value.concat(attr.filter(function (c) { return !~prev.indexOf(c); })).join(' ');

      if (className !== cls) {
        if (!isString(this.node.className)) {
          this.node.className.baseVal = className;
        } else {
          this.node.className = className;
        }
      }

      this.previous = value;
    }

    function updateInlineClass(reset) {
      var name = this.name.substr(6);

      // watch out for weirdo svg elements
      var cls = this.node.className;
      cls = cls.baseVal !== undefined ? cls.baseVal : cls;

      var attr = readClass(cls);
      var value = reset ? false : this.getValue();

      if (!this.inlineClass) { this.inlineClass = name; }

      if (value && !~attr.indexOf(name)) { attr.push(name); }
      else if (!value && ~attr.indexOf(name)) { attr.splice(attr.indexOf(name), 1); }

      if (!isString(this.node.className)) {
        this.node.className.baseVal = attr.join(' ');
      } else {
        this.node.className = attr.join(' ');
      }
    }

    function updateBoolean(reset) {
      // with two-way binding, only update if the change wasn't initiated by the user
      // otherwise the cursor will often be sent to the wrong place
      if (!this.locked) {
        if (reset) {
          if (this.useProperty) { this.node[this.propertyName] = false; }
          this.node.removeAttribute(this.propertyName);
        } else {
          if (this.useProperty) {
            this.node[this.propertyName] = this.getValue();
          } else {
            var val = this.getValue();
            if (val) {
              this.node.setAttribute(this.propertyName, isString(val) ? val : '');
            } else {
              this.node.removeAttribute(this.propertyName);
            }
          }
        }
      }
    }

    function updateAttribute(reset) {
      if (reset) {
        if (this.node.getAttribute(this.name) === this.value) {
          this.node.removeAttribute(this.name);
        }
      } else {
        this.value = safeToStringValue(this.getString());
        this.node.setAttribute(this.name, this.value);
      }
    }

    function updateNamespacedAttribute(reset) {
      if (reset) {
        if (
          this.value ===
          this.node.getAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1))
        ) {
          this.node.removeAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1));
        }
      } else {
        this.value = safeToStringValue(this.getString());
        this.node.setAttributeNS(
          this.namespace,
          this.name.slice(this.name.indexOf(':') + 1),
          this.value
        );
      }
    }

    var propertyNames = {
      'accept-charset': 'acceptCharset',
      accesskey: 'accessKey',
      bgcolor: 'bgColor',
      class: 'className',
      codebase: 'codeBase',
      colspan: 'colSpan',
      contenteditable: 'contentEditable',
      datetime: 'dateTime',
      dirname: 'dirName',
      for: 'htmlFor',
      'http-equiv': 'httpEquiv',
      ismap: 'isMap',
      maxlength: 'maxLength',
      novalidate: 'noValidate',
      pubdate: 'pubDate',
      readonly: 'readOnly',
      rowspan: 'rowSpan',
      tabindex: 'tabIndex',
      usemap: 'useMap'
    };

    var div$1 = doc ? createElement('div') : null;

    var attributes = false;
    function inAttributes() {
      return attributes;
    }

    var ConditionalAttribute = (function (Item) {
      function ConditionalAttribute(options) {
        Item.call(this, options);

        this.attributes = [];

        this.owner = options.owner;

        this.fragment = new Fragment({
          ractive: this.ractive,
          owner: this,
          template: this.template
        });

        // this fragment can't participate in node-y things
        this.fragment.findNextNode = noop;

        this.dirty = false;
      }

      if ( Item ) ConditionalAttribute.__proto__ = Item;
      var ConditionalAttribute__proto__ = ConditionalAttribute.prototype = Object.create( Item && Item.prototype );
      ConditionalAttribute__proto__.constructor = ConditionalAttribute;

      ConditionalAttribute__proto__.bind = function bind () {
        this.fragment.bind();
      };

      ConditionalAttribute__proto__.bubble = function bubble () {
        if (!this.dirty) {
          this.dirty = true;
          this.owner.bubble();
        }
      };

      ConditionalAttribute__proto__.destroyed = function destroyed () {
        this.unrender();
      };

      ConditionalAttribute__proto__.render = function render () {
        this.node = this.owner.node;
        if (this.node) {
          this.isSvg = this.node.namespaceURI === svg$1;
        }

        attributes = true;
        if (!this.rendered) { this.fragment.render(); }

        this.rendered = true;
        this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js
        this.update();
        attributes = false;
      };

      ConditionalAttribute__proto__.toString = function toString () {
        return this.fragment.toString();
      };

      ConditionalAttribute__proto__.unbind = function unbind (view) {
        this.fragment.unbind(view);
      };

      ConditionalAttribute__proto__.unrender = function unrender () {
        this.rendered = false;
        this.fragment.unrender();
      };

      ConditionalAttribute__proto__.update = function update () {
        var this$1 = this;

        var str;
        var attrs;

        if (this.dirty) {
          this.dirty = false;

          var current = attributes;
          attributes = true;
          this.fragment.update();

          if (this.rendered && this.node) {
            str = this.fragment.toString();

            attrs = parseAttributes(str, this.isSvg);

            // any attributes that previously existed but no longer do
            // must be removed
            this.attributes
              .filter(function (a) { return notIn(attrs, a); })
              .forEach(function (a) {
                this$1.node.removeAttribute(a.name);
              });

            attrs.forEach(function (a) {
              this$1.node.setAttribute(a.name, a.value);
            });

            this.attributes = attrs;
          }

          attributes = current || false;
        }
      };

      return ConditionalAttribute;
    }(Item));

    var onlyWhitespace = /^\s*$/;
    function parseAttributes(str, isSvg) {
      if (onlyWhitespace.test(str)) { return []; }
      var tagName = isSvg ? 'svg' : 'div';
      return str
        ? (div$1.innerHTML = "<" + tagName + " " + str + "></" + tagName + ">") && toArray(div$1.childNodes[0].attributes)
        : [];
    }

    function notIn(haystack, needle) {
      var i = haystack.length;

      while (i--) {
        if (haystack[i].name === needle.name) {
          return false;
        }
      }

      return true;
    }

    function lookupNamespace(node, prefix) {
      var qualified = "xmlns:" + prefix;

      while (node) {
        if (node.hasAttribute && node.hasAttribute(qualified)) { return node.getAttribute(qualified); }
        node = node.parentNode;
      }

      return namespaces[prefix];
    }

    var attribute = false;
    function inAttribute() {
      return attribute;
    }

    var Attribute = (function (Item) {
      function Attribute(options) {
        Item.call(this, options);

        this.name = options.template.n;
        this.namespace = null;

        this.owner = options.owner || options.up.owner || options.element || findElement(options.up);
        this.element =
          options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));
        this.up = options.up; // shared
        this.ractive = this.up.ractive;

        this.rendered = false;
        this.updateDelegate = null;
        this.fragment = null;

        this.element.attributeByName[this.name] = this;

        if (!isArray(options.template.f)) {
          this.value = options.template.f;
          if (this.value === 0) {
            this.value = '';
          } else if (isUndefined(this.value)) {
            this.value = true;
          }
          return;
        } else {
          this.fragment = new Fragment({
            owner: this,
            template: options.template.f
          });
        }

        this.interpolator =
          this.fragment &&
          this.fragment.items.length === 1 &&
          this.fragment.items[0].type === INTERPOLATOR &&
          this.fragment.items[0];

        if (this.interpolator) { this.interpolator.owner = this; }
      }

      if ( Item ) Attribute.__proto__ = Item;
      var Attribute__proto__ = Attribute.prototype = Object.create( Item && Item.prototype );
      Attribute__proto__.constructor = Attribute;

      Attribute__proto__.bind = function bind () {
        if (this.fragment) {
          this.fragment.bind();
        }
      };

      Attribute__proto__.bubble = function bubble () {
        if (!this.dirty) {
          this.up.bubble();
          this.element.bubble();
          this.dirty = true;
        }
      };

      Attribute__proto__.firstNode = function firstNode () {};

      Attribute__proto__.getString = function getString () {
        attribute = true;
        var value = this.fragment
          ? this.fragment.toString()
          : this.value != null
          ? '' + this.value
          : '';
        attribute = false;
        return value;
      };

      // TODO could getValue ever be called for a static attribute,
      // or can we assume that this.fragment exists?
      Attribute__proto__.getValue = function getValue () {
        attribute = true;
        var value = this.fragment
          ? this.fragment.valueOf()
          : booleanAttributes[this.name.toLowerCase()]
          ? true
          : this.value;
        attribute = false;
        return value;
      };

      Attribute__proto__.render = function render () {
        var node = this.element.node;
        this.node = node;

        // should we use direct property access, or setAttribute?
        if (!node.namespaceURI || node.namespaceURI === namespaces.html) {
          this.propertyName = propertyNames[this.name] || this.name;

          if (node[this.propertyName] !== undefined) {
            this.useProperty = true;
          }

          // is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
          // node.selected = true rather than node.setAttribute( 'selected', '' )
          if (booleanAttributes[this.name.toLowerCase()] || this.isTwoway) {
            this.isBoolean = true;
          }

          if (this.propertyName === 'value') {
            node._ractive.value = this.value;
          }
        }

        if (node.namespaceURI) {
          var index = this.name.indexOf(':');
          if (index !== -1) {
            this.namespace = lookupNamespace(node, this.name.slice(0, index));
          } else {
            this.namespace = node.namespaceURI;
          }
        }

        this.rendered = true;
        this.updateDelegate = getUpdateDelegate(this);
        this.updateDelegate();
      };

      Attribute__proto__.toString = function toString () {
        if (inAttributes()) { return ''; }
        attribute = true;

        var value = this.getValue();

        // Special case - select and textarea values (should not be stringified)
        if (
          this.name === 'value' &&
          (this.element.getAttribute('contenteditable') !== undefined ||
            (this.element.name === 'select' || this.element.name === 'textarea'))
        ) {
          return;
        }

        // Special case – bound radio `name` attributes
        if (
          this.name === 'name' &&
          this.element.name === 'input' &&
          this.interpolator &&
          this.element.getAttribute('type') === 'radio'
        ) {
          return ("name=\"{{" + (this.interpolator.model.getKeypath()) + "}}\"");
        }

        // Special case - style and class attributes and directives
        if (
          this.owner === this.element &&
          (this.name === 'style' || this.name === 'class' || this.style || this.inlineClass)
        ) {
          return;
        }

        if (
          !this.rendered &&
          this.owner === this.element &&
          (!this.name.indexOf('style-') || !this.name.indexOf('class-'))
        ) {
          if (!this.name.indexOf('style-')) {
            this.style = hyphenateCamel(this.name.substr(6));
          } else {
            this.inlineClass = this.name.substr(6);
          }

          return;
        }

        if (booleanAttributes[this.name.toLowerCase()])
          { return value
            ? isString(value)
              ? ((this.name) + "=\"" + (safeAttributeString(value)) + "\"")
              : this.name
            : ''; }
        if (value == null) { return ''; }

        var str = safeAttributeString(this.getString());
        attribute = false;

        return str ? ((this.name) + "=\"" + str + "\"") : this.name;
      };

      Attribute__proto__.unbind = function unbind (view) {
        if (this.fragment) { this.fragment.unbind(view); }
      };

      Attribute__proto__.unrender = function unrender () {
        this.updateDelegate(true);

        this.rendered = false;
      };

      Attribute__proto__.update = function update () {
        if (this.dirty) {
          var binding;
          this.dirty = false;
          if (this.fragment) { this.fragment.update(); }
          if (this.rendered) { this.updateDelegate(); }
          if (this.isTwoway && !this.locked) {
            this.interpolator.twowayBinding.lastVal(true, this.interpolator.model.get());
          } else if (this.name === 'value' && (binding = this.element.binding)) {
            // special case: name bound element with dynamic value
            var attr = binding.attribute;
            if (attr && !attr.dirty && attr.rendered) {
              this.element.binding.attribute.updateDelegate();
            }
          }
        }
      };

      return Attribute;
    }(Item));

    var BindingFlag = (function (Item) {
      function BindingFlag(options) {
        Item.call(this, options);

        this.owner = options.owner || options.up.owner || findElement(options.up);
        this.element = this.owner.attributeByName ? this.owner : findElement(options.up);
        this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';
        this.bubbler = this.owner === this.element ? this.element : this.up;

        if (this.element.type === ELEMENT) {
          if (isArray(options.template.f)) {
            this.fragment = new Fragment({
              owner: this,
              template: options.template.f
            });
          }

          this.interpolator =
            this.fragment &&
            this.fragment.items.length === 1 &&
            this.fragment.items[0].type === INTERPOLATOR &&
            this.fragment.items[0];
        }
      }

      if ( Item ) BindingFlag.__proto__ = Item;
      var BindingFlag__proto__ = BindingFlag.prototype = Object.create( Item && Item.prototype );
      BindingFlag__proto__.constructor = BindingFlag;

      BindingFlag__proto__.bind = function bind () {
        if (this.fragment) { this.fragment.bind(); }
        set$1(this, this.getValue(), true);
      };

      BindingFlag__proto__.bubble = function bubble () {
        if (!this.dirty) {
          this.bubbler.bubble();
          this.dirty = true;
        }
      };

      BindingFlag__proto__.getValue = function getValue () {
        if (this.fragment) { return this.fragment.valueOf(); }
        else if ('value' in this) { return this.value; }
        else if ('f' in this.template) { return this.template.f; }
        else { return true; }
      };

      BindingFlag__proto__.render = function render () {
        set$1(this, this.getValue(), true);
      };

      BindingFlag__proto__.toString = function toString () {
        return '';
      };

      BindingFlag__proto__.unbind = function unbind (view) {
        if (this.fragment) { this.fragment.unbind(view); }

        delete this.element[this.flag];
      };

      BindingFlag__proto__.unrender = function unrender () {
        if (this.element.rendered) { this.element.recreateTwowayBinding(); }
      };

      BindingFlag__proto__.update = function update () {
        if (this.dirty) {
          this.dirty = false;
          if (this.fragment) { this.fragment.update(); }
          set$1(this, this.getValue(), true);
        }
      };

      return BindingFlag;
    }(Item));

    function set$1(flag, value, update) {
      if (value === 0) {
        flag.value = true;
      } else if (value === 'true') {
        flag.value = true;
      } else if (value === 'false' || value === '0') {
        flag.value = false;
      } else {
        flag.value = value;
      }

      var current = flag.element[flag.flag];
      flag.element[flag.flag] = flag.value;
      if (update && !flag.element.attributes.binding && current !== flag.value) {
        flag.element.recreateTwowayBinding();
      }

      return flag.value;
    }

    function Comment(options) {
      Item.call(this, options);
    }

    var proto$1 = create(Item.prototype);

    assign(proto$1, {
      bind: noop,
      unbind: noop,
      update: noop,

      detach: function detach() {
        return detachNode(this.node);
      },

      firstNode: function firstNode() {
        return this.node;
      },

      render: function render(target) {
        this.rendered = true;

        this.node = doc.createComment(this.template.c);
        target.appendChild(this.node);
      },

      toString: function toString() {
        return ("<!-- " + (this.template.c) + " -->");
      },

      unrender: function unrender(shouldDestroy) {
        if (this.rendered && shouldDestroy) { this.detach(); }
        this.rendered = false;
      }
    });

    Comment.prototype = proto$1;

    // Teardown. This goes through the root fragment and all its children, removing observers
    // and generally cleaning up after itself

    function Ractive$teardown() {
      var this$1 = this;

      if (this.torndown) {
        warnIfDebug('ractive.teardown() was called on a Ractive instance that was already torn down');
        return Promise.resolve();
      }

      this.shouldDestroy = true;
      return teardown$1(this, function () { return (this$1.fragment.rendered ? this$1.unrender() : Promise.resolve()); });
    }

    function teardown$1(instance, getPromise) {
      instance.torndown = true;
      instance.fragment.unbind();
      instance._observers.slice().forEach(cancel);

      if (instance.el && instance.el.__ractive_instances__) {
        removeFromArray(instance.el.__ractive_instances__, instance);
      }

      var promise = getPromise();

      hooks.teardown.fire(instance);

      promise.then(function () {
        hooks.destruct.fire(instance);
        instance.viewmodel.teardown();
      });

      return promise;
    }

    var RactiveModel = (function (SharedModel) {
      function RactiveModel(ractive) {
        SharedModel.call(this, ractive, '@this');
        this.ractive = ractive;
      }

      if ( SharedModel ) RactiveModel.__proto__ = SharedModel;
      var RactiveModel__proto__ = RactiveModel.prototype = Object.create( SharedModel && SharedModel.prototype );
      RactiveModel__proto__.constructor = RactiveModel;

      RactiveModel__proto__.joinKey = function joinKey (key) {
        var model = SharedModel.prototype.joinKey.call(this, key);

        if ((key === 'root' || key === 'parent') && !model.isLink) { return initLink(model, key); }
        else if (key === 'data') { return this.ractive.viewmodel; }
        else if (key === 'cssData') { return this.ractive.constructor._cssModel; }

        return model;
      };

      return RactiveModel;
    }(SharedModel));

    function initLink(model, key) {
      model.applyValue = function(value) {
        this.parent.value[key] = value;
        if (value && value.viewmodel) {
          this.link(value.viewmodel.getRactiveModel(), key);
          this._link.markedAll();
        } else {
          this.link(create(Missing), key);
          this._link.markedAll();
        }
      };

      if (key === 'root') {
        var mark = model.mark;
        model.mark = function(force) {
          if (this._marking) { return; }
          this._marking = true;
          mark.apply(this, force);
          this._marking = false;
        };
      }

      model.applyValue(model.parent.ractive[key], key);
      model._link.set = function (v) { return model.applyValue(v); };
      model._link.applyValue = function (v) { return model.applyValue(v); };

      return model._link;
    }

    var specialModels = {
      '@this': function _this(root) {
        return root.getRactiveModel();
      },
      '@global': function _global() {
        return GlobalModel;
      },
      '@shared': function _shared() {
        return SharedModel$1;
      },
      '@style': function _style(root) {
        return root.getRactiveModel().joinKey('cssData');
      },
      '@helpers': function _helpers(root) {
        return root.getHelpers();
      }
    };
    specialModels['@'] = specialModels['@this'];

    var RootModel = (function (Model) {
      function RootModel(options) {
        Model.call(this, null, null);

        this.isRoot = true;
        this.root = this;
        this.ractive = options.ractive; // TODO sever this link

        this.value = options.data;
        this.adaptors = options.adapt;
        this.adapt();
      }

      if ( Model ) RootModel.__proto__ = Model;
      var RootModel__proto__ = RootModel.prototype = Object.create( Model && Model.prototype );
      RootModel__proto__.constructor = RootModel;

      RootModel__proto__.attached = function attached (fragment) {
        attachImplicits(this, fragment);
      };

      RootModel__proto__.createLink = function createLink (keypath, target, targetPath, options) {
        var keys = splitKeypath(keypath);

        var model = this;
        while (keys.length) {
          var key = keys.shift();
          model = model.childByKey[key] || model.joinKey(key);
        }

        return model.link(target, targetPath, options);
      };

      RootModel__proto__.detached = function detached () {
        detachImplicits(this);
      };

      RootModel__proto__.get = function get (shouldCapture, options) {
        if (shouldCapture) { capture(this); }

        if (!options || options.virtual !== false) {
          return this.getVirtual();
        } else {
          return this.value;
        }
      };

      RootModel__proto__.getHelpers = function getHelpers () {
        if (!this.helpers) { this.helpers = new SharedModel(this.ractive.helpers, 'helpers', this.ractive); }
        return this.helpers;
      };

      RootModel__proto__.getKeypath = function getKeypath () {
        return '';
      };

      RootModel__proto__.getRactiveModel = function getRactiveModel () {
        return this.ractiveModel || (this.ractiveModel = new RactiveModel(this.ractive));
      };

      RootModel__proto__.getValueChildren = function getValueChildren () {
        var children = Model.prototype.getValueChildren.call(this, this.value);

        this.children.forEach(function (child) {
          if (child._link) {
            var idx = children.indexOf(child);
            if (~idx) { children.splice(idx, 1, child._link); }
            else { children.push(child._link); }
          }
        });

        return children;
      };

      RootModel__proto__.has = function has (key) {
        if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }
        if (specialModels[key] || key === '') { return true; }

        if (Model.prototype.has.call(this, key)) {
          return true;
        } else {
          var unescapedKey = unescapeKey(key);

          // mappings/links and computations
          if (this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link) { return true; }
        }
      };

      RootModel__proto__.joinKey = function joinKey (key, opts) {
        if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }

        if (key[0] === '@') {
          var fn = specialModels[key];
          if (fn) { return fn(this); }
        } else {
          return Model.prototype.joinKey.call(this, key, opts);
        }
      };

      RootModel__proto__.set = function set (value) {
        // TODO wrapping root node is a baaaad idea. We should prevent this
        var wrapper = this.wrapper;
        if (wrapper) {
          var shouldTeardown = !wrapper.reset || wrapper.reset(value) === false;

          if (shouldTeardown) {
            wrapper.teardown();
            this.wrapper = null;
            this.value = value;
            this.adapt();
          }
        } else {
          this.value = value;
          this.adapt();
        }

        this.deps.forEach(handleChange);
        this.children.forEach(mark);
      };

      RootModel__proto__.retrieve = function retrieve () {
        return this.wrapper ? this.wrapper.get() : this.value;
      };

      RootModel__proto__.teardown = function teardown () {
        Model.prototype.teardown.call(this);
        this.ractiveModel && this.ractiveModel.teardown();
      };

      return RootModel;
    }(Model));
    RootModel.prototype.update = noop;

    function attachImplicits(model, fragment) {
      if (model._link && model._link.implicit && model._link.isDetached()) {
        model.attach(fragment);
      }

      // look for virtual children to relink and cascade
      for (var k in model.childByKey) {
        if (model.value) {
          if (k in model.value) {
            attachImplicits(model.childByKey[k], fragment);
          } else if (!model.childByKey[k]._link || model.childByKey[k]._link.isDetached()) {
            var mdl = resolveReference(fragment, k);
            if (mdl) {
              model.childByKey[k].link(mdl, k, { implicit: true });
            }
          }
        }
      }
    }

    function detachImplicits(model) {
      if (model._link && model._link.implicit) {
        model.unlink();
      }

      for (var k in model.childByKey) {
        detachImplicits(model.childByKey[k]);
      }
    }

    function subscribe(instance, options, type) {
      var subs = (instance.constructor[("_" + type)] || []).concat(toPairs(options[type] || []));
      var single = type === 'on' ? 'once' : (type + "Once");

      subs.forEach(function (ref) {
        var target = ref[0];
        var config = ref[1];

        if (isFunction(config)) {
          instance[type](target, config);
        } else if (isObjectType(config) && isFunction(config.handler)) {
          instance[config.once ? single : type](target, config.handler, create(config));
        }
      });
    }

    var registryNames$1 = [
      'adaptors',
      'components',
      'decorators',
      'easing',
      'events',
      'interpolators',
      'partials',
      'transitions'
    ];

    var protoRegistries = ['computed', 'helpers'];

    var uid = 0;

    function construct(ractive, options) {
      if (Ractive.DEBUG) { welcome(); }

      initialiseProperties(ractive);
      handleAttributes(ractive);

      // set up event subscribers
      subscribe(ractive, options, 'on');

      // if there's not a delegation setting, inherit from parent if it's not default
      if (
        !hasOwn(options, 'delegate') &&
        ractive.parent &&
        ractive.parent.delegate !== ractive.delegate
      ) {
        ractive.delegate = false;
      }

      // plugins that need to run at construct
      if (isArray(options.use)) {
        ractive.use.apply(ractive, options.use.filter(function (p) { return p.construct; }));
      }

      hooks.construct.fire(ractive, options);
      if (options.onconstruct) { options.onconstruct.call(ractive, getRactiveContext(ractive), options); }

      // Add registries
      var i = registryNames$1.length;
      while (i--) {
        var name = registryNames$1[i];
        ractive[name] = assign(create(ractive.constructor[name] || null), options[name]);
      }

      i = protoRegistries.length;
      while (i--) {
        var name$1 = protoRegistries[i];
        ractive[name$1] = assign(create(ractive.constructor.prototype[name$1]), options[name$1]);
      }

      if (ractive._attributePartial) {
        ractive.partials['extra-attributes'] = ractive._attributePartial;
        delete ractive._attributePartial;
      }

      // Create a viewmodel
      var viewmodel = new RootModel({
        adapt: getAdaptors(ractive, ractive.adapt, options),
        data: dataConfigurator.init(ractive.constructor, ractive, options),
        ractive: ractive
      });

      // once resolved, share the adaptors array between the root model and instance
      ractive.adapt = viewmodel.adaptors;

      ractive.viewmodel = viewmodel;

      for (var k in ractive.computed) {
        compute.call(ractive, k, ractive.computed[k]);
      }
    }

    function getAdaptors(ractive, protoAdapt, options) {
      protoAdapt = protoAdapt.map(lookup);
      var adapt = ensureArray(options.adapt).map(lookup);

      var srcs = [protoAdapt, adapt];
      if (ractive.parent && !ractive.isolated) {
        srcs.push(ractive.parent.viewmodel.adaptors);
      }

      return combine.apply(null, srcs);

      function lookup(adaptor) {
        if (isString(adaptor)) {
          adaptor = findInViewHierarchy('adaptors', ractive, adaptor);

          if (!adaptor) {
            fatal(missingPlugin(adaptor, 'adaptor'));
          }
        }

        return adaptor;
      }
    }

    function initialiseProperties(ractive) {
      // Generate a unique identifier, for places where you'd use a weak map if it
      // existed
      ractive._guid = 'r-' + uid++;

      // events
      ractive._subs = create(null);
      ractive._nsSubs = 0;

      // storage for item configuration from instantiation to reset,
      // like dynamic functions or original values
      ractive._config = {};

      // events
      ractive.event = null;
      ractive._eventQueue = [];

      // observers
      ractive._observers = [];

      // external children
      ractive._children = [];
      ractive._children.byName = {};
      ractive.children = ractive._children;

      if (!ractive.component) {
        ractive.root = ractive;
        ractive.parent = ractive.container = null; // TODO container still applicable?
      }
    }

    function handleAttributes(ractive) {
      var component = ractive.component;
      var attributes = ractive.constructor.attributes;

      if (attributes && component) {
        var tpl = component.template;
        var attrs = tpl.m ? tpl.m.slice() : [];

        // grab all of the passed attribute names
        var props = attrs.filter(function (a) { return a.t === ATTRIBUTE; }).map(function (a) { return a.n; });

        // warn about missing requireds
        attributes.required.forEach(function (p) {
          if (!~props.indexOf(p)) {
            warnIfDebug(("Component '" + (component.name) + "' requires attribute '" + p + "' to be provided"));
          }
        });

        // set up a partial containing non-property attributes
        var all = attributes.optional.concat(attributes.required);
        var partial = [];
        var i = attrs.length;
        while (i--) {
          var a = attrs[i];
          if (a.t === ATTRIBUTE && !~all.indexOf(a.n)) {
            if (attributes.mapAll) {
              // map the attribute if requested and make the extra attribute in the partial refer to the mapping
              partial.unshift({
                t: ATTRIBUTE,
                n: a.n,
                f: [{ t: INTERPOLATOR, r: ("~/" + (a.n)) }]
              });
            } else {
              // transfer the attribute to the extra attributes partal
              partial.unshift(attrs.splice(i, 1)[0]);
            }
          } else if (
            !attributes.mapAll &&
            (a.t === DECORATOR || a.t === TRANSITION || a.t === BINDING_FLAG)
          ) {
            partial.unshift(attrs.splice(i, 1)[0]);
          }
        }

        if (partial.length) { component.template = { t: tpl.t, e: tpl.e, f: tpl.f, m: attrs, p: tpl.p }; }
        ractive._attributePartial = partial;
      }
    }

    var Component = (function (Item) {
      function Component(options, ComponentConstructor) {
        var this$1 = this;

        Item.call(this, options);
        var template = options.template;
        this.isAnchor = template.t === ANCHOR;
        this.type = this.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super
        var attrs = template.m;

        var partials = template.p || {};
        if (!('content' in partials)) { partials.content = template.f || []; }
        this._partials = partials; // TEMP

        if (this.isAnchor) {
          this.name = template.n;

          this.addChild = addChild;
          this.removeChild = removeChild;
        } else {
          var instance = new ComponentConstructor({ component: true });

          this.instance = instance;
          this.name = template.e;

          if (instance.el || instance.target) {
            warnIfDebug(
              ("The <" + (this.name) + "> component has a default '" + (instance.el ? 'el' : 'target') + "' property; it has been disregarded")
            );
            instance.el = instance.target = null;
          }

          // find container
          var fragment = options.up;
          var container;
          while (fragment) {
            if (fragment.owner.type === YIELDER) {
              container = fragment.owner.container;
              break;
            }

            fragment = fragment.parent;
          }

          // add component-instance-specific properties
          instance.parent = this.up.ractive;
          instance.container = container || null;
          instance.root = instance.parent.root;
          instance.component = this;

          construct(this.instance, { partials: partials });

          // these can be modified during construction
          template = this.template;
          attrs = template.m;

          // allow components that are so inclined to add programmatic mappings
          if (isArray(this.mappings)) {
            attrs = (attrs || []).concat(this.mappings);
          } else if (isString(this.mappings)) {
            attrs = (attrs || []).concat(parser.parse(this.mappings, { attributes: true }).t);
          }

          // for hackability, this could be an open option
          // for any ractive instance, but for now, just
          // for components and just for ractive...
          instance._inlinePartials = partials;
        }

        this.attributeByName = {};
        this.attributes = [];

        if (attrs) {
          var leftovers = [];
          attrs.forEach(function (template) {
            switch (template.t) {
              case ATTRIBUTE:
              case EVENT:
                this$1.attributes.push(
                  createItem({
                    owner: this$1,
                    up: this$1.up,
                    template: template
                  })
                );
                break;

              case TRANSITION:
              case BINDING_FLAG:
              case DECORATOR:
                break;

              default:
                leftovers.push(template);
                break;
            }
          });

          if (leftovers.length) {
            this.attributes.push(
              new ConditionalAttribute({
                owner: this,
                up: this.up,
                template: leftovers
              })
            );
          }
        }

        this.eventHandlers = [];
      }

      if ( Item ) Component.__proto__ = Item;
      var Component__proto__ = Component.prototype = Object.create( Item && Item.prototype );
      Component__proto__.constructor = Component;

      Component__proto__.bind = function bind () {
        if (!this.isAnchor) {
          this.attributes.forEach(bind$1);
          this.eventHandlers.forEach(bind$1);

          initialise(
            this.instance,
            {
              partials: this._partials
            },
            {
              cssIds: this.up.cssIds
            }
          );

          if (this.instance.target || this.instance.el) { this.extern = true; }

          this.bound = true;
        }
      };

      Component__proto__.bubble = function bubble () {
        if (!this.dirty) {
          this.dirty = true;
          this.up.bubble();
        }
      };

      Component__proto__.destroyed = function destroyed () {
        if (!this.isAnchor && this.instance.fragment) { this.instance.fragment.destroyed(); }
      };

      Component__proto__.detach = function detach () {
        if (this.isAnchor) {
          if (this.instance) { return this.instance.fragment.detach(); }
          return createDocumentFragment();
        }

        return this.instance.fragment.detach();
      };

      Component__proto__.find = function find (selector, options) {
        if (this.instance) { return this.instance.fragment.find(selector, options); }
      };

      Component__proto__.findAll = function findAll (selector, options) {
        if (this.instance) { this.instance.fragment.findAll(selector, options); }
      };

      Component__proto__.findComponent = function findComponent (name, options) {
        if (!name || this.name === name) { return this.instance; }

        if (this.instance.fragment) {
          return this.instance.fragment.findComponent(name, options);
        }
      };

      Component__proto__.findAllComponents = function findAllComponents (name, options) {
        var result = options.result;

        if (this.instance && (!name || this.name === name)) {
          result.push(this.instance);
        }

        if (this.instance) { this.instance.findAllComponents(name, options); }
      };

      Component__proto__.firstNode = function firstNode (skipParent) {
        if (this.instance) { return this.instance.fragment.firstNode(skipParent); }
      };

      Component__proto__.getContext = function getContext () {
        var assigns = [], len = arguments.length;
        while ( len-- ) assigns[ len ] = arguments[ len ];

        assigns.unshift(this.instance);
        return getRactiveContext.apply(null, assigns);
      };

      Component__proto__.rebound = function rebound (update$$1) {
        this.attributes.forEach(function (x) { return x.rebound(update$$1); });
      };

      Component__proto__.render = function render$2 (target, occupants) {
        if (this.isAnchor) {
          this.rendered = true;
          this.target = target;

          if (!checking.length) {
            checking.push(this.ractive);
            if (occupants) {
              this.occupants = occupants;
              checkAnchors();
              this.occupants = null;
            } else {
              runloop.scheduleTask(checkAnchors, true);
            }
          }
        } else {
          this.attributes.forEach(render);
          this.eventHandlers.forEach(render);

          if (this.extern) {
            this.instance.delegate = false;
            this.instance.render();
          } else {
            render$1(this.instance, target, null, occupants);
          }

          this.rendered = true;
        }
      };

      Component__proto__.shuffled = function shuffled () {
        Item.prototype.shuffled.call(this);
        this.instance &&
          !this.instance.isolated &&
          this.instance.fragment &&
          this.instance.fragment.shuffled();
      };

      Component__proto__.toString = function toString () {
        if (this.instance) { return this.instance.toHTML(); }
      };

      Component__proto__.unbind = function unbind$1 (view) {
        if (!this.isAnchor) {
          this.bound = false;

          this.attributes.forEach(unbind);

          if (view) { this.instance.fragment.unbind(); }
          else { teardown$1(this.instance, function () { return runloop.promise(); }); }
        }
      };

      Component__proto__.unrender = function unrender$1 (shouldDestroy) {
        this.shouldDestroy = shouldDestroy;

        if (this.isAnchor) {
          if (this.item) { unrenderItem(this, this.item); }
          this.target = null;
          if (!checking.length) {
            checking.push(this.ractive);
            runloop.scheduleTask(checkAnchors, true);
          }
        } else {
          this.instance.unrender();
          this.instance.el = this.instance.target = null;
          this.attributes.forEach(unrender);
          this.eventHandlers.forEach(unrender);
        }

        this.rendered = false;
      };

      Component__proto__.update = function update$2 () {
        this.dirty = false;
        if (this.instance) {
          this.instance.fragment.update();
          this.attributes.forEach(update);
          this.eventHandlers.forEach(update);
        }
      };

      return Component;
    }(Item));

    function addChild(meta) {
      if (this.item) { this.removeChild(this.item); }

      var child = meta.instance;
      meta.anchor = this;

      meta.up = this.up;
      meta.name = meta.nameOption || this.name;
      this.name = meta.name;

      if (!child.isolated) { child.viewmodel.attached(this.up); }

      // render as necessary
      if (this.rendered) {
        renderItem(this, meta);
      }
    }

    function removeChild(meta) {
      // unrender as necessary
      if (this.item === meta) {
        unrenderItem(this, meta);
        this.name = this.template.n;
      }
    }

    function renderItem(anchor, meta) {
      if (!anchor.rendered) { return; }

      meta.shouldDestroy = false;
      meta.up = anchor.up;

      anchor.item = meta;
      anchor.instance = meta.instance;
      var nextNode = anchor.up.findNextNode(anchor);

      if (meta.instance.fragment.rendered) {
        meta.instance.unrender();
      }

      meta.partials = meta.instance.partials;
      meta.instance.partials = assign(create(meta.partials), meta.partials, anchor._partials);

      meta.instance.fragment.unbind(true);
      meta.instance.fragment.componentParent = anchor.up;
      meta.instance.fragment.bind(meta.instance.viewmodel);

      anchor.attributes.forEach(bind$1);
      anchor.eventHandlers.forEach(bind$1);
      anchor.attributes.forEach(render);
      anchor.eventHandlers.forEach(render);

      var target = anchor.up.findParentNode();
      render$1(meta.instance, target, target.contains(nextNode) ? nextNode : null, anchor.occupants);

      if (meta.lastBound !== anchor) {
        meta.lastBound = anchor;
      }
    }

    function unrenderItem(anchor, meta) {
      if (!anchor.rendered) { return; }

      meta.shouldDestroy = true;
      meta.instance.unrender();

      anchor.eventHandlers.forEach(unrender);
      anchor.attributes.forEach(unrender);
      anchor.eventHandlers.forEach(unbind);
      anchor.attributes.forEach(unbind);

      meta.instance.el = meta.instance.anchor = null;
      meta.instance.fragment.componentParent = null;
      meta.up = null;
      meta.anchor = null;
      anchor.item = null;
      anchor.instance = null;
    }

    var checking = [];
    function checkAnchors() {
      var list = checking;
      checking = [];

      list.forEach(updateAnchors);
    }

    var ComputationChild = (function (Model) {
      function ComputationChild(parent, key) {
        Model.call(this, parent, key);

        this.isReadonly = !this.root.ractive.syncComputedChildren;
        this.dirty = true;
        this.isComputed = true;
      }

      if ( Model ) ComputationChild.__proto__ = Model;
      var ComputationChild__proto__ = ComputationChild.prototype = Object.create( Model && Model.prototype );
      ComputationChild__proto__.constructor = ComputationChild;

      var prototypeAccessors$1 = { setRoot: {} };

      prototypeAccessors$1.setRoot.get = function () {
        return this.parent.setRoot;
      };

      ComputationChild__proto__.applyValue = function applyValue (value) {
        Model.prototype.applyValue.call(this, value);

        if (!this.isReadonly) {
          var source = this.parent;
          // computed models don't have a shuffle method
          while (source && source.shuffle) {
            source = source.parent;
          }

          if (source) {
            source.dependencies.forEach(mark);
          }
        }

        if (this.setRoot) {
          this.setRoot.set(this.setRoot.value);
        }
      };

      ComputationChild__proto__.get = function get (shouldCapture, opts) {
        if (shouldCapture) { capture(this); }

        if (this.dirty) {
          var parentValue = this.parent.get();
          this.value = parentValue ? parentValue[this.key] : undefined;
          if (this.wrapper) { this.newWrapperValue = this.value; }
          this.adapt();
        }

        this.dirty = false;

        return (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper
          ? this.wrapperValue
          : this.value;
      };

      ComputationChild__proto__.handleChange = function handleChange$2 () {
        if (this.dirty) {
          this.deps.forEach(handleChange);
          return;
        }

        this.dirty = true;

        if (this.boundValue) { this.boundValue = null; }

        this.links.forEach(marked);
        this.deps.forEach(handleChange);
        this.children.forEach(handleChange);
      };

      ComputationChild__proto__.joinKey = function joinKey (key) {
        if (isUndefined(key) || key === '') { return this; }

        if (!hasOwn(this.childByKey, key)) {
          var child = new ComputationChild(this, key);
          this.children.push(child);
          this.childByKey[key] = child;
        }

        return this.childByKey[key];
      };

      Object.defineProperties( ComputationChild__proto__, prototypeAccessors$1 );

      return ComputationChild;
    }(Model));

    /* global console */
    /* eslint no-console:"off" */

    var Computation = (function (Model) {
      function Computation(parent, signature, key) {
        Model.call(this, parent, key);

        this.signature = signature;

        this.isReadonly = !this.signature.setter;
        this.isComputed = true;

        this.dependencies = [];

        this.children = [];
        this.childByKey = {};

        this.deps = [];

        this.dirty = true;

        // TODO: is there a less hackish way to do this?
        this.shuffle = undefined;
      }

      if ( Model ) Computation.__proto__ = Model;
      var Computation__proto__ = Computation.prototype = Object.create( Model && Model.prototype );
      Computation__proto__.constructor = Computation;

      var prototypeAccessors$2 = { setRoot: {} };

      prototypeAccessors$2.setRoot.get = function () {
        if (this.signature.setter) { return this; }
      };

      Computation__proto__.get = function get (shouldCapture, opts) {
        if (shouldCapture) { capture(this); }

        if (this.dirty) {
          var old = this.value;
          this.value = this.getValue();
          // this may cause a view somewhere to update, so it must be in a runloop
          if (!runloop.active()) {
            runloop.start();
            if (!isEqual(old, this.value)) { this.notifyUpstream(); }
            runloop.end();
          } else {
            if (!isEqual(old, this.value)) { this.notifyUpstream(); }
          }
          if (this.wrapper) { this.newWrapperValue = this.value; }
          this.adapt();
          this.dirty = false;
        }

        // if capturing, this value needs to be unwrapped because it's for external use
        return maybeBind(
          this,
          // if unwrap is supplied, it overrides capture
          this.wrapper && (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture)
            ? this.wrapperValue
            : this.value,
          !opts || opts.shouldBind !== false
        );
      };

      Computation__proto__.getContext = function getContext () {
        return this.parent.isRoot ? this.root.ractive : this.parent.get(false, noVirtual);
      };

      Computation__proto__.getValue = function getValue () {
        startCapturing();
        var result;

        try {
          result = this.signature.getter.call(this.root.ractive, this.getContext(), this.getKeypath());
        } catch (err) {
          warnIfDebug(("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)));

          // TODO this is all well and good in Chrome, but...
          // ...also, should encapsulate this stuff better, and only
          // show it if Ractive.DEBUG
          if (hasConsole) {
            if (console.groupCollapsed)
              { console.groupCollapsed(
                '%cshow details',
                'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'
              ); }
            var sig = this.signature;
            console.error(
              ((err.name) + ": " + (err.message) + "\n\n" + (sig.getterString) + (sig.getterUseStack ? '\n\n' + err.stack : ''))
            );
            if (console.groupCollapsed) { console.groupEnd(); }
          }
        }

        var dependencies = stopCapturing();
        if (this.parent.keypath && !~dependencies.indexOf(this.parent)) { dependencies.push(this.parent); }
        this.setDependencies(dependencies);

        return result;
      };

      Computation__proto__.mark = function mark () {
        this.handleChange();
      };

      Computation__proto__.rebind = function rebind (next, previous) {
        // computations will grab all of their deps again automagically
        if (next !== previous) { this.handleChange(); }
      };

      Computation__proto__.set = function set (value) {
        if (this.isReadonly) {
          throw new Error(("Cannot set read-only computed value '" + (this.key) + "'"));
        }

        this.signature.setter(value, this.getContext(), this.getKeypath());
        this.mark();
      };

      Computation__proto__.setDependencies = function setDependencies (dependencies) {
        var this$1 = this;

        // unregister any soft dependencies we no longer have
        var i = this.dependencies.length;
        while (i--) {
          var model = this$1.dependencies[i];
          if (!~dependencies.indexOf(model)) { model.unregister(this$1); }
        }

        // and add any new ones
        i = dependencies.length;
        while (i--) {
          var model$1 = dependencies[i];
          if (!~this$1.dependencies.indexOf(model$1)) { model$1.register(this$1); }
        }

        this.dependencies = dependencies;
      };

      Computation__proto__.teardown = function teardown () {
        var this$1 = this;

        var i = this.dependencies.length;
        while (i--) {
          if (this$1.dependencies[i]) { this$1.dependencies[i].unregister(this$1); }
        }
        if (this.parent.computed[this.key] === this) { delete this.parent.computed[this.key]; }
        Model.prototype.teardown.call(this);
      };

      Object.defineProperties( Computation__proto__, prototypeAccessors$2 );

      return Computation;
    }(Model));

    var prototype = Computation.prototype;
    var child = ComputationChild.prototype;
    prototype.handleChange = child.handleChange;
    prototype.joinKey = child.joinKey;

    shared$1.Computation = Computation;

    var ExpressionProxy = (function (Model) {
      function ExpressionProxy(fragment, template) {
        var this$1 = this;

        Model.call(this, fragment.ractive.viewmodel, null);

        this.fragment = fragment;
        this.template = template;

        this.isReadonly = true;
        this.isComputed = true;
        this.dirty = true;

        this.fn =
          fragment.ractive.allowExpressions === false
            ? noop
            : getFunction(template.s, template.r.length);

        this.models = this.template.r.map(function (ref) {
          return resolveReference(this$1.fragment, ref);
        });
        this.dependencies = [];

        this.shuffle = undefined;

        this.bubble();
      }

      if ( Model ) ExpressionProxy.__proto__ = Model;
      var ExpressionProxy__proto__ = ExpressionProxy.prototype = Object.create( Model && Model.prototype );
      ExpressionProxy__proto__.constructor = ExpressionProxy;

      ExpressionProxy__proto__.bubble = function bubble (actuallyChanged) {
        if ( actuallyChanged === void 0 ) actuallyChanged = true;

        // refresh the keypath
        this.keypath = undefined;

        if (actuallyChanged) {
          this.handleChange();
        }
      };

      ExpressionProxy__proto__.getKeypath = function getKeypath () {
        var this$1 = this;

        if (!this.template) { return '@undefined'; }
        if (!this.keypath) {
          this.keypath =
            '@' +
            this.template.s.replace(/_(\d+)/g, function (match, i) {
              if (i >= this$1.models.length) { return match; }

              var model = this$1.models[i];
              return model ? model.getKeypath() : '@undefined';
            });
        }

        return this.keypath;
      };

      ExpressionProxy__proto__.getValue = function getValue () {
        var this$1 = this;

        startCapturing();
        var result;

        try {
          var params = this.models.map(function (m) { return (m ? m.get(true) : undefined); });
          result = this.fn.apply(this.fragment.ractive, params);
        } catch (err) {
          warnIfDebug(("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)));
        }

        var dependencies = stopCapturing();
        // remove missing deps
        this.dependencies
          .filter(function (d) { return !~dependencies.indexOf(d); })
          .forEach(function (d) {
            d.unregister(this$1);
            removeFromArray(this$1.dependencies, d);
          });
        // register new deps
        dependencies
          .filter(function (d) { return !~this$1.dependencies.indexOf(d); })
          .forEach(function (d) {
            d.register(this$1);
            this$1.dependencies.push(d);
          });

        return result;
      };

      ExpressionProxy__proto__.notifyUpstream = function notifyUpstream () {};

      ExpressionProxy__proto__.rebind = function rebind (next, previous, safe) {
        var idx = this.models.indexOf(previous);

        if (~idx) {
          next = rebindMatch(this.template.r[idx], next, previous);
          if (next !== previous) {
            previous.unregister(this);
            this.models.splice(idx, 1, next);
            if (next) { next.addShuffleRegister(this, 'mark'); }
          }
        }
        this.bubble(!safe);
      };

      ExpressionProxy__proto__.rebound = function rebound (update) {
        var this$1 = this;

        this.models = this.template.r.map(function (ref) { return resolveReference(this$1.fragment, ref); });
        if (update) { this.bubble(true); }
      };

      ExpressionProxy__proto__.retrieve = function retrieve () {
        return this.get();
      };

      ExpressionProxy__proto__.teardown = function teardown () {
        var this$1 = this;

        this.fragment = undefined;
        if (this.dependencies) { this.dependencies.forEach(function (d) { return d.unregister(this$1); }); }
        Model.prototype.teardown.call(this);
      };

      ExpressionProxy__proto__.unreference = function unreference () {
        Model.prototype.unreference.call(this);
        collect(this);
      };

      ExpressionProxy__proto__.unregister = function unregister (dep) {
        Model.prototype.unregister.call(this, dep);
        collect(this);
      };

      ExpressionProxy__proto__.unregisterLink = function unregisterLink (link) {
        Model.prototype.unregisterLink.call(this, link);
        collect(this);
      };

      return ExpressionProxy;
    }(Model));

    var prototype$1 = ExpressionProxy.prototype;
    var computation = Computation.prototype;
    prototype$1.get = computation.get;
    prototype$1.handleChange = computation.handleChange;
    prototype$1.joinKey = computation.joinKey;
    prototype$1.mark = computation.mark;
    prototype$1.unbind = noop;

    function collect(model) {
      if (!model.deps.length && !model.refs && !model.links.length) { model.teardown(); }
    }

    function setupArgsFn(item, template, fragment, opts) {
      if ( opts === void 0 ) opts = {};

      if (template && template.f && template.f.s) {
        if (opts.register) {
          item.model = new ExpressionProxy(fragment, template.f);
          item.model.register(item);
        } else {
          item.fn = getFunction(template.f.s, template.f.r.length);
        }
      }
    }

    function resolveArgs(item, template, fragment, opts) {
      if ( opts === void 0 ) opts = {};

      return template.f.r.map(function (ref, i) {
        var model;

        if (opts.specialRef && (model = opts.specialRef(ref, i))) { return model; }

        model = resolveReference(fragment, ref);

        return model;
      });
    }

    function teardownArgsFn(item) {
      if (item.model) { item.model.unregister(item); }
    }

    var missingDecorator = {
      update: noop,
      teardown: noop
    };

    var Decorator = function Decorator(options) {
      this.owner = options.owner || options.up.owner || findElement(options.up);
      this.element = this.owner.attributeByName ? this.owner : findElement(options.up);
      this.up = options.up || this.owner.up;
      this.ractive = this.up.ractive || this.owner.ractive;
      var template = (this.template = options.template);

      this.name = template.n;

      this.node = null;
      this.handle = null;

      this.element.decorators.push(this);
    };
    var Decorator__proto__ = Decorator.prototype;

    Decorator__proto__.bind = function bind () {
      // if the owner is the elment, make sure the context includes the element
      var frag = this.element === this.owner ? new Fragment({ owner: this.owner }) : this.up;
      setupArgsFn(this, this.template, frag, { register: true });
    };

    Decorator__proto__.bubble = function bubble () {
      if (!this.dirty) {
        this.dirty = true;
        // decorators may be owned directly by an element or by a fragment if conditional
        this.owner.bubble();
        this.up.bubble();
      }
    };

    Decorator__proto__.destroyed = function destroyed () {
      if (this.handle) {
        this.handle.teardown();
        this.handle = null;
      }
      this.shouldDestroy = true;
    };

    Decorator__proto__.handleChange = function handleChange () {
      this.bubble();
    };

    Decorator__proto__.rebound = function rebound (update) {
      if (this.model) { this.model.rebound(update); }
    };

    Decorator__proto__.render = function render () {
        var this$1 = this;

      this.shouldDestroy = false;
      if (this.handle) { this.unrender(); }
      var ractive = this.ractive;
      runloop.scheduleTask(function () {
        // bail if the host element has managed to become unrendered
        if (!this$1.element.rendered) { return; }

        var fn = findInViewHierarchy('decorators', ractive, this$1.name);

        if (!fn) {
          warnOnce(missingPlugin(this$1.name, 'decorator'));
          this$1.handle = missingDecorator;
          return;
        }

        this$1.node = this$1.element.node;

        var args = this$1.model ? this$1.model.get() : [];
        localFragment.f = this$1.up;
        this$1.handle = fn.apply(ractive, [this$1.node].concat(args));
        localFragment.f = null;

        if (!this$1.handle || !this$1.handle.teardown) {
          throw new Error(
            ("The '" + (this$1.name) + "' decorator must return an object with a teardown method")
          );
        }

        // watch out for decorators that cause their host element to be unrendered
        if (this$1.shouldDestroy) { this$1.destroyed(); }
      }, true);
    };

    Decorator__proto__.shuffled = function shuffled () {
      if (this.handle && this.handle.shuffled) { this.handle.shuffled(); }
    };

    Decorator__proto__.toString = function toString () {
      return '';
    };

    Decorator__proto__.unbind = function unbind () {
      teardownArgsFn(this, this.template);
    };

    Decorator__proto__.unrender = function unrender (shouldDestroy) {
      if ((!shouldDestroy || this.element.rendered) && this.handle) {
        this.handle.teardown();
        this.handle = null;
      }
    };

    Decorator__proto__.update = function update () {
      var instance = this.handle;

      if (!this.dirty) {
        if (instance && instance.invalidate) {
          runloop.scheduleTask(function () { return instance.invalidate(); }, true);
        }
        return;
      }

      this.dirty = false;

      if (instance) {
        if (!instance.update) {
          this.unrender();
          this.render();
        } else {
          var args = this.model ? this.model.get() : [];
          instance.update.apply(this.ractive, args);
        }
      }
    };

    Decorator.prototype.firstNode = noop;

    var Doctype = (function (Item) {
      function Doctype () {
        Item.apply(this, arguments);
      }

      if ( Item ) Doctype.__proto__ = Item;
      var Doctype__proto__ = Doctype.prototype = Object.create( Item && Item.prototype );
      Doctype__proto__.constructor = Doctype;

      Doctype__proto__.toString = function toString () {
        return '<!DOCTYPE' + this.template.a + '>';
      };

      return Doctype;
    }(Item));

    var proto$2 = Doctype.prototype;
    proto$2.bind = proto$2.render = proto$2.teardown = proto$2.unbind = proto$2.unrender = proto$2.update = noop;

    var Binding = function Binding(element, name) {
      if ( name === void 0 ) name = 'value';

      this.element = element;
      this.ractive = element.ractive;
      this.attribute = element.attributeByName[name];

      var interpolator = this.attribute.interpolator;
      interpolator.twowayBinding = this;

      var model = interpolator.model;

      if (model.isReadonly && !model.setRoot) {
        var keypath = model.getKeypath().replace(/^@/, '');
        warnOnceIfDebug(
          ("Cannot use two-way binding on <" + (element.name) + "> element: " + keypath + " is read-only. To suppress this warning use <" + (element.name) + " twoway='false'...>"),
          { ractive: this.ractive }
        );
        return false;
      }

      this.attribute.isTwoway = true;
      this.model = model;

      // initialise value, if it's undefined
      var value = model.get();
      this.wasUndefined = isUndefined(value);

      if (isUndefined(value) && this.getInitialValue) {
        value = this.getInitialValue();
        model.set(value);
      }
      this.lastVal(true, value);

      var parentForm = findElement(this.element, false, 'form');
      if (parentForm) {
        this.resetValue = value;
        parentForm.formBindings.push(this);
      }
    };
    var Binding__proto__ = Binding.prototype;

    Binding__proto__.bind = function bind () {
      this.model.registerTwowayBinding(this);
    };

    Binding__proto__.handleChange = function handleChange () {
        var this$1 = this;

      var value = this.getValue();
      if (this.lastVal() === value) { return; }

      runloop.start();
      this.attribute.locked = true;
      this.model.set(value);
      this.lastVal(true, value);

      // if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up
      if (this.model.get() !== value) { this.attribute.locked = false; }
      else { runloop.scheduleTask(function () { return (this$1.attribute.locked = false); }); }

      runloop.end();
    };

    Binding__proto__.lastVal = function lastVal (setting, value) {
      if (setting) { this.lastValue = value; }
      else { return this.lastValue; }
    };

    Binding__proto__.rebind = function rebind (next, previous) {
        var this$1 = this;

      if (this.model && this.model === previous) { previous.unregisterTwowayBinding(this); }
      if (next) {
        this.model = next;
        runloop.scheduleTask(function () { return next.registerTwowayBinding(this$1); });
      }
    };

    Binding__proto__.rebound = function rebound () {
      if (this.model) { this.model.unregisterTwowayBinding(this); }
      this.model = this.attribute.interpolator.model;
      this.model && this.model.registerTwowayBinding(this);
    };

    Binding__proto__.render = function render () {
      this.node = this.element.node;
      this.node._ractive.binding = this;
      this.rendered = true; // TODO is this used anywhere?
    };

    Binding__proto__.setFromNode = function setFromNode (node) {
      this.model.set(node.value);
    };

    Binding__proto__.unbind = function unbind () {
      this.model && this.model.unregisterTwowayBinding(this);
    };

    Binding.prototype.unrender = noop;

    // This is the handler for DOM events that would lead to a change in the model
    // (i.e. change, sometimes, input, and occasionally click and keyup)
    function handleDomEvent() {
      this._ractive.binding.handleChange();
    }

    var CheckboxBinding = (function (Binding) {
      function CheckboxBinding(element) {
        Binding.call(this, element, 'checked');
      }

      if ( Binding ) CheckboxBinding.__proto__ = Binding;
      var CheckboxBinding__proto__ = CheckboxBinding.prototype = Object.create( Binding && Binding.prototype );
      CheckboxBinding__proto__.constructor = CheckboxBinding;

      CheckboxBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        this.element.on('change', handleDomEvent);

        if (this.node.attachEvent) {
          this.element.on('click', handleDomEvent);
        }
      };

      CheckboxBinding__proto__.unrender = function unrender () {
        this.element.off('change', handleDomEvent);

        if (this.node.attachEvent) {
          this.element.off('click', handleDomEvent);
        }
      };

      CheckboxBinding__proto__.getInitialValue = function getInitialValue () {
        return !!this.element.getAttribute('checked');
      };

      CheckboxBinding__proto__.getValue = function getValue () {
        return this.node.checked;
      };

      CheckboxBinding__proto__.setFromNode = function setFromNode (node) {
        this.model.set(node.checked);
      };

      return CheckboxBinding;
    }(Binding));

    function getBindingGroup(group, model, getValue) {
      var hash = group + "-bindingGroup";
      return model[hash] || (model[hash] = new BindingGroup(hash, model, getValue));
    }

    var BindingGroup = function BindingGroup(hash, model, getValue) {
      var this$1 = this;

      this.model = model;
      this.hash = hash;
      this.getValue = function () {
        this$1.value = getValue.call(this$1);
        return this$1.value;
      };

      this.bindings = [];
    };
    var BindingGroup__proto__ = BindingGroup.prototype;

    BindingGroup__proto__.add = function add (binding) {
      this.bindings.push(binding);
    };

    BindingGroup__proto__.bind = function bind () {
        var this$1 = this;

      this.value = this.model.get();
      this.bindings.forEach(function (b) { return b.lastVal(true, this$1.value); });
      this.model.registerTwowayBinding(this);
      this.bound = true;
    };

    BindingGroup__proto__.remove = function remove (binding) {
      removeFromArray(this.bindings, binding);
      if (!this.bindings.length) {
        this.unbind();
      }
    };

    BindingGroup__proto__.unbind = function unbind () {
      this.model.unregisterTwowayBinding(this);
      this.bound = false;
      delete this.model[this.hash];
    };

    BindingGroup.prototype.rebind = Binding.prototype.rebind;

    var push$1 = [].push;

    function getValue() {
      var this$1 = this;

      var all = this.bindings
        .filter(function (b) { return b.node && b.node.checked; })
        .map(function (b) { return b.element.getAttribute('value'); });
      var res = [];
      all.forEach(function (v) {
        if (!this$1.bindings[0].arrayContains(res, v)) { res.push(v); }
      });
      return res;
    }

    var CheckboxNameBinding = (function (Binding) {
      function CheckboxNameBinding(element) {
        Binding.call(this, element, 'name');

        this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

        // Each input has a reference to an array containing it and its
        // group, as two-way binding depends on being able to ascertain
        // the status of all inputs within the group
        this.group = getBindingGroup('checkboxes', this.model, getValue);
        this.group.add(this);

        if (this.noInitialValue) {
          this.group.noInitialValue = true;
        }

        // If no initial value was set, and this input is checked, we
        // update the model
        if (this.group.noInitialValue && this.element.getAttribute('checked')) {
          var existingValue = this.model.get();
          var bindingValue = this.element.getAttribute('value');

          if (!this.arrayContains(existingValue, bindingValue)) {
            push$1.call(existingValue, bindingValue); // to avoid triggering runloop with array adaptor
          }
        }
      }

      if ( Binding ) CheckboxNameBinding.__proto__ = Binding;
      var CheckboxNameBinding__proto__ = CheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );
      CheckboxNameBinding__proto__.constructor = CheckboxNameBinding;

      CheckboxNameBinding__proto__.bind = function bind () {
        if (!this.group.bound) {
          this.group.bind();
        }
      };

      CheckboxNameBinding__proto__.getInitialValue = function getInitialValue () {
        // This only gets called once per group (of inputs that
        // share a name), because it only gets called if there
        // isn't an initial value. By the same token, we can make
        // a note of that fact that there was no initial value,
        // and populate it using any `checked` attributes that
        // exist (which users should avoid, but which we should
        // support anyway to avoid breaking expectations)
        this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?
        return [];
      };

      CheckboxNameBinding__proto__.getValue = function getValue () {
        return this.group.value;
      };

      CheckboxNameBinding__proto__.handleChange = function handleChange () {
        this.isChecked = this.element.node.checked;
        var mval = this.model.get();
        this.group.value = mval === undefined ? [] : mval.slice();
        var value = this.element.getAttribute('value');
        if (this.isChecked && !this.arrayContains(this.group.value, value)) {
          this.group.value.push(value);
        } else if (!this.isChecked && this.arrayContains(this.group.value, value)) {
          this.removeFromArray(this.group.value, value);
        }
        // make sure super knows there's a change
        this.lastValue = null;
        Binding.prototype.handleChange.call(this);
      };

      CheckboxNameBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        var node = this.node;

        var existingValue = this.model.get();
        var bindingValue = this.element.getAttribute('value');

        if (isArray(existingValue)) {
          this.isChecked = this.arrayContains(existingValue, bindingValue);
        } else {
          this.isChecked = this.element.compare(existingValue, bindingValue);
        }
        node.name = '{{' + this.model.getKeypath() + '}}';
        node.checked = this.isChecked;

        this.element.on('change', handleDomEvent);

        // in case of IE emergency, bind to click event as well
        if (this.node.attachEvent) {
          this.element.on('click', handleDomEvent);
        }
      };

      CheckboxNameBinding__proto__.setFromNode = function setFromNode (node) {
        this.group.bindings.forEach(function (binding) { return (binding.wasUndefined = true); });

        if (node.checked) {
          var valueSoFar = this.group.getValue();
          valueSoFar.push(this.element.getAttribute('value'));

          this.group.model.set(valueSoFar);
        }
      };

      CheckboxNameBinding__proto__.unbind = function unbind () {
        this.group.remove(this);
      };

      CheckboxNameBinding__proto__.unrender = function unrender () {
        var el = this.element;

        el.off('change', handleDomEvent);

        if (this.node.attachEvent) {
          el.off('click', handleDomEvent);
        }
      };

      CheckboxNameBinding__proto__.arrayContains = function arrayContains (selectValue, optionValue) {
        var this$1 = this;

        var i = selectValue.length;
        while (i--) {
          if (this$1.element.compare(optionValue, selectValue[i])) { return true; }
        }
        return false;
      };

      CheckboxNameBinding__proto__.removeFromArray = function removeFromArray (array, item) {
        var this$1 = this;

        if (!array) { return; }
        var i = array.length;
        while (i--) {
          if (this$1.element.compare(item, array[i])) {
            array.splice(i, 1);
          }
        }
      };

      return CheckboxNameBinding;
    }(Binding));

    var ContentEditableBinding = (function (Binding) {
      function ContentEditableBinding () {
        Binding.apply(this, arguments);
      }

      if ( Binding ) ContentEditableBinding.__proto__ = Binding;
      var ContentEditableBinding__proto__ = ContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );
      ContentEditableBinding__proto__.constructor = ContentEditableBinding;

      ContentEditableBinding__proto__.getInitialValue = function getInitialValue () {
        return this.element.fragment ? this.element.fragment.toString() : '';
      };

      ContentEditableBinding__proto__.getValue = function getValue () {
        return this.element.node.innerHTML;
      };

      ContentEditableBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        var el = this.element;

        el.on('change', handleDomEvent);
        el.on('blur', handleDomEvent);

        if (!this.ractive.lazy) {
          el.on('input', handleDomEvent);

          if (this.node.attachEvent) {
            el.on('keyup', handleDomEvent);
          }
        }
      };

      ContentEditableBinding__proto__.setFromNode = function setFromNode (node) {
        this.model.set(node.innerHTML);
      };

      ContentEditableBinding__proto__.unrender = function unrender () {
        var el = this.element;

        el.off('blur', handleDomEvent);
        el.off('change', handleDomEvent);
        el.off('input', handleDomEvent);
        el.off('keyup', handleDomEvent);
      };

      return ContentEditableBinding;
    }(Binding));

    function handleBlur() {
      handleDomEvent.call(this);

      var value = this._ractive.binding.model.get();
      this.value = value == undefined ? '' : value;
    }

    function handleDelay(delay) {
      var timeout;

      return function() {
        var this$1 = this;

        if (timeout) { clearTimeout(timeout); }

        timeout = setTimeout(function () {
          var binding = this$1._ractive.binding;
          if (binding.rendered) { handleDomEvent.call(this$1); }
          timeout = null;
        }, delay);
      };
    }

    var GenericBinding = (function (Binding) {
      function GenericBinding () {
        Binding.apply(this, arguments);
      }

      if ( Binding ) GenericBinding.__proto__ = Binding;
      var GenericBinding__proto__ = GenericBinding.prototype = Object.create( Binding && Binding.prototype );
      GenericBinding__proto__.constructor = GenericBinding;

      GenericBinding__proto__.getInitialValue = function getInitialValue () {
        return '';
      };

      GenericBinding__proto__.getValue = function getValue () {
        return this.node.value;
      };

      GenericBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        // any lazy setting for this element overrides the root
        // if the value is a number, it's a timeout
        var lazy = this.ractive.lazy;
        var timeout = false;
        var el = this.element;

        if ('lazy' in this.element) {
          lazy = this.element.lazy;
        }

        if (isNumeric(lazy)) {
          timeout = +lazy;
          lazy = false;
        }

        this.handler = timeout ? handleDelay(timeout) : handleDomEvent;

        var node = this.node;

        el.on('change', handleDomEvent);

        if (node.type !== 'file') {
          if (!lazy) {
            el.on('input', this.handler);

            // IE is a special snowflake
            if (node.attachEvent) {
              el.on('keyup', this.handler);
            }
          }

          el.on('blur', handleBlur);
        }
      };

      GenericBinding__proto__.unrender = function unrender () {
        var el = this.element;
        this.rendered = false;

        el.off('change', handleDomEvent);
        el.off('input', this.handler);
        el.off('keyup', this.handler);
        el.off('blur', handleBlur);
      };

      return GenericBinding;
    }(Binding));

    var FileBinding = (function (GenericBinding) {
      function FileBinding () {
        GenericBinding.apply(this, arguments);
      }

      if ( GenericBinding ) FileBinding.__proto__ = GenericBinding;
      var FileBinding__proto__ = FileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );
      FileBinding__proto__.constructor = FileBinding;

      FileBinding__proto__.getInitialValue = function getInitialValue () {
        /* istanbul ignore next */
        return undefined;
      };

      FileBinding__proto__.getValue = function getValue () {
        /* istanbul ignore next */
        return this.node.files;
      };

      FileBinding__proto__.render = function render () {
        /* istanbul ignore next */
        this.element.lazy = false;
        /* istanbul ignore next */
        GenericBinding.prototype.render.call(this);
      };

      FileBinding__proto__.setFromNode = function setFromNode (node) {
        /* istanbul ignore next */
        this.model.set(node.files);
      };

      return FileBinding;
    }(GenericBinding));

    function getSelectedOptions(select) {
      /* istanbul ignore next */
      return select.selectedOptions
        ? toArray(select.selectedOptions)
        : select.options
        ? toArray(select.options).filter(function (option) { return option.selected; })
        : [];
    }

    var MultipleSelectBinding = (function (Binding) {
      function MultipleSelectBinding () {
        Binding.apply(this, arguments);
      }

      if ( Binding ) MultipleSelectBinding.__proto__ = Binding;
      var MultipleSelectBinding__proto__ = MultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );
      MultipleSelectBinding__proto__.constructor = MultipleSelectBinding;

      MultipleSelectBinding__proto__.getInitialValue = function getInitialValue () {
        return this.element.options
          .filter(function (option) { return option.getAttribute('selected'); })
          .map(function (option) { return option.getAttribute('value'); });
      };

      MultipleSelectBinding__proto__.getValue = function getValue () {
        var options = this.element.node.options;
        var len = options.length;

        var selectedValues = [];

        for (var i = 0; i < len; i += 1) {
          var option = options[i];

          if (option.selected) {
            var optionValue = option._ractive ? option._ractive.value : option.value;
            selectedValues.push(optionValue);
          }
        }

        return selectedValues;
      };

      MultipleSelectBinding__proto__.handleChange = function handleChange () {
        var attribute = this.attribute;
        var previousValue = attribute.getValue();

        var value = this.getValue();

        if (isUndefined(previousValue) || !arrayContentsMatch(value, previousValue)) {
          Binding.prototype.handleChange.call(this);
        }

        return this;
      };

      MultipleSelectBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        this.element.on('change', handleDomEvent);

        if (isUndefined(this.model.get())) {
          // get value from DOM, if possible
          this.handleChange();
        }
      };

      MultipleSelectBinding__proto__.setFromNode = function setFromNode (node) {
        var selectedOptions = getSelectedOptions(node);
        var i = selectedOptions.length;
        var result = new Array(i);

        while (i--) {
          var option = selectedOptions[i];
          result[i] = option._ractive ? option._ractive.value : option.value;
        }

        this.model.set(result);
      };

      MultipleSelectBinding__proto__.unrender = function unrender () {
        this.element.off('change', handleDomEvent);
      };

      return MultipleSelectBinding;
    }(Binding));

    var NumericBinding = (function (GenericBinding) {
      function NumericBinding () {
        GenericBinding.apply(this, arguments);
      }

      if ( GenericBinding ) NumericBinding.__proto__ = GenericBinding;
      var NumericBinding__proto__ = NumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );
      NumericBinding__proto__.constructor = NumericBinding;

      NumericBinding__proto__.getInitialValue = function getInitialValue () {
        return undefined;
      };

      NumericBinding__proto__.getValue = function getValue () {
        var value = parseFloat(this.node.value);
        return isNaN(value) ? undefined : value;
      };

      NumericBinding__proto__.setFromNode = function setFromNode (node) {
        var value = parseFloat(node.value);
        if (!isNaN(value)) { this.model.set(value); }
      };

      return NumericBinding;
    }(GenericBinding));

    var siblings = {};

    function getSiblings(hash) {
      return siblings[hash] || (siblings[hash] = []);
    }

    var RadioBinding = (function (Binding) {
      function RadioBinding(element) {
        Binding.call(this, element, 'checked');

        this.siblings = getSiblings(this.ractive._guid + this.element.getAttribute('name'));
        this.siblings.push(this);
      }

      if ( Binding ) RadioBinding.__proto__ = Binding;
      var RadioBinding__proto__ = RadioBinding.prototype = Object.create( Binding && Binding.prototype );
      RadioBinding__proto__.constructor = RadioBinding;

      RadioBinding__proto__.getValue = function getValue () {
        return this.node.checked;
      };

      RadioBinding__proto__.handleChange = function handleChange () {
        runloop.start();

        this.siblings.forEach(function (binding) {
          binding.model.set(binding.getValue());
        });

        runloop.end();
      };

      RadioBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        this.element.on('change', handleDomEvent);

        if (this.node.attachEvent) {
          this.element.on('click', handleDomEvent);
        }
      };

      RadioBinding__proto__.setFromNode = function setFromNode (node) {
        this.model.set(node.checked);
      };

      RadioBinding__proto__.unbind = function unbind () {
        removeFromArray(this.siblings, this);
      };

      RadioBinding__proto__.unrender = function unrender () {
        this.element.off('change', handleDomEvent);

        if (this.node.attachEvent) {
          this.element.off('click', handleDomEvent);
        }
      };

      return RadioBinding;
    }(Binding));

    function getValue$1() {
      var checked = this.bindings.filter(function (b) { return b.node.checked; });
      if (checked.length > 0) {
        return checked[0].element.getAttribute('value');
      }
    }

    var RadioNameBinding = (function (Binding) {
      function RadioNameBinding(element) {
        var this$1 = this;

        Binding.call(this, element, 'name');

        this.group = getBindingGroup('radioname', this.model, getValue$1);
        this.group.add(this);

        if (element.checked) {
          this.group.value = this.getValue();
        }

        this.attribute.interpolator.pathChanged = function () { return this$1.updateName(); };
      }

      if ( Binding ) RadioNameBinding.__proto__ = Binding;
      var RadioNameBinding__proto__ = RadioNameBinding.prototype = Object.create( Binding && Binding.prototype );
      RadioNameBinding__proto__.constructor = RadioNameBinding;

      RadioNameBinding__proto__.bind = function bind () {
        if (!this.group.bound) {
          this.group.bind();
        }
      };

      RadioNameBinding__proto__.getInitialValue = function getInitialValue () {
        if (this.element.getAttribute('checked')) {
          return this.element.getAttribute('value');
        }
      };

      RadioNameBinding__proto__.getValue = function getValue () {
        return this.element.getAttribute('value');
      };

      RadioNameBinding__proto__.handleChange = function handleChange () {
        // If this <input> is the one that's checked, then the value of its
        // `name` model gets set to its value
        if (this.node.checked) {
          this.group.value = this.getValue();
          Binding.prototype.handleChange.call(this);
        }

        this.updateName();
      };

      RadioNameBinding__proto__.lastVal = function lastVal (setting, value) {
        if (!this.group) { return; }
        if (setting) { this.group.lastValue = value; }
        else { return this.group.lastValue; }
      };

      RadioNameBinding__proto__.rebind = function rebind (next, previous) {
        Binding.prototype.rebind.call(this, next, previous);
        this.updateName();
      };

      RadioNameBinding__proto__.rebound = function rebound (update) {
        Binding.prototype.rebound.call(this, update);
        this.updateName();
      };

      RadioNameBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);

        var node = this.node;

        this.updateName();
        node.checked = this.element.compare(this.model.get(), this.element.getAttribute('value'));

        this.element.on('change', handleDomEvent);

        if (node.attachEvent) {
          this.element.on('click', handleDomEvent);
        }
      };

      RadioNameBinding__proto__.setFromNode = function setFromNode (node) {
        if (node.checked) {
          this.group.model.set(this.element.getAttribute('value'));
        }
      };

      RadioNameBinding__proto__.unbind = function unbind () {
        this.group.remove(this);
      };

      RadioNameBinding__proto__.unrender = function unrender () {
        var el = this.element;

        el.off('change', handleDomEvent);

        if (this.node.attachEvent) {
          el.off('click', handleDomEvent);
        }
      };

      RadioNameBinding__proto__.updateName = function updateName () {
        if (this.node) { this.node.name = "{{" + (this.model.getKeypath()) + "}}"; }
      };

      return RadioNameBinding;
    }(Binding));

    var SingleSelectBinding = (function (Binding) {
      function SingleSelectBinding () {
        Binding.apply(this, arguments);
      }

      if ( Binding ) SingleSelectBinding.__proto__ = Binding;
      var SingleSelectBinding__proto__ = SingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );
      SingleSelectBinding__proto__.constructor = SingleSelectBinding;

      SingleSelectBinding__proto__.forceUpdate = function forceUpdate () {
        var this$1 = this;

        var value = this.getValue();

        if (value !== undefined) {
          this.attribute.locked = true;
          runloop.scheduleTask(function () { return (this$1.attribute.locked = false); });
          this.model.set(value);
        }
      };

      SingleSelectBinding__proto__.getInitialValue = function getInitialValue () {
        if (this.element.getAttribute('value') !== undefined) {
          return;
        }

        var options = this.element.options;
        var len = options.length;

        if (!len) { return; }

        var value;
        var optionWasSelected;
        var i = len;

        // take the final selected option...
        while (i--) {
          var option = options[i];

          if (option.getAttribute('selected')) {
            if (!option.getAttribute('disabled')) {
              value = option.getAttribute('value');
            }

            optionWasSelected = true;
            break;
          }
        }

        // or the first non-disabled option, if none are selected
        if (!optionWasSelected) {
          while (++i < len) {
            if (!options[i].getAttribute('disabled')) {
              value = options[i].getAttribute('value');
              break;
            }
          }
        }

        // This is an optimisation (aka hack) that allows us to forgo some
        // other more expensive work
        // TODO does it still work? seems at odds with new architecture
        if (value !== undefined) {
          this.element.attributeByName.value.value = value;
        }

        return value;
      };

      SingleSelectBinding__proto__.getValue = function getValue () {
        var options = this.node.options;
        var len = options.length;

        var i;
        for (i = 0; i < len; i += 1) {
          var option = options[i];

          if (options[i].selected && !options[i].disabled) {
            return option._ractive ? option._ractive.value : option.value;
          }
        }
      };

      SingleSelectBinding__proto__.render = function render () {
        Binding.prototype.render.call(this);
        this.element.on('change', handleDomEvent);
      };

      SingleSelectBinding__proto__.setFromNode = function setFromNode (node) {
        var option = getSelectedOptions(node)[0];
        this.model.set(option._ractive ? option._ractive.value : option.value);
      };

      SingleSelectBinding__proto__.unrender = function unrender () {
        this.element.off('change', handleDomEvent);
      };

      return SingleSelectBinding;
    }(Binding));

    function isBindable(attribute) {
      // The fragment must be a single non-string fragment
      if (
        !attribute ||
        !attribute.template.f ||
        attribute.template.f.length !== 1 ||
        attribute.template.f[0].s
      )
        { return false; }

      // A binding is an interpolator `{{ }}`, yey.
      if (attribute.template.f[0].t === INTERPOLATOR) { return true; }

      // The above is probably the only true case. For the rest, show an appropriate
      // warning before returning false.

      // You can't bind a triple curly. HTML values on an attribute makes no sense.
      if (attribute.template.f[0].t === TRIPLE)
        { warnIfDebug('It is not possible create a binding using a triple mustache.'); }

      return false;
    }

    function selectBinding(element) {
      var name = element.name;
      var attributes = element.attributeByName;
      if (name !== 'input' && name !== 'textarea' && name !== 'select' && !attributes.contenteditable)
        { return; }
      var isBindableByValue = isBindable(attributes.value);
      var isBindableByContentEditable = isBindable(attributes.contenteditable);
      var isContentEditable = element.getAttribute('contenteditable');

      // contenteditable
      // Bind if the contenteditable is true or a binding that may become true.
      if ((isContentEditable || isBindableByContentEditable) && isBindableByValue)
        { return ContentEditableBinding; }

      // <input>
      if (name === 'input') {
        var type = element.getAttribute('type');

        if (type === 'radio') {
          var isBindableByName = isBindable(attributes.name);
          var isBindableByChecked = isBindable(attributes.checked);

          // For radios we can either bind the name or checked, but not both.
          // Name binding is handed instead.
          if (isBindableByName && isBindableByChecked) {
            warnIfDebug(
              'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
              { ractive: element.root }
            );
            return RadioNameBinding;
          }

          if (isBindableByName) { return RadioNameBinding; }

          if (isBindableByChecked) { return RadioBinding; }

          // Dead end. Unknown binding on radio input.
          return null;
        }

        if (type === 'checkbox') {
          var isBindableByName$1 = isBindable(attributes.name);
          var isBindableByChecked$1 = isBindable(attributes.checked);

          // A checkbox with bindings for both name and checked. Checked treated as
          // the checkbox value, name is treated as a regular binding.
          //
          // See https://github.com/ractivejs/ractive/issues/1749
          if (isBindableByName$1 && isBindableByChecked$1) { return CheckboxBinding; }

          if (isBindableByName$1) { return CheckboxNameBinding; }

          if (isBindableByChecked$1) { return CheckboxBinding; }

          // Dead end. Unknown binding on checkbox input.
          return null;
        }

        if (type === 'file' && isBindableByValue) { return FileBinding; }

        if (type === 'number' && isBindableByValue) { return NumericBinding; }

        if (type === 'range' && isBindableByValue) { return NumericBinding; }

        // Some input of unknown type (browser usually falls back to text).
        if (isBindableByValue) { return GenericBinding; }

        // Dead end. Some unknown input and an unbindable.
        return null;
      }

      // <select>
      if (name === 'select' && isBindableByValue) {
        return element.getAttribute('multiple') ? MultipleSelectBinding : SingleSelectBinding;
      }

      // <textarea>
      if (name === 'textarea' && isBindableByValue) { return GenericBinding; }

      // Dead end. Some unbindable element.
      return null;
    }

    var endsWithSemi = /;\s*$/;

    var Element = (function (ContainerItem) {
      function Element(options) {
        var this$1 = this;

        ContainerItem.call(this, options);

        this.name = options.template.e.toLowerCase();

        // find parent element
        this.parent = findElement(this.up, false);

        if (this.parent && this.parent.name === 'option') {
          throw new Error(
            ("An <option> element cannot contain other elements (encountered <" + (this.name) + ">)")
          );
        }

        this.decorators = [];

        // create attributes
        this.attributeByName = {};

        var attrs;
        var n, attr, val, cls, name, template, leftovers;

        var m = this.template.m;
        var len = (m && m.length) || 0;

        for (var i = 0; i < len; i++) {
          template = m[i];
          if (template.g) {
            (this$1.statics || (this$1.statics = {}))[template.n] = isString(template.f)
              ? template.f
              : template.n;
          } else {
            switch (template.t) {
              case ATTRIBUTE:
              case BINDING_FLAG:
              case DECORATOR:
              case EVENT:
              case TRANSITION:
                attr = createItem({
                  owner: this$1,
                  up: this$1.up,
                  template: template
                });

                n = template.n;

                attrs = attrs || (attrs = this$1.attributes = []);

                if (n === 'value') { val = attr; }
                else if (n === 'name') { name = attr; }
                else if (n === 'class') { cls = attr; }
                else { attrs.push(attr); }

                break;

              case DELEGATE_FLAG:
                this$1.delegate = false;
                break;

              default:
                (leftovers || (leftovers = [])).push(template);
                break;
            }
          }
        }

        if (val) { attrs.push(val); }
        if (name) { attrs.push(name); }
        if (cls) { attrs.unshift(cls); }

        if (leftovers) {
          (attrs || (this.attributes = [])).push(
            new ConditionalAttribute({
              owner: this,
              up: this.up,
              template: leftovers
            })
          );

          // empty leftovers array
          leftovers = [];
        }

        // create children
        if (options.template.f && !options.deferContent) {
          this.fragment = new Fragment({
            template: options.template.f,
            owner: this,
            cssIds: null
          });
        }

        this.binding = null; // filled in later
      }

      if ( ContainerItem ) Element.__proto__ = ContainerItem;
      var Element__proto__ = Element.prototype = Object.create( ContainerItem && ContainerItem.prototype );
      Element__proto__.constructor = Element;

      Element__proto__.bind = function bind () {
        var attrs = this.attributes;
        if (attrs) {
          attrs.binding = true;
          var len = attrs.length;
          for (var i = 0; i < len; i++) { attrs[i].bind(); }
          attrs.binding = false;
        }

        if (this.fragment) { this.fragment.bind(); }

        // create two-way binding if necessary
        if (!this.binding) { this.recreateTwowayBinding(); }
        else { this.binding.bind(); }
      };

      Element__proto__.createTwowayBinding = function createTwowayBinding () {
        if ('twoway' in this ? this.twoway : this.ractive.twoway) {
          var Binding = selectBinding(this);
          if (Binding) {
            var binding = new Binding(this);
            if (binding && binding.model) { return binding; }
          }
        }
      };

      Element__proto__.destroyed = function destroyed$1 () {
        if (this.attributes) { this.attributes.forEach(destroyed); }
        if (this.fragment) { this.fragment.destroyed(); }
      };

      Element__proto__.detach = function detach () {
        // if this element is no longer rendered, the transitions are complete and the attributes can be torn down
        if (!this.rendered) { this.destroyed(); }

        return detachNode(this.node);
      };

      Element__proto__.find = function find (selector, options) {
        if (this.node && matches(this.node, selector)) { return this.node; }
        if (this.fragment) {
          return this.fragment.find(selector, options);
        }
      };

      Element__proto__.findAll = function findAll (selector, options) {
        var result = options.result;

        if (matches(this.node, selector)) {
          result.push(this.node);
        }

        if (this.fragment) {
          this.fragment.findAll(selector, options);
        }
      };

      Element__proto__.findNextNode = function findNextNode () {
        return null;
      };

      Element__proto__.firstNode = function firstNode () {
        return this.node;
      };

      Element__proto__.getAttribute = function getAttribute (name) {
        if (this.statics && name in this.statics) { return this.statics[name]; }
        var attribute = this.attributeByName[name];
        return attribute ? attribute.getValue() : undefined;
      };

      Element__proto__.getContext = function getContext () {
        var assigns = [], len = arguments.length;
        while ( len-- ) assigns[ len ] = arguments[ len ];

        if (this.fragment) { return (ref = this.fragment).getContext.apply(ref, assigns); }

        if (!this.ctx) { this.ctx = new Context(this.up, this); }
        assigns.unshift(create(this.ctx));
        return assign.apply(null, assigns);
        var ref;
      };

      Element__proto__.off = function off (event, callback, capture) {
        if ( capture === void 0 ) capture = false;

        var delegate = this.up.delegate;
        var ref = this.listeners && this.listeners[event];

        if (!ref) { return; }
        removeFromArray(ref, callback);

        if (delegate) {
          var listeners =
            (delegate.listeners || (delegate.listeners = [])) &&
            (delegate.listeners[event] || (delegate.listeners[event] = []));
          if (listeners.refs && !--listeners.refs) { delegate.off(event, delegateHandler, true); }
        } else if (this.rendered) {
          var n = this.node;
          var add = n.addEventListener;
          var rem = n.removeEventListener;

          if (!ref.length) {
            rem.call(n, event, handler, capture);
          } else if (ref.length && !ref.refs && capture) {
            rem.call(n, event, handler, true);
            add.call(n, event, handler, false);
          }
        }
      };

      Element__proto__.on = function on (event, callback, capture) {
        if ( capture === void 0 ) capture = false;

        var delegate = this.up.delegate;
        var ref = (this.listeners || (this.listeners = {}))[event] || (this.listeners[event] = []);

        if (delegate) {
          var listeners =
            ((delegate.listeners || (delegate.listeners = [])) && delegate.listeners[event]) ||
            (delegate.listeners[event] = []);
          if (!listeners.refs) {
            listeners.refs = 0;
            delegate.on(event, delegateHandler, true);
            listeners.refs++;
          } else {
            listeners.refs++;
          }
        } else if (this.rendered) {
          var n = this.node;
          var add = n.addEventListener;
          var rem = n.removeEventListener;

          if (!ref.length) {
            add.call(n, event, handler, capture);
          } else if (ref.length && !ref.refs && capture) {
            rem.call(n, event, handler, false);
            add.call(n, event, handler, true);
          }
        }

        addToArray(this.listeners[event], callback);
      };

      Element__proto__.recreateTwowayBinding = function recreateTwowayBinding () {
        if (this.binding) {
          this.binding.unbind();
          this.binding.unrender();
        }

        if ((this.binding = this.createTwowayBinding())) {
          this.binding.bind();
          if (this.rendered) { this.binding.render(); }
        }
      };

      Element__proto__.rebound = function rebound (update$$1) {
        ContainerItem.prototype.rebound.call(this, update$$1);
        if (this.attributes) { this.attributes.forEach(function (x) { return x.rebound(update$$1); }); }
        if (this.binding) { this.binding.rebound(update$$1); }
      };

      Element__proto__.render = function render (target, occupants) {
        var this$1 = this;

        // TODO determine correct namespace
        this.namespace = getNamespace(this);

        var node;
        var existing = false;

        if (occupants) {
          var n;
          while ((n = occupants.shift())) {
            if (
              n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() &&
              n.namespaceURI === this$1.namespace
            ) {
              this$1.node = node = n;
              existing = true;
              break;
            } else {
              detachNode(n);
            }
          }
        }

        if (!existing && this.node) {
          node = this.node;
          target.appendChild(node);
          existing = true;
        }

        if (!node) {
          var name = this.template.e;
          node = createElement(
            this.namespace === html ? name.toLowerCase() : name,
            this.namespace,
            this.getAttribute('is')
          );
          this.node = node;
        }

        // tie the node to this vdom element
        defineProperty(node, '_ractive', {
          value: {
            proxy: this
          },
          configurable: true
        });

        if (this.statics) {
          keys(this.statics).forEach(function (k) {
            node.setAttribute(k, this$1.statics[k]);
          });
        }

        if (existing && this.foundNode) { this.foundNode(node); }

        // register intro before rendering content so children can find the intro
        var intro = this.intro;
        if (intro && intro.shouldFire('intro')) {
          intro.isIntro = true;
          intro.isOutro = false;
          runloop.registerTransition(intro);
        }

        if (this.fragment) {
          var children = existing ? toArray(node.childNodes) : undefined;

          this.fragment.render(node, children);

          // clean up leftover children
          if (children) {
            children.forEach(detachNode);
          }
        }

        if (existing) {
          // store initial values for two-way binding
          if (this.binding && this.binding.wasUndefined) { this.binding.setFromNode(node); }
          // remove unused attributes
          var i = node.attributes.length;
          while (i--) {
            var name$1 = node.attributes[i].name;
            if (!(name$1 in this$1.attributeByName) && (!this$1.statics || !(name$1 in this$1.statics)))
              { node.removeAttribute(name$1); }
          }
        }

        // Is this a top-level node of a component? If so, we may need to add
        // a data-ractive-css attribute, for CSS encapsulation
        if (this.up.cssIds) {
          node.setAttribute('data-ractive-css', this.up.cssIds.map(function (x) { return ("{" + x + "}"); }).join(' '));
        }

        if (this.attributes) {
          var len = this.attributes.length;
          for (var i$1 = 0; i$1 < len; i$1++) { this$1.attributes[i$1].render(); }
        }
        if (this.binding) { this.binding.render(); }

        if (!this.up.delegate && this.listeners) {
          var ls = this.listeners;
          for (var k in ls) {
            if (ls[k] && ls[k].length) { this$1.node.addEventListener(k, handler, !!ls[k].refs); }
          }
        }

        if (!existing) {
          target.appendChild(node);
        }

        this.rendered = true;
      };

      Element__proto__.shuffled = function shuffled$1 () {
        ContainerItem.prototype.shuffled.call(this);
        this.decorators.forEach(shuffled);
      };

      Element__proto__.toString = function toString () {
        var this$1 = this;

        var tagName = this.template.e;

        var attrs = (this.attributes && this.attributes.map(stringifyAttribute).join('')) || '';

        if (this.statics)
          { keys(this.statics).forEach(
            function (k) { return k !== 'class' &&
              k !== 'style' &&
              (attrs = " " + k + "=\"" + (safeAttributeString(this$1.statics[k])) + "\"" + attrs); }
          ); }

        // Special case - selected options
        if (this.name === 'option' && this.isSelected()) {
          attrs += ' selected';
        }

        // Special case - two-way radio name bindings
        if (this.name === 'input' && inputIsCheckedRadio(this)) {
          attrs += ' checked';
        }

        // Special case style and class attributes and directives
        var style = this.statics ? this.statics.style : undefined;
        var cls = this.statics ? this.statics.class : undefined;
        this.attributes &&
          this.attributes.forEach(function (attr) {
            if (attr.name === 'class') {
              cls = (cls || '') + (cls ? ' ' : '') + safeAttributeString(attr.getString());
            } else if (attr.name === 'style') {
              style = (style || '') + (style ? ' ' : '') + safeAttributeString(attr.getString());
              if (style && !endsWithSemi.test(style)) { style += ';'; }
            } else if (attr.style) {
              style =
                (style || '') +
                (style ? ' ' : '') +
                (attr.style) + ": " + (safeAttributeString(attr.getString())) + ";";
            } else if (attr.inlineClass && attr.getValue()) {
              cls = (cls || '') + (cls ? ' ' : '') + attr.inlineClass;
            }
          });
        // put classes first, then inline style
        if (style !== undefined) { attrs = ' style' + (style ? ("=\"" + style + "\"") : '') + attrs; }
        if (cls !== undefined) { attrs = ' class' + (cls ? ("=\"" + cls + "\"") : '') + attrs; }

        if (this.up.cssIds) {
          attrs += " data-ractive-css=\"" + (this.up.cssIds.map(function (x) { return ("{" + x + "}"); }).join(' ')) + "\"";
        }

        var str = "<" + tagName + attrs + ">";

        if (voidElements[this.name.toLowerCase()]) { return str; }

        // Special case - textarea
        if (this.name === 'textarea' && this.getAttribute('value') !== undefined) {
          str += escapeHtml(this.getAttribute('value'));
        } else if (this.getAttribute('contenteditable') !== undefined) {
          // Special case - contenteditable
          str += this.getAttribute('value') || '';
        }

        if (this.fragment) {
          str += this.fragment.toString(!/^(?:script|style)$/i.test(this.template.e)); // escape text unless script/style
        }

        str += "</" + tagName + ">";
        return str;
      };

      Element__proto__.unbind = function unbind (view) {
        var attrs = this.attributes;
        if (attrs) {
          attrs.unbinding = true;
          var len = attrs.length;
          for (var i = 0; i < len; i++) { attrs[i].unbind(view); }
          attrs.unbinding = false;
        }

        if (this.binding) { this.binding.unbind(view); }
        if (this.fragment) { this.fragment.unbind(view); }
      };

      Element__proto__.unrender = function unrender (shouldDestroy) {
        if (!this.rendered) { return; }
        this.rendered = false;

        // unrendering before intro completed? complete it now
        // TODO should be an API for aborting transitions
        var transition = this.intro;
        if (transition && transition.complete) { transition.complete(); }

        // Detach as soon as we can
        if (this.name === 'option') {
          // <option> elements detach immediately, so that
          // their parent <select> element syncs correctly, and
          // since option elements can't have transitions anyway
          this.detach();
        } else if (shouldDestroy) {
          runloop.detachWhenReady(this);
        }

        // outro transition
        var outro = this.outro;
        if (outro && outro.shouldFire('outro')) {
          outro.isIntro = false;
          outro.isOutro = true;
          runloop.registerTransition(outro);
        }

        if (this.fragment) { this.fragment.unrender(); }

        if (this.binding) { this.binding.unrender(); }
      };

      Element__proto__.update = function update () {
        if (this.dirty) {
          this.dirty = false;

          var attrs = this.attributes;
          if (attrs) {
            var len = attrs.length;
            for (var i = 0; i < len; i++) { attrs[i].update(); }
          }

          if (this.fragment) { this.fragment.update(); }
        }
      };

      return Element;
    }(ContainerItem));

    function inputIsCheckedRadio(element) {
      var nameAttr = element.attributeByName.name;
      return (
        element.getAttribute('type') === 'radio' &&
        (nameAttr || {}).interpolator &&
        element.getAttribute('value') === nameAttr.interpolator.model.get()
      );
    }

    function stringifyAttribute(attribute) {
      var str = attribute.toString();
      return str ? ' ' + str : '';
    }

    function getNamespace(element) {
      // Use specified namespace...
      var xmlns$$1 = element.getAttribute('xmlns');
      if (xmlns$$1) { return xmlns$$1; }

      // ...or SVG namespace, if this is an <svg> element
      if (element.name === 'svg') { return svg$1; }

      var parent = element.parent;

      if (parent) {
        // ...or HTML, if the parent is a <foreignObject>
        if (parent.name === 'foreignobject') { return html; }

        // ...or inherit from the parent node
        return parent.node.namespaceURI;
      }

      return element.ractive.el.namespaceURI;
    }

    var stop = false;
    function stopPropagation() {
      stop = true;
    }
    var immediate$1 = false;
    function stopImmediatePropagation() {
      immediate$1 = true;
    }
    var prevent = false;
    function preventDefault() {
      prevent = true;
    }

    function delegateHandler(ev) {
      var name = ev.type;
      var end = ev.currentTarget;
      var endEl = end._ractive && end._ractive.proxy;
      var node = ev.target;
      var bubble = true;
      var listeners;
      var prevented = false;

      stop = immediate$1 = prevent = false;
      var oldStop = ev.stopPropagation;
      var oldImmediate = ev.stopImmediatePropagation;
      var oldPrevent = ev.preventDefault;
      ev.stopPropagation = stopPropagation;
      ev.stopImmediatePropagation = stopImmediatePropagation;
      ev.preventDefault = preventDefault;

      // starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener
      while (bubble && node && node !== end) {
        var proxy = node._ractive && node._ractive.proxy;
        if (proxy && proxy.up.delegate === endEl && shouldFire(ev, node, end)) {
          listeners = proxy.listeners && proxy.listeners[name];

          if (listeners) {
            var len = listeners.length;
            for (var i = 0; i < len; i++) {
              bubble = listeners[i].call(node, ev) !== false && bubble;
              if (immediate$1) {
                bubble = false;
                break;
              }
              if (stop) { bubble = false; }
              if (prevent && !prevented) {
                prevented = true;
                oldPrevent.call(ev);
              }
            }
          }
        }

        node = node.parentNode || node.correspondingUseElement; // SVG with a <use> element in certain environments
      }

      if (bubble) { bubble = !stop && !immediate$1; }

      if (stop) { oldStop.call(ev); }
      if (immediate$1) { oldImmediate.call(ev); }

      ev.stopPropagation = oldStop;
      ev.stopImmediaitePropagation = oldImmediate;
      ev.preventDefault = oldPrevent;

      return bubble;
    }

    var UIEvent = win !== null ? win.UIEvent : null;
    function shouldFire(event, start, end) {
      if (UIEvent && event instanceof UIEvent) {
        var node = start;
        while (node && node !== end) {
          if (node.disabled) { return false; }
          node = node.parentNode || node.correspondingUseElement;
        }
      }

      return true;
    }

    function handler(ev) {
      var this$1 = this;

      var el = this._ractive.proxy;
      var listeners;
      if (el.listeners && (listeners = el.listeners[ev.type])) {
        var len = listeners.length;
        for (var i = 0; i < len; i++) { listeners[i] && listeners[i].call(this$1, ev); }
      }
    }

    var Form = (function (Element) {
      function Form(options) {
        Element.call(this, options);
        this.formBindings = [];
      }

      if ( Element ) Form.__proto__ = Element;
      var Form__proto__ = Form.prototype = Object.create( Element && Element.prototype );
      Form__proto__.constructor = Form;

      Form__proto__.render = function render (target, occupants) {
        Element.prototype.render.call(this, target, occupants);
        this.on('reset', handleReset);
      };

      Form__proto__.unrender = function unrender (shouldDestroy) {
        this.off('reset', handleReset);
        Element.prototype.unrender.call(this, shouldDestroy);
      };

      return Form;
    }(Element));

    function handleReset() {
      var element = this._ractive.proxy;

      runloop.start();
      element.formBindings.forEach(updateModel);
      runloop.end();
    }

    function updateModel(binding) {
      binding.model.set(binding.resetValue);
    }

    var DOMEvent = function DOMEvent(name, owner) {
      if (name.indexOf('*') !== -1) {
        fatal(
          ("Only component proxy-events may contain \"*\" wildcards, <" + (owner.name) + " on-" + name + "=\"...\"/> is not valid")
        );
      }

      this.name = name;
      this.owner = owner;
      this.handler = null;
    };
    var DOMEvent__proto__ = DOMEvent.prototype;

    DOMEvent__proto__.bind = function bind () {};

    DOMEvent__proto__.render = function render (directive) {
        var this$1 = this;

      var name = this.name;

      var register = function () {
        var node = this$1.owner.node;

        this$1.owner.on(
          name,
          (this$1.handler = function (event) {
            return directive.fire({
              node: node,
              original: event,
              event: event,
              name: name
            });
          })
        );
      };

      if (name !== 'load') {
        // schedule events so that they take place after twoway binding
        runloop.scheduleTask(register, true);
      } else {
        // unless its a load event
        register();
      }
    };

    DOMEvent__proto__.unbind = function unbind () {};

    DOMEvent__proto__.unrender = function unrender () {
      if (this.handler) { this.owner.off(this.name, this.handler); }
    };

    var CustomEvent = function CustomEvent(eventPlugin, owner, name, args) {
      this.eventPlugin = eventPlugin;
      this.owner = owner;
      this.name = name;
      this.handler = null;
      this.args = args;
    };
    var CustomEvent__proto__ = CustomEvent.prototype;

    CustomEvent__proto__.bind = function bind () {};

    CustomEvent__proto__.render = function render (directive) {
        var this$1 = this;

      runloop.scheduleTask(function () {
        var node = this$1.owner.node;

        localFragment.f = directive.up;
        this$1.handler = this$1.eventPlugin.apply(
          this$1.owner.ractive,
          [
            node,
            function (event) {
                if ( event === void 0 ) event = {};

              if (event.original) { event.event = event.original; }
              else { event.original = event.event; }

              event.name = this$1.name;
              event.node = event.node || node;
              return directive.fire(event);
            }
          ].concat(this$1.args || [])
        );
        localFragment.f = null;
      });
    };

    CustomEvent__proto__.unbind = function unbind () {};

    CustomEvent__proto__.unrender = function unrender () {
        var this$1 = this;

      if (this.handler) { this.handler.teardown(); }
      else { runloop.scheduleTask(function () { return this$1.handler && this$1.handler.teardown(); }); }
    };

    var RactiveEvent = function RactiveEvent(component, name) {
      this.component = component;
      this.name = name;
      this.handler = null;
    };
    var RactiveEvent__proto__ = RactiveEvent.prototype;

    RactiveEvent__proto__.bind = function bind (directive) {
      var ractive = this.component.instance;

      this.handler = ractive.on(this.name, function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];

        // watch for reproxy
        if (args[0] instanceof Context) {
          var ctx = args.shift();
          ctx.component = ractive;
          directive.fire(ctx, args);
        } else {
          directive.fire({}, args);
        }

        // cancel bubbling
        return false;
      });
    };

    RactiveEvent__proto__.render = function render () {};

    RactiveEvent__proto__.unbind = function unbind () {
      this.handler.cancel();
    };

    RactiveEvent__proto__.unrender = function unrender () {};

    var specialPattern = /^(event|arguments|@node|@event|@context)(\..+)?$/;
    var dollarArgsPattern = /^\$(\d+)(\..+)?$/;

    var EventDirective = function EventDirective(options) {
      this.owner = options.owner || options.up.owner || findElement(options.up);
      this.element = this.owner.attributeByName ? this.owner : findElement(options.up, true);
      this.template = options.template;
      this.up = options.up;
      this.ractive = options.up.ractive;
      this.events = [];
    };
    var EventDirective__proto__ = EventDirective.prototype;

    EventDirective__proto__.bind = function bind () {
        var this$1 = this;

      // sometimes anchors will cause an unbind without unrender
      if (this.events.length) {
        this.events.forEach(function (e) { return e.unrender(); });
        this.events = [];
      }

      if (this.element.type === COMPONENT || this.element.type === ANCHOR) {
        this.template.n.forEach(function (n) {
          this$1.events.push(new RactiveEvent(this$1.element, n));
        });
      } else {
        var args;
        if ((args = this.template.a)) {
          var rs = args.r.map(function (r) {
            var model = resolveReference(this$1.up, r);
            return model ? model.get() : undefined;
          });
          try {
            args = getFunction(args.s, rs.length).apply(null, rs);
          } catch (err) {
            args = null;
            warnIfDebug(
              ("Failed to compute args for event on-" + (this.template.n.join('- ')) + ": " + (err.message ||
                err))
            );
          }
        }

        this.template.n.forEach(function (n) {
          var fn = findInViewHierarchy('events', this$1.ractive, n);
          if (fn) {
            this$1.events.push(new CustomEvent(fn, this$1.element, n, args));
          } else {
            this$1.events.push(new DOMEvent(n, this$1.element));
          }
        });
      }

      // method calls
      this.models = null;

      addToArray(this.element.events || (this.element.events = []), this);

      setupArgsFn(this, this.template);
      if (!this.fn) { this.action = this.template.f; }

      this.events.forEach(function (e) { return e.bind(this$1); });
    };

    EventDirective__proto__.destroyed = function destroyed () {
      this.events.forEach(function (e) { return e.unrender(); });
    };

    EventDirective__proto__.fire = function fire (event, args) {
        var this$1 = this;
        if ( args === void 0 ) args = [];

      var context =
        event instanceof Context && event.refire ? event : this.element.getContext(event);

      if (this.fn) {
        var values = [];

        var models = resolveArgs(this, this.template, this.up, {
          specialRef: function specialRef(ref) {
            var specialMatch = specialPattern.exec(ref);
            if (specialMatch) {
              // on-click="foo(event.node)"
              return {
                special: specialMatch[1],
                keys: specialMatch[2] ? splitKeypath(specialMatch[2].substr(1)) : []
              };
            }

            var dollarMatch = dollarArgsPattern.exec(ref);
            if (dollarMatch) {
              // on-click="foo($1)"
              return {
                special: 'arguments',
                keys: [dollarMatch[1] - 1].concat(
                  dollarMatch[2] ? splitKeypath(dollarMatch[2].substr(1)) : []
                )
              };
            }
          }
        });

        if (models) {
          models.forEach(function (model) {
            if (!model) { return values.push(undefined); }

            if (model.special) {
              var which = model.special;
              var obj;

              if (which === '@node') {
                obj = this$1.element.node;
              } else if (which === '@event') {
                obj = event && event.event;
              } else if (which === 'event') {
                warnOnceIfDebug(
                  "The event reference available to event directives is deprecated and should be replaced with @context and @event"
                );
                obj = context;
              } else if (which === '@context') {
                obj = context;
              } else {
                obj = args;
              }

              var keys = model.keys.slice();

              while (obj && keys.length) { obj = obj[keys.shift()]; }
              return values.push(obj);
            }

            if (model.wrapper) {
              return values.push(model.wrapperValue);
            }

            values.push(model.get());
          });
        }

        // make event available as `this.event`
        var ractive = this.ractive;
        var oldEvent = ractive.event;

        ractive.event = context;
        var returned = this.fn.apply(ractive, values);
        var result = returned.pop();

        // Auto prevent and stop if return is explicitly false
        if (result === false) {
          var original = event ? event.original : undefined;
          if (original) {
            original.preventDefault && original.preventDefault();
            original.stopPropagation && original.stopPropagation();
          } else {
            warnOnceIfDebug(
              ("handler '" + (this.template.n.join(
                ' '
              )) + "' returned false, but there is no event available to cancel")
            );
          }
        } else if (!returned.length && isArray(result) && isString(result[0])) {
          // watch for proxy events
          result = fireEvent(this.ractive, result.shift(), context, result);
        }

        ractive.event = oldEvent;

        return result;
      } else {
        return fireEvent(this.ractive, this.action, context, args);
      }
    };

    EventDirective__proto__.handleChange = function handleChange () {};

    EventDirective__proto__.render = function render () {
        var this$1 = this;

      this.events.forEach(function (e) { return e.render(this$1); });
    };

    EventDirective__proto__.toString = function toString () {
      return '';
    };

    EventDirective__proto__.unbind = function unbind (view) {
      removeFromArray(this.element.events, this);
      this.events.forEach(function (e) { return e.unbind(view); });
    };

    EventDirective__proto__.unrender = function unrender () {
      this.events.forEach(function (e) { return e.unrender(); });
    };

    var proto$3 = EventDirective.prototype;
    proto$3.firstNode = proto$3.rebound = proto$3.update = noop;

    function progressiveText(item, target, occupants, text) {
      if (occupants) {
        var n = occupants[0];
        if (n && n.nodeType === 3) {
          var idx = n.nodeValue.indexOf(text);
          occupants.shift();

          if (idx === 0) {
            if (n.nodeValue.length !== text.length) {
              occupants.unshift(n.splitText(text.length));
            }
          } else {
            n.nodeValue = text;
          }
        } else {
          n = item.node = doc.createTextNode(text);
          if (occupants[0]) {
            target.insertBefore(n, occupants[0]);
          } else {
            target.appendChild(n);
          }
        }

        item.node = n;
      } else {
        if (!item.node) { item.node = doc.createTextNode(text); }
        target.appendChild(item.node);
      }
    }

    var ReferenceExpressionProxy = (function (LinkModel) {
      function ReferenceExpressionProxy(fragment, template) {
        LinkModel.call(this, null, null, null, '@undefined');
        this.root = fragment.ractive.viewmodel;
        this.template = template;
        this.rootLink = true;
        this.template = template;
        this.fragment = fragment;

        this.rebound();
      }

      if ( LinkModel ) ReferenceExpressionProxy.__proto__ = LinkModel;
      var ReferenceExpressionProxy__proto__ = ReferenceExpressionProxy.prototype = Object.create( LinkModel && LinkModel.prototype );
      ReferenceExpressionProxy__proto__.constructor = ReferenceExpressionProxy;

      ReferenceExpressionProxy__proto__.getKeypath = function getKeypath () {
        return this.model ? this.model.getKeypath() : '@undefined';
      };

      ReferenceExpressionProxy__proto__.rebound = function rebound () {
        var this$1 = this;

        var fragment = this.fragment;
        var template = this.template;

        var base = (this.base = resolve(fragment, template));
        var idx;

        if (this.proxy) {
          teardown$2(this);
        }

        var proxy = (this.proxy = {
          rebind: function (next, previous) {
            if (previous === base) {
              next = rebindMatch(template, next, previous);
              if (next !== base) {
                this$1.base = base = next;
              }
            } else if (~(idx = members.indexOf(previous))) {
              next = rebindMatch(template.m[idx].n, next, previous);
              if (next !== members[idx]) {
                members.splice(idx, 1, next || Missing);
              }
            }

            if (next !== previous) {
              previous.unregister(proxy);
              if (next) { next.addShuffleTask(function () { return next.register(proxy); }); }
            }
          },
          handleChange: function () {
            pathChanged();
          }
        });

        base.register(proxy);

        var members = (this.members = template.m.map(function (tpl) {
          if (isString(tpl)) {
            return { get: function () { return tpl; } };
          }

          var model;

          if (tpl.t === REFERENCE) {
            model = resolveReference(fragment, tpl.n);
            model.register(proxy);

            return model;
          }

          model = new ExpressionProxy(fragment, tpl);
          model.register(proxy);
          return model;
        }));

        var pathChanged = function () {
          var model =
            base &&
            base.joinAll(
              members.reduce(function (list, m) {
                var k = m.get();
                if (isArray(k)) { return list.concat(k); }
                else { list.push(escapeKey(String(k))); }
                return list;
              }, [])
            );

          if (model !== this$1.model) {
            this$1.model = model;
            this$1.relinking(model);
            fireShuffleTasks();
            refreshPathDeps(this$1);
            this$1.fragment.shuffled();
          }
        };

        pathChanged();
      };

      ReferenceExpressionProxy__proto__.teardown = function teardown () {
        teardown$2(this);
        LinkModel.prototype.teardown.call(this);
      };

      ReferenceExpressionProxy__proto__.unreference = function unreference () {
        LinkModel.prototype.unreference.call(this);
        if (!this.deps.length && !this.refs) { this.teardown(); }
      };

      ReferenceExpressionProxy__proto__.unregister = function unregister (dep) {
        LinkModel.prototype.unregister.call(this, dep);
        if (!this.deps.length && !this.refs) { this.teardown(); }
      };

      return ReferenceExpressionProxy;
    }(LinkModel));

    function teardown$2(proxy) {
      if (proxy.base) { proxy.base.unregister(proxy.proxy); }
      if (proxy.models) {
        proxy.models.forEach(function (m) {
          if (m.unregister) { m.unregister(proxy); }
        });
      }
    }

    function refreshPathDeps(proxy) {
      var len = proxy.deps.length;
      var i, v;

      for (i = 0; i < len; i++) {
        v = proxy.deps[i];
        if (v.pathChanged) { v.pathChanged(); }
        if (v.fragment && v.fragment.pathModel) { v.fragment.pathModel.applyValue(proxy.getKeypath()); }
      }

      len = proxy.children.length;
      for (i = 0; i < len; i++) {
        refreshPathDeps(proxy.children[i]);
      }
    }

    var eproto = ExpressionProxy.prototype;
    var proto$4 = ReferenceExpressionProxy.prototype;

    proto$4.unreference = eproto.unreference;
    proto$4.unregister = eproto.unregister;
    proto$4.unregisterLink = eproto.unregisterLink;

    function resolve(fragment, template) {
      if (template.r) {
        return resolveReference(fragment, template.r);
      } else if (template.x) {
        return new ExpressionProxy(fragment, template.x);
      } else if (template.rx) {
        return new ReferenceExpressionProxy(fragment, template.rx);
      }
    }

    var Mustache = (function (Item) {
      function Mustache(options) {
        Item.call(this, options);

        if (options.owner) { this.parent = options.owner; }

        this.isStatic = !!options.template.s;

        this.model = null;
        this.dirty = false;
      }

      if ( Item ) Mustache.__proto__ = Item;
      var Mustache__proto__ = Mustache.prototype = Object.create( Item && Item.prototype );
      Mustache__proto__.constructor = Mustache;

      Mustache__proto__.bind = function bind (pre) {
        // yield mustaches and inner contexts should resolve in container context
        var start = this.template.y
          ? this.template.y.containerFragment
          : this.containerFragment || this.up;
        // try to find a model for this view
        var model = pre || resolve(start, this.template);

        if (model) {
          var value = model.get();

          if (this.isStatic) {
            this.model = { get: function () { return value; } };
            model.unreference();
            return;
          }

          model.register(this);
          this.model = model;
        }
      };

      Mustache__proto__.handleChange = function handleChange () {
        this.bubble();
      };

      Mustache__proto__.rebind = function rebind (next, previous, safe) {
        if (this.isStatic) { return; }

        next = rebindMatch(this.template, next, previous, this.up);
        if (next === this.model) { return false; }

        if (this.model) {
          this.model.unregister(this);
        }
        if (next) { next.addShuffleRegister(this, 'mark'); }
        this.model = next;
        if (!safe) { this.handleChange(); }
        return true;
      };

      Mustache__proto__.rebound = function rebound (update) {
        if (this.model) {
          if (this.model.rebound) { this.model.rebound(update); }
          else {
            // check to see if the model actually changed...
            // yield mustaches and inner contexts should resolve in container context
            var start = this.template.y
              ? this.template.y.containerFragment
              : this.containerFragment || this.up;
            // try to find a model for this view
            var model = resolve(start, this.template);
            if (model !== this.model) {
              this.model.unregister(this);
              this.bind(model);
            }
          }

          if (update) { this.bubble(); }
        }
        if (this.fragment) { this.fragment.rebound(update); }
      };

      Mustache__proto__.unbind = function unbind () {
        if (!this.isStatic) {
          this.model && this.model.unregister(this);
          this.model = undefined;
        }
      };

      return Mustache;
    }(Item));

    function MustacheContainer(options) {
      Mustache.call(this, options);
    }

    var proto$5 = (MustacheContainer.prototype = Object.create(ContainerItem.prototype));

    assign(proto$5, Mustache.prototype, { constructor: MustacheContainer });

    var Interpolator = (function (Mustache) {
      function Interpolator () {
        Mustache.apply(this, arguments);
      }

      if ( Mustache ) Interpolator.__proto__ = Mustache;
      var Interpolator__proto__ = Interpolator.prototype = Object.create( Mustache && Mustache.prototype );
      Interpolator__proto__.constructor = Interpolator;

      Interpolator__proto__.bubble = function bubble () {
        if (this.owner) { this.owner.bubble(); }
        Mustache.prototype.bubble.call(this);
      };

      Interpolator__proto__.detach = function detach () {
        return detachNode(this.node);
      };

      Interpolator__proto__.firstNode = function firstNode () {
        return this.node;
      };

      Interpolator__proto__.getString = function getString () {
        return this.model ? safeToStringValue(this.model.get()) : '';
      };

      Interpolator__proto__.render = function render (target, occupants) {
        if (inAttributes()) { return; }
        var value = (this.value = this.getString());

        this.rendered = true;

        progressiveText(this, target, occupants, value);
      };

      Interpolator__proto__.toString = function toString (escape) {
        var string = this.getString();
        return escape ? escapeHtml(string) : string;
      };

      Interpolator__proto__.unrender = function unrender (shouldDestroy) {
        if (shouldDestroy) { this.detach(); }
        this.rendered = false;
      };

      Interpolator__proto__.update = function update () {
        if (this.dirty) {
          this.dirty = false;
          if (this.rendered) {
            var value = this.getString();
            if (value !== this.value) { this.node.data = this.value = value; }
          }
        }
      };

      Interpolator__proto__.valueOf = function valueOf () {
        return this.model ? this.model.get() : undefined;
      };

      return Interpolator;
    }(Mustache));

    var Input = (function (Element) {
      function Input () {
        Element.apply(this, arguments);
      }

      if ( Element ) Input.__proto__ = Element;
      var Input__proto__ = Input.prototype = Object.create( Element && Element.prototype );
      Input__proto__.constructor = Input;

      Input__proto__.render = function render (target, occupants) {
        Element.prototype.render.call(this, target, occupants);
        this.node.defaultValue = this.node.value;
      };
      Input__proto__.compare = function compare (value, attrValue) {
        var comparator = this.getAttribute('value-comparator');
        if (comparator) {
          if (isFunction(comparator)) {
            return comparator(value, attrValue);
          }
          if (value && attrValue) {
            return value[comparator] == attrValue[comparator];
          }
        }
        return value == attrValue;
      };

      return Input;
    }(Element));

    // simple JSON parser, without the restrictions of JSON parse
    // (i.e. having to double-quote keys).
    //
    // If passed a hash of values as the second argument, ${placeholders}
    // will be replaced with those values

    var specials$1 = {
      true: true,
      false: false,
      null: null,
      undefined: undefined
    };

    var specialsPattern = new RegExp('^(?:' + keys(specials$1).join('|') + ')');
    var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
    var placeholderPattern = /\$\{([^\}]+)\}/g;
    var placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
    var onlyWhitespace$1 = /^\s*$/;

    var JsonParser = Parser.extend({
      init: function init(str, options) {
        this.values = options.values;
        this.sp();
      },

      postProcess: function postProcess(result) {
        if (result.length !== 1 || !onlyWhitespace$1.test(this.leftover)) {
          return null;
        }

        return { value: result[0].v };
      },

      converters: [
        function getPlaceholder(parser) {
          if (!parser.values) { return null; }

          var placeholder = parser.matchPattern(placeholderAtStartPattern);

          if (placeholder && hasOwn(parser.values, placeholder)) {
            return { v: parser.values[placeholder] };
          }
        },

        function getSpecial(parser) {
          var special = parser.matchPattern(specialsPattern);
          if (special) { return { v: specials$1[special] }; }
        },

        function getNumber(parser) {
          var number = parser.matchPattern(numberPattern$1);
          if (number) { return { v: +number }; }
        },

        function getString(parser) {
          var stringLiteral = readStringLiteral(parser);
          var values = parser.values;

          if (stringLiteral && values) {
            return {
              v: stringLiteral.v.replace(placeholderPattern, function (match, $1) { return $1 in values ? values[$1] : $1; }
              )
            };
          }

          return stringLiteral;
        },

        function getObject(parser) {
          if (!parser.matchString('{')) { return null; }

          var result = {};

          parser.sp();

          if (parser.matchString('}')) {
            return { v: result };
          }

          var pair;
          while ((pair = getKeyValuePair(parser))) {
            result[pair.key] = pair.value;

            parser.sp();

            if (parser.matchString('}')) {
              return { v: result };
            }

            if (!parser.matchString(',')) {
              return null;
            }
          }

          return null;
        },

        function getArray(parser) {
          if (!parser.matchString('[')) { return null; }

          var result = [];

          parser.sp();

          if (parser.matchString(']')) {
            return { v: result };
          }

          var valueToken;
          while ((valueToken = parser.read())) {
            result.push(valueToken.v);

            parser.sp();

            if (parser.matchString(']')) {
              return { v: result };
            }

            if (!parser.matchString(',')) {
              return null;
            }

            parser.sp();
          }

          return null;
        }
      ]
    });

    function getKeyValuePair(parser) {
      parser.sp();

      var key = readKey(parser);

      if (!key) { return null; }

      var pair = { key: key };

      parser.sp();
      if (!parser.matchString(':')) {
        return null;
      }
      parser.sp();

      var valueToken = parser.read();

      if (!valueToken) { return null; }

      pair.value = valueToken.v;
      return pair;
    }

    function parseJSON(str, values) {
      var parser = new JsonParser(str, { values: values });
      return parser.result;
    }

    var Mapping = (function (Item) {
      function Mapping(options) {
        Item.call(this, options);

        this.name = options.template.n;

        this.owner = options.owner || options.up.owner || options.element || findElement(options.up);
        this.element =
          options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));
        this.up = this.element.up; // shared
        this.ractive = this.up.ractive;

        this.element.attributeByName[this.name] = this;

        this.value = options.template.f;
      }

      if ( Item ) Mapping.__proto__ = Item;
      var Mapping__proto__ = Mapping.prototype = Object.create( Item && Item.prototype );
      Mapping__proto__.constructor = Mapping;

      Mapping__proto__.bind = function bind () {
        var template = this.template.f;
        var viewmodel = this.element.instance.viewmodel;

        if (template === 0) {
          // empty attributes are `true`
          viewmodel.joinKey(this.name).set(true);
        } else if (isString(template)) {
          var parsed = parseJSON(template);
          viewmodel.joinKey(this.name).set(parsed ? parsed.value : template);
        } else if (isArray(template)) {
          createMapping(this);
        }
      };

      Mapping__proto__.rebound = function rebound (update) {
        if (this.boundFragment) { this.boundFragment.rebound(update); }
        if (this.link) {
          this.model = resolve(this.up, this.template.f[0]);
          var model = this.element.instance.viewmodel.joinAll(splitKeypath(this.name));
          model.link(this.model, this.name, { mapping: true });
        }
      };

      Mapping__proto__.render = function render () {};

      Mapping__proto__.unbind = function unbind (view) {
        if (this.model) { this.model.unregister(this); }
        if (this.boundFragment) { this.boundFragment.unbind(view); }

        if (this.element.bound) {
          if (this.link.target === this.model) { this.link.owner.unlink(); }
        }
      };

      Mapping__proto__.unrender = function unrender () {};

      Mapping__proto__.update = function update () {
        if (this.dirty) {
          this.dirty = false;
          if (this.boundFragment) { this.boundFragment.update(); }
        }
      };

      return Mapping;
    }(Item));

    function createMapping(item) {
      var template = item.template.f;
      var viewmodel = item.element.instance.viewmodel;
      var childData = viewmodel.value;

      if (template.length === 1 && template[0].t === INTERPOLATOR) {
        var model = resolve(item.up, template[0]);
        var val = model.get(false);

        // if the interpolator is not static
        if (!template[0].s) {
          item.model = model;
          item.link = viewmodel.createLink(item.name, model, template[0].r, {
            mapping: true
          });

          // initialize parent side of the mapping from child data
          if (isUndefined(val) && !model.isReadonly && item.name in childData) {
            model.set(childData[item.name]);
          }
        } else if (!isObjectType(val) || template[0].x) {
          // copy non-object, non-computed vals through
          viewmodel.joinKey(splitKeypath(item.name)).set(val);
        } else {
          // warn about trying to copy an object
          warnIfDebug(("Cannot copy non-computed object value from static mapping '" + (item.name) + "'"));
        }

        // if the item isn't going to manage the model, give it a change to tear down if it's computed
        if (model !== item.model) { model.unregister(); }
      } else {
        item.boundFragment = new Fragment({
          owner: item,
          template: template
        }).bind();

        item.model = viewmodel.joinKey(splitKeypath(item.name));
        item.model.set(item.boundFragment.valueOf());

        // item is a *bit* of a hack
        item.boundFragment.bubble = function () {
          Fragment.prototype.bubble.call(item.boundFragment);
          // defer this to avoid mucking around model deps if there happens to be an expression involved
          runloop.scheduleTask(function () {
            item.boundFragment.update();
            item.model.set(item.boundFragment.valueOf());
          });
        };
      }
    }

    var Option = (function (Element) {
      function Option(options) {
        var template = options.template;
        if (!template.a) { template.a = {}; }

        // If the value attribute is missing, use the element's content,
        // as long as it isn't disabled
        if (isUndefined(template.a.value) && !('disabled' in template.a)) {
          template.a.value = template.f || '';
        }

        Element.call(this, options);

        this.select = findElement(this.parent || this.up, false, 'select');
      }

      if ( Element ) Option.__proto__ = Element;
      var Option__proto__ = Option.prototype = Object.create( Element && Element.prototype );
      Option__proto__.constructor = Option;

      Option__proto__.bind = function bind () {
        if (!this.select) {
          Element.prototype.bind.call(this);
          return;
        }

        // If the select has a value, it overrides the `selected` attribute on
        // this option - so we delete the attribute
        var selectedAttribute = this.attributeByName.selected;
        if (selectedAttribute && this.select.getAttribute('value') !== undefined) {
          var index = this.attributes.indexOf(selectedAttribute);
          this.attributes.splice(index, 1);
          delete this.attributeByName.selected;
        }

        Element.prototype.bind.call(this);
        this.select.options.push(this);
      };

      Option__proto__.bubble = function bubble () {
        // if we're using content as value, may need to update here
        var value = this.getAttribute('value');
        if (this.node && this.node.value !== value) {
          this.node._ractive.value = value;
        }
        Element.prototype.bubble.call(this);
      };

      Option__proto__.getAttribute = function getAttribute (name) {
        var attribute = this.attributeByName[name];
        return attribute
          ? attribute.getValue()
          : name === 'value' && this.fragment
          ? this.fragment.valueOf()
          : undefined;
      };

      Option__proto__.isSelected = function isSelected () {
        var this$1 = this;

        var optionValue = this.getAttribute('value');

        if (isUndefined(optionValue) || !this.select) {
          return false;
        }

        var selectValue = this.select.getAttribute('value');

        if (this.select.compare(selectValue, optionValue)) {
          return true;
        }

        if (this.select.getAttribute('multiple') && isArray(selectValue)) {
          var i = selectValue.length;
          while (i--) {
            if (this$1.select.compare(selectValue[i], optionValue)) {
              return true;
            }
          }
        }
      };

      Option__proto__.render = function render (target, occupants) {
        Element.prototype.render.call(this, target, occupants);

        if (!this.attributeByName.value) {
          this.node._ractive.value = this.getAttribute('value');
        }
      };

      Option__proto__.unbind = function unbind (view) {
        Element.prototype.unbind.call(this, view);

        if (this.select) {
          removeFromArray(this.select.options, this);
        }
      };

      return Option;
    }(Element));

    function getPartialTemplate(ractive, name, up) {
      // If the partial in instance or view heirarchy instances, great
      var partial = getPartialFromRegistry(ractive, name, up || {});
      if (partial) { return partial; }

      // Does it exist on the page as a script tag?
      partial = parser.fromId(name, { noThrow: true });
      if (partial) {
        // parse and register to this ractive instance
        var parsed = parser.parseFor(partial, ractive);

        // register extra partials on the ractive instance if they don't already exist
        if (parsed.p) { fillGaps(ractive.partials, parsed.p); }

        // register (and return main partial if there are others in the template)
        return (ractive.partials[name] = parsed.t);
      }
    }

    function getPartialFromRegistry(ractive, name, up) {
      // if there was an instance up-hierarchy, cool
      var partial = findParentPartial(name, up.owner);
      if (partial) { return partial; }

      // find first instance in the ractive or view hierarchy that has this partial
      var instance = findInstance('partials', ractive, name);

      if (!instance) {
        return;
      }

      partial = instance.partials[name];

      // partial is a function?
      var fn;
      if (isFunction(partial)) {
        fn = partial;
        // super partial
        if (fn.styleSet) { return fn; }

        fn = partial.bind(instance);
        fn.isOwner = hasOwn(instance.partials, name);
        partial = fn.call(ractive, parser);
      }

      if (!partial && partial !== '') {
        warnIfDebug(noRegistryFunctionReturn, name, 'partial', 'partial', {
          ractive: ractive
        });
        return;
      }

      // If this was added manually to the registry,
      // but hasn't been parsed, parse it now
      if (!parser.isParsed(partial)) {
        // use the parseOptions of the ractive instance on which it was found
        var parsed = parser.parseFor(partial, instance);

        // Partials cannot contain nested partials!
        // TODO add a test for this
        if (parsed.p) {
          warnIfDebug('Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });
        }

        // if fn, use instance to store result, otherwise needs to go
        // in the correct point in prototype chain on instance or constructor
        var target = fn ? instance : findOwner(instance, name);

        // may be a template with partials, which need to be registered and main template extracted
        target.partials[name] = partial = parsed.t;
      }

      // store for reset
      if (fn) { partial._fn = fn; }

      // if the partial is a pre-parsed template object, import any expressions and update the registry
      if (partial.v) {
        addFunctions(partial);
        return (instance.partials[name] = partial.t);
      } else {
        return partial;
      }
    }

    function findOwner(ractive, key) {
      return hasOwn(ractive.partials, key) ? ractive : findConstructor(ractive.constructor, key);
    }

    function findConstructor(constructor, key) {
      if (!constructor) {
        return;
      }
      return hasOwn(constructor.partials, key) ? constructor : findConstructor(constructor.Parent, key);
    }

    function findParentPartial(name, parent) {
      if (parent) {
        if (
          parent.template &&
          parent.template.p &&
          !isArray(parent.template.p) &&
          hasOwn(parent.template.p, name)
        ) {
          return parent.template.p[name];
        } else if (parent.up && parent.up.owner) {
          return findParentPartial(name, parent.up.owner);
        }
      }
    }

    function Partial(options) {
      MustacheContainer.call(this, options);

      var tpl = options.template;

      // yielder is a special form of partial that will later require special handling
      if (tpl.t === YIELDER) {
        this.yielder = 1;
      } else if (tpl.t === ELEMENT) {
        // this is a macro partial, complete with macro constructor
        // leaving this as an element will confuse up-template searches
        this.type = PARTIAL;
        this.macro = options.macro;
      }
    }

    var proto$6 = (Partial.prototype = create(MustacheContainer.prototype));

    assign(proto$6, {
      constructor: Partial,

      bind: function bind() {
        var template = this.template;

        if (this.yielder) {
          // the container is the instance that owns this node
          this.container = this.up.ractive;
          this.component = this.container.component;
          this.containerFragment = this.up;

          // normal component
          if (this.component) {
            // yields skip the owning instance and go straight to the surrounding context
            this.up = this.component.up;

            // {{yield}} is equivalent to {{yield content}}
            if (!template.r && !template.x && !template.rx) { this.refName = 'content'; }
          } else {
            // plain-ish instance that may be attached to a parent later
            this.fragment = new Fragment({
              owner: this,
              template: []
            });
            this.fragment.bind();
            return;
          }
        }

        // this is a macro/super partial
        if (this.macro) {
          this.fn = this.macro;
        } else {
          // this is a plain partial or yielder
          if (!this.refName) { this.refName = template.r; }

          // if the refName exists as a partial, this is a plain old partial reference where no model binding will happen
          if (this.refName) {
            partialFromValue(this, this.refName);
          }

          // this is a dynamic/inline partial
          if (!this.partial && !this.fn) {
            MustacheContainer.prototype.bind.call(this);
            if (this.model) { partialFromValue(this, this.model.get()); }
          }
        }

        if (!this.partial && !this.fn) {
          warnOnceIfDebug(("Could not find template for partial '" + (this.name) + "'"));
        }

        createFragment(this, this.partial || []);

        // macro/super partial
        if (this.fn) { initMacro(this); }

        this.fragment.bind();
      },

      bubble: function bubble() {
        if (!this.dirty) {
          this.dirty = true;

          if (this.yielder) {
            this.containerFragment.bubble();
          } else {
            this.up.bubble();
          }
        }
      },

      findNextNode: function findNextNode() {
        return (this.containerFragment || this.up).findNextNode(this);
      },

      handleChange: function handleChange() {
        this.dirtyTemplate = true;
        this.externalChange = true;
        this.bubble();
      },

      rebound: function rebound(update) {
        var this$1 = this;

        if (this._attrs) {
          keys(this._attrs).forEach(function (k) { return this$1._attrs[k].rebound(update); });
        }
        MustacheContainer.prototype.rebound.call(this, update);
      },

      refreshAttrs: function refreshAttrs() {
        var this$1 = this;

        keys(this._attrs).forEach(function (k) {
          this$1.handle.attributes[k] = !this$1._attrs[k].items.length || this$1._attrs[k].valueOf();
        });
      },

      resetTemplate: function resetTemplate() {
        var this$1 = this;

        if (this.fn && this.proxy) {
          this.last = 0;
          if (this.externalChange) {
            if (isFunction(this.proxy.teardown)) { this.proxy.teardown(); }
            this.fn = this.proxy = null;
          } else {
            this.partial = this.fnTemplate;
            return true;
          }
        }

        this.partial = null;

        if (this.refName) {
          this.partial = getPartialTemplate(this.ractive, this.refName, this.up);
        }

        if (!this.partial && this.model) {
          partialFromValue(this, this.model.get());
        }

        if (!this.fn) {
          if (this.last && this.partial === this.last) { return false; }
          else if (this.partial) {
            this.last = this.partial;
            contextifyTemplate(this);
          }
        }

        this.unbindAttrs();

        if (this.fn) {
          initMacro(this);
          if (isFunction(this.proxy.render)) { runloop.scheduleTask(function () { return this$1.proxy.render(); }); }
        } else if (!this.partial) {
          warnOnceIfDebug(("Could not find template for partial '" + (this.name) + "'"));
        }

        return true;
      },

      render: function render(target, occupants) {
        if (this.fn && this.fn._cssDef && !this.fn._cssDef.applied) { applyCSS(); }

        this.fragment.render(target, occupants);

        if (this.proxy && isFunction(this.proxy.render)) { this.proxy.render(); }
      },

      unbind: function unbind(view) {
        this.fragment.unbind(view);

        this.unbindAttrs(view);

        MustacheContainer.prototype.unbind.call(this, view);
      },

      unbindAttrs: function unbindAttrs(view) {
        var this$1 = this;

        if (this._attrs) {
          keys(this._attrs).forEach(function (k) {
            this$1._attrs[k].unbind(view);
          });
        }
      },

      unrender: function unrender(shouldDestroy) {
        if (this.proxy && isFunction(this.proxy.teardown)) { this.proxy.teardown(); }

        this.fragment.unrender(shouldDestroy);
      },

      update: function update() {
        var this$1 = this;

        var proxy = this.proxy;
        this.updating = 1;

        if (this.dirtyAttrs) {
          this.dirtyAttrs = false;
          keys(this._attrs).forEach(function (k) { return this$1._attrs[k].update(); });
          this.refreshAttrs();
          if (isFunction(proxy.update)) { proxy.update(this.handle.attributes); }
        }

        if (this.dirtyTemplate) {
          this.dirtyTemplate = false;
          this.resetTemplate() && this.fragment.resetTemplate(this.partial || []);
        }

        if (this.dirty) {
          this.dirty = false;
          if (proxy && isFunction(proxy.invalidate)) { proxy.invalidate(); }
          this.fragment.update();
        }

        this.externalChange = false;
        this.updating = 0;
      }
    });

    function createFragment(self, partial) {
      self.partial = self.last = partial;
      contextifyTemplate(self);

      var options = {
        owner: self,
        template: self.partial
      };

      if (self.yielder) { options.ractive = self.container.parent; }

      if (self.fn) { options.cssIds = self.fn._cssIds; }

      self.fragment = new Fragment(options);
    }

    function contextifyTemplate(self) {
      if (self.template.c) {
        self.partial = [{ t: SECTION, n: SECTION_WITH, f: self.partial }];
        assign(self.partial[0], self.template.c);
        if (self.yielder) { self.partial[0].y = self; }
        else { self.partial[0].z = self.template.z; }
      }
    }

    function partialFromValue(self, value, okToParse) {
      var tpl = value;

      if (isArray(tpl)) {
        self.partial = tpl;
      } else if (tpl && isObjectType(tpl)) {
        if (isArray(tpl.t)) { self.partial = tpl.t; }
        else if (isString(tpl.template))
          { self.partial = parsePartial(tpl.template, tpl.template, self.ractive).t; }
      } else if (isFunction(tpl) && tpl.styleSet) {
        self.fn = tpl;
        if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }
      } else if (tpl != null) {
        tpl = getPartialTemplate(self.ractive, '' + tpl, self.containerFragment || self.up);
        if (tpl) {
          self.name = value;
          if (tpl.styleSet) {
            self.fn = tpl;
            if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }
          } else { self.partial = tpl; }
        } else if (okToParse) {
          self.partial = parsePartial('' + value, '' + value, self.ractive).t;
        } else {
          self.name = value;
        }
      }

      return self.partial;
    }

    function setTemplate(template) {
      partialFromValue(this, template, true);

      if (!this.initing) {
        this.dirtyTemplate = true;
        this.fnTemplate = this.partial;

        if (this.updating) {
          this.bubble();
          runloop.promise();
        } else {
          var promise = runloop.start();

          this.bubble();
          runloop.end();

          return promise;
        }
      }
    }

    function aliasLocal(ref, name) {
      var aliases = this.fragment.aliases || (this.fragment.aliases = {});
      if (!name) {
        aliases[ref] = this._data;
      } else {
        aliases[name] = this._data.joinAll(splitKeypath(ref));
      }
    }

    var extras = 'extra-attributes';

    function initMacro(self) {
      var fn = self.fn;
      var fragment = self.fragment;

      // defensively copy the template in case it changes
      var template = (self.template = assign({}, self.template));
      var handle = (self.handle = fragment.getContext({
        proxy: self,
        aliasLocal: aliasLocal,
        name: self.template.e || self.name,
        attributes: {},
        setTemplate: setTemplate.bind(self),
        template: template,
        macro: fn
      }));

      if (!template.p) { template.p = {}; }
      template.p = handle.partials = assign({}, template.p);
      if (!hasOwn(template.p, 'content')) { template.p.content = template.f || []; }

      if (isArray(fn.attributes)) {
        self._attrs = {};

        var invalidate = function() {
          this.dirty = true;
          self.dirtyAttrs = true;
          self.bubble();
        };

        if (isArray(template.m)) {
          var attrs = template.m;
          template.p[extras] = template.m = attrs.filter(function (a) { return !~fn.attributes.indexOf(a.n); });
          attrs
            .filter(function (a) { return ~fn.attributes.indexOf(a.n); })
            .forEach(function (a) {
              var fragment = new Fragment({
                template: a.f,
                owner: self
              });
              fragment.bubble = invalidate;
              fragment.findFirstNode = noop;
              self._attrs[a.n] = fragment;
            });
        } else {
          template.p[extras] = [];
        }
      } else {
        template.p[extras] = template.m;
      }

      if (self._attrs) {
        keys(self._attrs).forEach(function (k) {
          self._attrs[k].bind();
        });
        self.refreshAttrs();
      }

      self.initing = 1;
      self.proxy = fn.call(self.ractive, handle, handle.attributes) || {};
      if (!self.partial) { self.partial = []; }
      self.fnTemplate = self.partial;
      self.initing = 0;

      contextifyTemplate(self);
      fragment.resetTemplate(self.partial);
    }

    function parsePartial(name, partial, ractive) {
      var parsed;

      try {
        parsed = parser.parse(partial, parser.getParseOptions(ractive));
      } catch (e) {
        warnIfDebug(("Could not parse partial from expression '" + name + "'\n" + (e.message)));
      }

      return parsed || { t: [] };
    }

    var KeyModel = function KeyModel(value, context, instance) {
      this.value = this.key = value;
      this.context = context;
      this.isReadonly = this.isKey = true;
      this.deps = [];
      this.links = [];
      this.children = [];
      this.instance = instance;
    };
    var KeyModel__proto__ = KeyModel.prototype;

    KeyModel__proto__.applyValue = function applyValue (value) {
      if (value !== this.value) {
        this.value = this.key = value;
        this.deps.forEach(handleChange);
        this.links.forEach(handleChange);
        this.children.forEach(function (c) {
          c.applyValue(c.context.getKeypath(c.instance));
        });
      }
    };

    KeyModel__proto__.destroyed = function destroyed () {
      if (this.upstream) { this.upstream.unregisterChild(this); }
    };

    KeyModel__proto__.get = function get (shouldCapture) {
      if (shouldCapture) { capture(this); }
      return unescapeKey(this.value);
    };

    KeyModel__proto__.getKeypath = function getKeypath () {
      return unescapeKey(this.value);
    };

    KeyModel__proto__.has = function has () {
      return false;
    };

    KeyModel__proto__.rebind = function rebind (next, previous) {
        var this$1 = this;

      var i = this.deps.length;
      while (i--) { this$1.deps[i].rebind(next, previous, false); }

      i = this.links.length;
      while (i--) { this$1.links[i].relinking(next, false); }
    };

    KeyModel__proto__.register = function register (dependant) {
      this.deps.push(dependant);
    };

    KeyModel__proto__.registerChild = function registerChild (child) {
      addToArray(this.children, child);
      child.upstream = this;
    };

    KeyModel__proto__.registerLink = function registerLink (link) {
      addToArray(this.links, link);
    };

    KeyModel__proto__.unregister = function unregister (dependant) {
      removeFromArray(this.deps, dependant);
    };

    KeyModel__proto__.unregisterChild = function unregisterChild (child) {
      removeFromArray(this.children, child);
    };

    KeyModel__proto__.unregisterLink = function unregisterLink (link) {
      removeFromArray(this.links, link);
    };

    KeyModel.prototype.reference = noop;
    KeyModel.prototype.unreference = noop;

    var keypathString = /^"(\\"|[^"])+"$/;

    var RepeatedFragment = function RepeatedFragment(options) {
      this.parent = options.owner.up;

      // bit of a hack, so reference resolution works without another
      // layer of indirection
      this.up = this;
      this.owner = options.owner;
      this.ractive = this.parent.ractive;
      this.delegate =
        this.ractive.delegate !== false && (this.parent.delegate || findDelegate(this.parent));
      // delegation disabled by directive
      if (this.delegate && this.delegate.delegate === false) { this.delegate = false; }
      // let the element know it's a delegate handler
      if (this.delegate) { this.delegate.delegate = this.delegate; }

      // encapsulated styles should be inherited until they get applied by an element
      this.cssIds = 'cssIds' in options ? options.cssIds : this.parent ? this.parent.cssIds : null;

      this.context = null;
      this.rendered = false;
      this.iterations = [];

      this.template = options.template;

      this.indexRef = options.indexRef;
      this.keyRef = options.keyRef;

      this.pendingNewIndices = null;
      this.previousIterations = null;

      // track array versus object so updates of type rest
      this.isArray = false;
    };
    var RepeatedFragment__proto__ = RepeatedFragment.prototype;

    RepeatedFragment__proto__.bind = function bind (context) {
        var this$1 = this;

      this.context = context;
      this.bound = true;
      var value = context.get();

      var aliases = (this.aliases = this.owner.template.z && this.owner.template.z.slice());

      var shuffler = aliases && aliases.find(function (a) { return a.n === 'shuffle'; });
      if (shuffler && shuffler.x && shuffler.x.x) {
        if (shuffler.x.x.s === 'true') { this.shuffler = true; }
        else if (keypathString.test(shuffler.x.x.s))
          { this.shuffler = splitKeypath(shuffler.x.x.s.slice(1, -1)); }
      }

      if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }

      if (this.source) { this.source.model.unbind(this.source); }
      var source = context.isComputed && aliases && aliases.find(function (a) { return a.n === 'source'; });
      if (source && source.x && source.x.r) {
        var model = resolve(this, source.x);
        this.source = {
          handleChange: function handleChange() {},
          rebind: function rebind(next) {
            this.model.unregister(this);
            this.model = next;
            next.register(this);
          }
        };
        this.source.model = model;
        model.register(this.source);
      }

      // {{#each array}}...
      if ((this.isArray = isArray(value))) {
        // we can't use map, because of sparse arrays
        this.iterations = [];
        var max = (this.length = value.length);
        for (var i = 0; i < max; i += 1) {
          this$1.iterations[i] = this$1.createIteration(i, i);
        }
      } else if (isObject(value)) {
        // {{#each object}}...
        this.isArray = false;

        // TODO this is a dreadful hack. There must be a neater way
        if (this.indexRef) {
          var refs = this.indexRef.split(',');
          this.keyRef = refs[0];
          this.indexRef = refs[1];
        }

        var ks = keys(value);
        this.length = ks.length;

        this.iterations = ks.map(function (key, index) {
          return this$1.createIteration(key, index);
        });
      }

      return this;
    };

    RepeatedFragment__proto__.bubble = function bubble (index) {
      if (!this.bubbled) { this.bubbled = []; }
      this.bubbled.push(index);

      if (!this.rebounding) { this.owner.bubble(); }
    };

    RepeatedFragment__proto__.createIteration = function createIteration (key, index) {
      var fragment = new Fragment({
        owner: this,
        template: this.template
      });

      fragment.isIteration = true;
      fragment.delegate = this.delegate;

      if (this.aliases) { fragment.aliases = {}; }
      swizzleFragment(this, fragment, key, index);

      return fragment.bind(fragment.context);
    };

    RepeatedFragment__proto__.destroyed = function destroyed () {
        var this$1 = this;

      var len = this.iterations.length;
      for (var i = 0; i < len; i++) { this$1.iterations[i].destroyed(); }
      if (this.pathModel) { this.pathModel.destroyed(); }
      if (this.rootModel) { this.rootModel.destroyed(); }
    };

    RepeatedFragment__proto__.detach = function detach () {
      var docFrag = createDocumentFragment();
      this.iterations.forEach(function (fragment) { return docFrag.appendChild(fragment.detach()); });
      return docFrag;
    };

    RepeatedFragment__proto__.find = function find (selector, options) {
      return findMap(this.iterations, function (i) { return i.find(selector, options); });
    };

    RepeatedFragment__proto__.findAll = function findAll (selector, options) {
      return this.iterations.forEach(function (i) { return i.findAll(selector, options); });
    };

    RepeatedFragment__proto__.findAllComponents = function findAllComponents (name, options) {
      return this.iterations.forEach(function (i) { return i.findAllComponents(name, options); });
    };

    RepeatedFragment__proto__.findComponent = function findComponent (name, options) {
      return findMap(this.iterations, function (i) { return i.findComponent(name, options); });
    };

    RepeatedFragment__proto__.findContext = function findContext () {
      return this.context;
    };

    RepeatedFragment__proto__.findNextNode = function findNextNode (iteration) {
        var this$1 = this;

      if (iteration.index < this.iterations.length - 1) {
        for (var i = iteration.index + 1; i < this.iterations.length; i++) {
          var node = this$1.iterations[i].firstNode(true);
          if (node) { return node; }
        }
      }

      return this.owner.findNextNode();
    };

    RepeatedFragment__proto__.firstNode = function firstNode (skipParent) {
      return this.iterations[0] ? this.iterations[0].firstNode(skipParent) : null;
    };

    RepeatedFragment__proto__.getLast = function getLast () {
      return this.lastModel || (this.lastModel = new KeyModel(this.length - 1));
    };

    RepeatedFragment__proto__.rebind = function rebind (next) {
        var this$1 = this;

      this.context = next;
      if (this.source) { return; }
      if (next) {
        this.iterations.forEach(function (fragment) {
          swizzleFragment(this$1, fragment, fragment.key, fragment.index);
        });
      }
    };

    RepeatedFragment__proto__.rebound = function rebound (update$$1) {
        var this$1 = this;

      this.context = this.owner.model;
      this.iterations.forEach(function (f, i) {
        f.context = contextFor(this$1, f, i);
        f.rebound(update$$1);
      });
    };

    RepeatedFragment__proto__.render = function render (target, occupants) {
      var xs = this.iterations;
      if (xs) {
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          xs[i].render(target, occupants);
        }
      }

      this.rendered = true;
    };

    RepeatedFragment__proto__.shuffle = function shuffle (newIndices, merge) {
        var this$1 = this;

      if (!this.pendingNewIndices) { this.previousIterations = this.iterations.slice(); }

      if (!this.pendingNewIndices) { this.pendingNewIndices = []; }

      this.pendingNewIndices.push(newIndices);

      var iterations = [];

      newIndices.forEach(function (newIndex, oldIndex) {
        if (newIndex === -1) { return; }

        var fragment = this$1.iterations[oldIndex];
        iterations[newIndex] = fragment;

        if (newIndex !== oldIndex && fragment) {
          fragment.dirty = true;
          if (merge) { fragment.shouldRebind = 1; }
        }
      });

      this.iterations = iterations;

      // if merging, we're in the midst of an update already
      if (!merge) { this.bubble(); }
    };

    RepeatedFragment__proto__.shuffled = function shuffled$2 () {
      this.iterations.forEach(shuffled);
    };

    RepeatedFragment__proto__.toString = function toString (escape) {
      return this.iterations ? this.iterations.map(escape ? toEscapedString : toString$1).join('') : '';
    };

    RepeatedFragment__proto__.unbind = function unbind (view) {
      this.bound = false;
      if (this.source) { this.source.model.unregister(this.source); }
      var iterations = this.pendingNewIndices ? this.previousIterations : this.iterations;
      var len = iterations.length;
      for (var i = 0; i < len; i++) { iterations[i].unbind(view); }
      return this;
    };

    RepeatedFragment__proto__.unrender = function unrender (shouldDestroy) {
        var this$1 = this;

      var len = this.iterations.length;
      for (var i = 0; i < len; i++) { this$1.iterations[i].unrender(shouldDestroy); }
      if (this.pendingNewIndices && this.previousIterations) {
        len = this.previousIterations.length;
        for (var i$1 = 0; i$1 < len; i$1++) { this$1.previousIterations[i$1].unrender(shouldDestroy); }
      }
      this.rendered = false;
    };

    RepeatedFragment__proto__.update = function update$3 () {
        var this$1 = this;

      if (this.pendingNewIndices) {
        this.bubbled.length = 0;
        this.updatePostShuffle();
        return;
      }

      if (this.updating) { return; }
      this.updating = true;

      if (this.shuffler) {
        var values = shuffleValues(this, this.shuffler);
        var newIndices = buildNewIndices(this.values, values);
        if (!newIndices.same) {
          this.shuffle(newIndices, true);
          this.updatePostShuffle();
        } else {
          this.iterations.forEach(update);
        }
      } else {
        var len = this.iterations.length;
        for (var i = 0; i < len; i++) {
          var f = this$1.iterations[i];
          f && f.idxModel && f.idxModel.applyValue(i);
        }

        var value = this.context.get();
        var wasArray = this.isArray;

        var toRemove;
        var oldKeys;
        var reset = true;
        var i$1;

        if ((this.isArray = isArray(value))) {
          // if there's a source to map back to, make sure everything stays bound correctly
          if (this.source) {
            this.rebounding = 1;
            var source = this.source.model.get();
            this.iterations.forEach(function (f, c) {
              if (c < value.length && f.lastValue !== value[c] && ~(i$1 = source.indexOf(value[c]))) {
                swizzleFragment(this$1, f, c, c);
                f.rebound(true);
              }
            });
            this.rebounding = 0;
          }

          if (wasArray) {
            reset = false;
            if (this.iterations.length > value.length) {
              toRemove = this.iterations.splice(value.length);
            }
          }
        } else if (isObject(value) && !wasArray) {
          reset = false;
          toRemove = [];
          oldKeys = {};
          i$1 = this.iterations.length;

          while (i$1--) {
            var fragment = this$1.iterations[i$1];
            if (fragment.key in value) {
              oldKeys[fragment.key] = true;
            } else {
              this$1.iterations.splice(i$1, 1);
              toRemove.push(fragment);
            }
          }
        }

        var newLength = isArray(value) ? value.length : isObject(value) ? keys(value).length : 0;
        this.length = newLength;
        this.updateLast();

        if (reset) {
          toRemove = this.iterations;
          this.iterations = [];
        }

        if (toRemove) {
          len = toRemove.length;
          for (var i$2 = 0; i$2 < len; i$2++) { toRemove[i$2].unbind().unrender(true); }
        }

        // update the remaining ones
        if (!reset && this.isArray && this.bubbled && this.bubbled.length) {
          var bubbled = this.bubbled;
          this.bubbled = [];
          len = bubbled.length;
          for (var i$3 = 0; i$3 < len; i$3++)
            { this$1.iterations[bubbled[i$3]] && this$1.iterations[bubbled[i$3]].update(); }
        } else {
          len = this.iterations.length;
          for (var i$4 = 0; i$4 < len; i$4++) { this$1.iterations[i$4].update(); }
        }

        // add new iterations
        var docFrag;
        var fragment$1;

        if (newLength > this.iterations.length) {
          docFrag = this.rendered ? createDocumentFragment() : null;
          i$1 = this.iterations.length;

          if (isArray(value)) {
            while (i$1 < value.length) {
              fragment$1 = this$1.createIteration(i$1, i$1);

              this$1.iterations.push(fragment$1);
              if (this$1.rendered) { fragment$1.render(docFrag); }

              i$1 += 1;
            }
          } else if (isObject(value)) {
            // TODO this is a dreadful hack. There must be a neater way
            if (this.indexRef && !this.keyRef) {
              var refs = this.indexRef.split(',');
              this.keyRef = refs[0];
              this.indexRef = refs[1];
            }

            keys(value).forEach(function (key) {
              if (!oldKeys || !(key in oldKeys)) {
                fragment$1 = this$1.createIteration(key, i$1);

                this$1.iterations.push(fragment$1);
                if (this$1.rendered) { fragment$1.render(docFrag); }

                i$1 += 1;
              }
            });
          }

          if (this.rendered) {
            var parentNode = this.parent.findParentNode();
            var anchor = this.parent.findNextNode(this.owner);

            parentNode.insertBefore(docFrag, anchor);
          }
        }
      }

      this.updating = false;
    };

    RepeatedFragment__proto__.updateLast = function updateLast () {
      if (this.lastModel) { this.lastModel.applyValue(this.length - 1); }
    };

    RepeatedFragment__proto__.updatePostShuffle = function updatePostShuffle () {
        var this$1 = this;

      var newIndices = this.pendingNewIndices[0];
      var parentNode = this.rendered ? this.parent.findParentNode() : null;
      var nextNode = parentNode && this.owner.findNextNode();
      var docFrag = parentNode ? createDocumentFragment() : null;

      // map first shuffle through
      this.pendingNewIndices.slice(1).forEach(function (indices) {
        newIndices.forEach(function (newIndex, oldIndex) {
          newIndices[oldIndex] = indices[newIndex];
        });
      });

      var len = (this.length = this.context.get().length);
      var prev = this.previousIterations;
      var iters = this.iterations;
      var value = this.context.get();
      var stash = {};
      var idx, dest, pos, next, anchor, rebound;

      var map = new Array(newIndices.length);
      newIndices.forEach(function (e, i) { return (map[e] = i); });

      this.updateLast();

      idx = pos = 0;
      while (idx < len) {
        // if there's not an existing thing to shuffle, handle that
        if (isUndefined(map[idx])) {
          next = iters[idx] = this$1.createIteration(idx, idx);
          if (parentNode) {
            anchor = prev[pos];
            anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;

            next.render(docFrag);
            parentNode.insertBefore(docFrag, anchor);
          }

          idx++;
        } else {
          dest = newIndices[pos];

          if (dest === -1) {
            // if it needs to be dropped, drop it
            prev[pos] && prev[pos].unbind().unrender(true);
            prev[pos++] = 0;
          } else if (dest > idx) {
            // if it needs to move down, stash it
            stash[dest] = prev[pos];
            prev[pos++] = null;
          } else {
            // get the fragment that goes for this idx
            iters[idx] = next = iters[idx] || stash[idx] || this$1.createIteration(idx, idx);

            // if it's an existing fragment, swizzle
            if (stash[idx] || pos !== idx) {
              rebound = this$1.source && next.lastValue !== value[idx];
              swizzleFragment(this$1, next, idx, idx);
            }

            // does next need to be moved?
            if (parentNode && (stash[idx] || !prev[pos])) {
              anchor = prev[pos + 1];
              anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;

              if (stash[idx]) {
                parentNode.insertBefore(next.detach(), anchor);
              } else {
                next.render(docFrag);
                parentNode.insertBefore(docFrag, anchor);
              }
            }

            prev[pos++] = 0;
            idx++;
          }

          if (next && isObjectType(next)) {
            if (next.shouldRebind || rebound) {
              next.rebound(rebound);
              next.shouldRebind = 0;
            }
            next.update();
            next.shuffled();
          }
        }
      }

      // clean up any stragglers
      var plen = prev.length;
      for (var i = 0; i < plen; i++) { prev[i] && prev[i].unbind().unrender(true); }

      if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }

      this.pendingNewIndices = null;
      this.previousIterations = null;
    };

    RepeatedFragment.prototype.getContext = getContext;
    RepeatedFragment.prototype.getKeypath = getKeypath;

    // find the topmost delegate
    function findDelegate(start) {
      var frag = start;
      var delegate, el;

      out: while (frag) {
        // find next element
        el = 0;
        while (!el && frag) {
          if (frag.owner.type === ELEMENT) { el = frag.owner; }
          if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }
          frag = frag.parent || frag.componentParent;
        }

        if (el.delegate === false) { break out; }
        delegate = el.delegate || el;

        // find next repeated fragment
        while (frag) {
          if (frag.iterations) { break; }
          if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }
          frag = frag.parent || frag.componentParent;
        }
      }

      return delegate;
    }

    function swizzleFragment(section, fragment, key, idx) {
      var model = section.context ? contextFor(section, fragment, key) : undefined;

      fragment.key = key;
      fragment.index = idx;
      fragment.context = model;
      if (section.source) { fragment.lastValue = model && model.get(); }

      if (fragment.idxModel) { fragment.idxModel.applyValue(idx); }
      if (fragment.keyModel) { fragment.keyModel.applyValue(key); }
      if (fragment.pathModel) {
        fragment.pathModel.context = model;
        fragment.pathModel.applyValue(model.getKeypath());
      }
      if (fragment.rootModel) {
        fragment.rootModel.context = model;
        fragment.rootModel.applyValue(model.getKeypath(fragment.ractive.root));
      }

      // handle any aliases
      var aliases = fragment.aliases;
      section.aliases &&
        section.aliases.forEach(function (a) {
          if (a.x.r === '.') { aliases[a.n] = model; }
          else if (a.x.r === '@index') { aliases[a.n] = fragment.getIndex(); }
          else if (a.x.r === '@key') { aliases[a.n] = fragment.getKey(); }
          else if (a.x.r === '@keypath') { aliases[a.n] = fragment.getKeypath(); }
          else if (a.x.r === '@rootpath') { aliases[a.n] = fragment.getKeypath(true); }
        });
    }

    function shuffleValues(section, shuffler) {
      var array = section.context.get() || [];
      if (shuffler === true) {
        return array.slice();
      } else {
        return array.map(function (v) { return shuffler.reduce(function (a, c) { return a && a[c]; }, v); });
      }
    }

    function contextFor(section, fragment, key) {
      if (section.source) {
        var idx;
        var source = section.source.model.get();
        if (source.indexOf && ~(idx = source.indexOf(section.context.joinKey(key).get())))
          { return section.source.model.joinKey(idx); }
      }

      return section.context.joinKey(key);
    }

    function isEmpty(value) {
      return (
        !value ||
        (isArray(value) && value.length === 0) ||
        (isObject(value) && keys(value).length === 0)
      );
    }

    function getType(value, hasIndexRef) {
      if (hasIndexRef || isArray(value)) { return SECTION_EACH; }
      if (isObjectLike(value)) { return SECTION_IF_WITH; }
      if (isUndefined(value)) { return null; }
      return SECTION_IF;
    }

    var Section = (function (MustacheContainer) {
      function Section(options) {
        MustacheContainer.call(this, options);

        this.isAlias = options.template.t === ALIAS;
        this.sectionType = options.template.n || (this.isAlias && SECTION_WITH) || null;
        this.templateSectionType = this.sectionType;
        this.subordinate = options.template.l === 1;
        this.fragment = null;
      }

      if ( MustacheContainer ) Section.__proto__ = MustacheContainer;
      var Section__proto__ = Section.prototype = Object.create( MustacheContainer && MustacheContainer.prototype );
      Section__proto__.constructor = Section;

      Section__proto__.bind = function bind () {
        MustacheContainer.prototype.bind.call(this);

        if (this.subordinate) {
          this.sibling = this.up.items[this.up.items.indexOf(this) - 1];
          this.sibling.nextSibling = this;
        }

        // if we managed to bind, we need to create children
        if (this.model || this.isAlias) {
          this.dirty = true;
          this.update();
        } else if (
          this.sectionType &&
          this.sectionType === SECTION_UNLESS &&
          (!this.sibling || !this.sibling.isTruthy())
        ) {
          this.fragment = new Fragment({
            owner: this,
            template: this.template.f
          }).bind();
        }
      };

      Section__proto__.bubble = function bubble () {
        if (!this.dirty && this.yield) {
          this.dirty = true;
          this.containerFragment.bubble();
        } else { MustacheContainer.prototype.bubble.call(this); }
      };

      Section__proto__.detach = function detach () {
        var frag = this.fragment || this.detached;
        return frag ? frag.detach() : MustacheContainer.prototype.detach.call(this);
      };

      Section__proto__.findNextNode = function findNextNode () {
        return (this.containerFragment || this.up).findNextNode(this);
      };

      Section__proto__.isTruthy = function isTruthy () {
        if (this.subordinate && this.sibling.isTruthy()) { return true; }
        var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
        return !!value && (this.templateSectionType === SECTION_IF_WITH || !isEmpty(value));
      };

      Section__proto__.rebind = function rebind (next, previous, safe) {
        if (MustacheContainer.prototype.rebind.call(this, next, previous, safe)) {
          if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {
            this.fragment.rebind(next);
          }
        }
      };

      Section__proto__.rebound = function rebound (update) {
        if (this.model) {
          if (this.model.rebound) { this.model.rebound(update); }
          else {
            MustacheContainer.prototype.unbind.call(this);
            MustacheContainer.prototype.bind.call(this);
            if (
              this.sectionType === SECTION_WITH ||
              this.sectionType === SECTION_IF_WITH ||
              this.sectionType === SECTION_EACH
            ) {
              if (this.fragment) { this.fragment.rebind(this.model); }
            }

            if (update) { this.bubble(); }
          }
        }
        if (this.fragment) { this.fragment.rebound(update); }
      };

      Section__proto__.render = function render (target, occupants) {
        this.rendered = true;
        if (this.fragment) { this.fragment.render(target, occupants); }
      };

      Section__proto__.shuffle = function shuffle (newIndices) {
        if (this.fragment && this.sectionType === SECTION_EACH) {
          this.fragment.shuffle(newIndices);
        }
      };

      Section__proto__.unbind = function unbind (view) {
        MustacheContainer.prototype.unbind.call(this, view);
        if (this.fragment) { this.fragment.unbind(view); }
      };

      Section__proto__.unrender = function unrender (shouldDestroy) {
        if (this.rendered && this.fragment) { this.fragment.unrender(shouldDestroy); }
        this.rendered = false;
      };

      Section__proto__.update = function update () {
        var this$1 = this;

        if (!this.dirty) { return; }

        if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {
          this.fragment.context = this.model;
        }

        if (!this.model && this.sectionType !== SECTION_UNLESS && !this.isAlias) { return; }

        this.dirty = false;

        var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
        var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();
        var lastType = this.sectionType;

        if (this.yield && this.yield !== value) {
          this.up = this.containerFragment;
          this.container = null;
          this.yield = null;
          if (this.rendered) { this.fragment.unbind().unrender(true); }
          this.fragment = null;
        } else if (this.rendered && !this.yield && value instanceof Context) {
          if (this.rendered && this.fragment) { this.fragment.unbind().unrender(true); }
          this.fragment = null;
        }

        // watch for switching section types
        if (this.sectionType === null || this.templateSectionType === null)
          { this.sectionType = getType(value, this.template.i); }
        if (lastType && lastType !== this.sectionType && this.fragment) {
          if (this.rendered) {
            this.fragment.unbind().unrender(true);
          }

          this.fragment = null;
        }

        var newFragment;

        var fragmentShouldExist =
          this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations
          this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment
          (siblingFalsey &&
            (this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy())) || // if, unless, and if-with depend on siblings and the condition
          this.isAlias;

        if (fragmentShouldExist) {
          if (!this.fragment) { this.fragment = this.detached; }

          if (this.fragment) {
            // check for detached fragment
            if (this.detached) {
              attach(this, this.fragment);
              this.detached = false;
              this.rendered = true;
            }

            if (!this.fragment.bound) { this.fragment.bind(this.model); }
            this.fragment.update();
          } else {
            if (this.sectionType === SECTION_EACH) {
              newFragment = new RepeatedFragment({
                owner: this,
                template: this.template.f,
                indexRef: this.template.i
              }).bind(this.model);
            } else {
              // only with and if-with provide context - if and unless do not
              var context =
                this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS
                  ? this.model
                  : null;

              if (value instanceof Context) {
                this.yield = value;
                this.containerFragment = this.up;
                this.up = value.fragment;
                this.container = value.ractive;
                context = undefined;
              }

              newFragment = new Fragment({
                owner: this,
                template: this.template.f
              }).bind(context);
            }
          }
        } else {
          if (this.fragment && this.rendered) {
            if (keep !== true) {
              this.fragment.unbind().unrender(true);
            } else {
              this.unrender(false);
              this.detached = this.fragment;
              runloop.promise().then(function () {
                if (this$1.detached) { this$1.detach(); }
              });
            }
          } else if (this.fragment) {
            this.fragment.unbind();
          }

          this.fragment = null;
        }

        if (newFragment) {
          if (this.rendered) {
            attach(this, newFragment);
          }

          this.fragment = newFragment;
        }

        if (this.nextSibling) {
          this.nextSibling.dirty = true;
          this.nextSibling.update();
        }
      };

      return Section;
    }(MustacheContainer));

    function attach(section, fragment) {
      var anchor = (section.containerFragment || section.up).findNextNode(section);

      if (anchor) {
        var docFrag = createDocumentFragment();
        fragment.render(docFrag);

        anchor.parentNode.insertBefore(docFrag, anchor);
      } else {
        fragment.render(section.up.findParentNode());
      }
    }

    var Select = (function (Element) {
      function Select(options) {
        Element.call(this, options);
        this.options = [];
      }

      if ( Element ) Select.__proto__ = Element;
      var Select__proto__ = Select.prototype = Object.create( Element && Element.prototype );
      Select__proto__.constructor = Select;

      Select__proto__.foundNode = function foundNode (node) {
        if (this.binding) {
          var selectedOptions = getSelectedOptions(node);

          if (selectedOptions.length > 0) {
            this.selectedOptions = selectedOptions;
          }
        }
      };

      Select__proto__.render = function render (target, occupants) {
        Element.prototype.render.call(this, target, occupants);
        this.sync();

        var node = this.node;

        var i = node.options.length;
        while (i--) {
          node.options[i].defaultSelected = node.options[i].selected;
        }

        this.rendered = true;
      };

      Select__proto__.sync = function sync () {
        var this$1 = this;

        var selectNode = this.node;

        if (!selectNode) { return; }

        var options = toArray(selectNode.options);

        if (this.selectedOptions) {
          options.forEach(function (o) {
            if (this$1.selectedOptions.indexOf(o) >= 0) { o.selected = true; }
            else { o.selected = false; }
          });
          this.binding.setFromNode(selectNode);
          delete this.selectedOptions;
          return;
        }

        var selectValue = this.getAttribute('value');
        var isMultiple = this.getAttribute('multiple');
        var array = isMultiple && isArray(selectValue);

        // If the <select> has a specified value, that should override
        // these options
        if (selectValue !== undefined) {
          var optionWasSelected;

          options.forEach(function (o) {
            var optionValue = o._ractive ? o._ractive.value : o.value;
            var shouldSelect = isMultiple
              ? array && this$1.valueContains(selectValue, optionValue)
              : this$1.compare(selectValue, optionValue);

            if (shouldSelect) {
              optionWasSelected = true;
            }

            o.selected = shouldSelect;
          });

          if (!optionWasSelected && !isMultiple) {
            if (this.binding) {
              this.binding.forceUpdate();
            }
          }
        } else if (this.binding && this.binding.forceUpdate) {
          // Otherwise the value should be initialised according to which
          // <option> element is selected, if twoway binding is in effect
          this.binding.forceUpdate();
        }
      };
      Select__proto__.valueContains = function valueContains (selectValue, optionValue) {
        var this$1 = this;

        var i = selectValue.length;
        while (i--) {
          if (this$1.compare(optionValue, selectValue[i])) { return true; }
        }
      };
      Select__proto__.compare = function compare (optionValue, selectValue) {
        var comparator = this.getAttribute('value-comparator');
        if (comparator) {
          if (isFunction(comparator)) {
            return comparator(selectValue, optionValue);
          }
          if (selectValue && optionValue) {
            return selectValue[comparator] == optionValue[comparator];
          }
        }
        return selectValue == optionValue;
      };
      Select__proto__.update = function update () {
        var dirty = this.dirty;
        Element.prototype.update.call(this);
        if (dirty) {
          this.sync();
        }
      };

      return Select;
    }(Element));

    var Textarea = (function (Input) {
      function Textarea(options) {
        var template = options.template;

        options.deferContent = true;

        Input.call(this, options);

        // check for single interpolator binding
        if (!this.attributeByName.value) {
          if (template.f && isBindable({ template: template })) {
            (this.attributes || (this.attributes = [])).push(
              createItem({
                owner: this,
                template: { t: ATTRIBUTE, f: template.f, n: 'value' },
                up: this.up
              })
            );
          } else {
            this.fragment = new Fragment({
              owner: this,
              cssIds: null,
              template: template.f
            });
          }
        }
      }

      if ( Input ) Textarea.__proto__ = Input;
      var Textarea__proto__ = Textarea.prototype = Object.create( Input && Input.prototype );
      Textarea__proto__.constructor = Textarea;

      Textarea__proto__.bubble = function bubble () {
        var this$1 = this;

        if (!this.dirty) {
          this.dirty = true;

          if (this.rendered && !this.binding && this.fragment) {
            runloop.scheduleTask(function () {
              this$1.dirty = false;
              this$1.node.value = this$1.fragment.toString();
            });
          }

          this.up.bubble(); // default behaviour
        }
      };

      return Textarea;
    }(Input));

    var Text = (function (Item) {
      function Text(options) {
        Item.call(this, options);
        this.type = TEXT;
      }

      if ( Item ) Text.__proto__ = Item;
      var Text__proto__ = Text.prototype = Object.create( Item && Item.prototype );
      Text__proto__.constructor = Text;

      Text__proto__.detach = function detach () {
        return detachNode(this.node);
      };

      Text__proto__.firstNode = function firstNode () {
        return this.node;
      };

      Text__proto__.render = function render (target, occupants) {
        if (inAttributes()) { return; }
        this.rendered = true;

        progressiveText(this, target, occupants, this.template);
      };

      Text__proto__.toString = function toString (escape) {
        return escape ? escapeHtml(this.template) : this.template;
      };

      Text__proto__.unrender = function unrender (shouldDestroy) {
        if (this.rendered && shouldDestroy) { this.detach(); }
        this.rendered = false;
      };

      Text__proto__.valueOf = function valueOf () {
        return this.template;
      };

      return Text;
    }(Item));

    var proto$7 = Text.prototype;
    proto$7.bind = proto$7.unbind = proto$7.update = noop;

    var visible;
    var hidden = 'hidden';

    if (doc) {
      var prefix$2;

      /* istanbul ignore next */
      if (hidden in doc) {
        prefix$2 = '';
      } else {
        var i$1 = vendors.length;
        while (i$1--) {
          var vendor = vendors[i$1];
          hidden = vendor + 'Hidden';

          if (hidden in doc) {
            prefix$2 = vendor;
            break;
          }
        }
      }

      /* istanbul ignore else */
      if (prefix$2 !== undefined) {
        doc.addEventListener(prefix$2 + 'visibilitychange', onChange);
        onChange();
      } else {
        // gah, we're in an old browser
        if ('onfocusout' in doc) {
          doc.addEventListener('focusout', onHide);
          doc.addEventListener('focusin', onShow);
        } else {
          win.addEventListener('pagehide', onHide);
          win.addEventListener('blur', onHide);

          win.addEventListener('pageshow', onShow);
          win.addEventListener('focus', onShow);
        }

        visible = true; // until proven otherwise. Not ideal but hey
      }
    }

    function onChange() {
      visible = !doc[hidden];
    }

    /* istanbul ignore next */
    function onHide() {
      visible = false;
    }

    /* istanbul ignore next */
    function onShow() {
      visible = true;
    }

    var prefix;

    /* istanbul ignore next */
    if (!isClient) {
      prefix = null;
    } else {
      var prefixCache = {};
      var testStyle = createElement('div').style;

      // technically this also normalizes on hyphenated styles as well
      prefix = function(prop) {
        if (!prefixCache[prop]) {
          var name = hyphenateCamel(prop);

          if (testStyle[prop] !== undefined) {
            prefixCache[prop] = name;
          } else {
            /* istanbul ignore next */
            // test vendors...
            var i = vendors.length;
            while (i--) {
              var vendor = "-" + (vendors[i]) + "-" + name;
              if (testStyle[vendor] !== undefined) {
                prefixCache[prop] = vendor;
                break;
              }
            }
          }
        }

        return prefixCache[prop];
      };
    }

    var prefix$1 = prefix;

    var vendorPattern = new RegExp('^(?:' + vendors.join('|') + ')([A-Z])');

    function hyphenate(str) {
      /* istanbul ignore next */
      if (!str) { return ''; } // edge case

      /* istanbul ignore next */
      if (vendorPattern.test(str)) { str = '-' + str; }

      return str.replace(/[A-Z]/g, function (match) { return '-' + match.toLowerCase(); });
    }

    var createTransitions;

    if (!isClient) {
      createTransitions = null;
    } else {
      var testStyle$1 = createElement('div').style;
      var linear$1 = function (x) { return x; };

      var canUseCssTransitions = {};
      var cannotUseCssTransitions = {};

      // determine some facts about our environment
      var TRANSITION$1;
      var TRANSITIONEND;
      var CSS_TRANSITIONS_ENABLED;
      var TRANSITION_DURATION;
      var TRANSITION_PROPERTY;
      var TRANSITION_TIMING_FUNCTION;

      if (testStyle$1.transition !== undefined) {
        TRANSITION$1 = 'transition';
        TRANSITIONEND = 'transitionend';
        CSS_TRANSITIONS_ENABLED = true;
      } else if (testStyle$1.webkitTransition !== undefined) {
        TRANSITION$1 = 'webkitTransition';
        TRANSITIONEND = 'webkitTransitionEnd';
        CSS_TRANSITIONS_ENABLED = true;
      } else {
        CSS_TRANSITIONS_ENABLED = false;
      }

      if (TRANSITION$1) {
        TRANSITION_DURATION = TRANSITION$1 + 'Duration';
        TRANSITION_PROPERTY = TRANSITION$1 + 'Property';
        TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';
      }

      createTransitions = function(t, to, options, changedProperties, resolve) {
        // Wait a beat (otherwise the target styles will be applied immediately)
        // TODO use a fastdom-style mechanism?
        setTimeout(function () {
          var jsTransitionsComplete;
          var cssTransitionsComplete;
          var cssTimeout; // eslint-disable-line prefer-const

          function transitionDone() {
            clearTimeout(cssTimeout);
          }

          function checkComplete() {
            if (jsTransitionsComplete && cssTransitionsComplete) {
              t.unregisterCompleteHandler(transitionDone);
              // will changes to events and fire have an unexpected consequence here?
              t.ractive.fire(t.name + ':end', t.node, t.isIntro);
              resolve();
            }
          }

          // this is used to keep track of which elements can use CSS to animate
          // which properties
          var hashPrefix = (t.node.namespaceURI || '') + t.node.tagName;

          // need to reset transition properties
          var style = t.node.style;
          var previous = {
            property: style[TRANSITION_PROPERTY],
            timing: style[TRANSITION_TIMING_FUNCTION],
            duration: style[TRANSITION_DURATION]
          };

          function transitionEndHandler(event) {
            if (event.target !== t.node) { return; }
            var index = changedProperties.indexOf(event.propertyName);

            if (index !== -1) {
              changedProperties.splice(index, 1);
            }

            if (changedProperties.length) {
              // still transitioning...
              return;
            }

            clearTimeout(cssTimeout);
            cssTransitionsDone();
          }

          function cssTransitionsDone() {
            style[TRANSITION_PROPERTY] = previous.property;
            style[TRANSITION_TIMING_FUNCTION] = previous.duration;
            style[TRANSITION_DURATION] = previous.timing;

            t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);

            cssTransitionsComplete = true;
            checkComplete();
          }

          t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);

          // safety net in case transitionend never fires
          cssTimeout = setTimeout(function () {
            changedProperties = [];
            cssTransitionsDone();
          }, options.duration + (options.delay || 0) + 50);
          t.registerCompleteHandler(transitionDone);

          style[TRANSITION_PROPERTY] = changedProperties.join(',');
          var easingName = hyphenate(options.easing || 'linear');
          style[TRANSITION_TIMING_FUNCTION] = easingName;
          var cssTiming = style[TRANSITION_TIMING_FUNCTION] === easingName;
          style[TRANSITION_DURATION] = options.duration / 1000 + 's';

          setTimeout(function () {
            var i = changedProperties.length;
            var hash;
            var originalValue = null;
            var index;
            var propertiesToTransitionInJs = [];
            var prop;
            var suffix;
            var interpolator;

            while (i--) {
              prop = changedProperties[i];
              hash = hashPrefix + prop;

              if (cssTiming && CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {
                var initial = style[prop];
                style[prop] = to[prop];

                // If we're not sure if CSS transitions are supported for
                // this tag/property combo, find out now
                if (!(hash in canUseCssTransitions)) {
                  originalValue = t.getStyle(prop);

                  // if this property is transitionable in this browser,
                  // the current style will be different from the target style
                  canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];
                  cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];

                  // Reset, if we're going to use timers after all
                  if (cannotUseCssTransitions[hash]) {
                    style[prop] = initial;
                  }
                }
              }

              if (!cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {
                // we need to fall back to timer-based stuff
                if (originalValue === null) { originalValue = t.getStyle(prop); }

                // need to remove this from changedProperties, otherwise transitionEndHandler
                // will get confused
                index = changedProperties.indexOf(prop);
                if (index === -1) {
                  warnIfDebug(
                    'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!',
                    { node: t.node }
                  );
                } else {
                  changedProperties.splice(index, 1);
                }

                // TODO Determine whether this property is animatable at all

                suffix = /[^\d]*$/.exec(originalValue)[0];
                interpolator = interpolate(parseFloat(originalValue), parseFloat(to[prop]));

                // ...then kick off a timer-based transition
                if (interpolator) {
                  propertiesToTransitionInJs.push({
                    name: prop,
                    interpolator: interpolator,
                    suffix: suffix
                  });
                } else {
                  style[prop] = to[prop];
                }

                originalValue = null;
              }
            }

            // javascript transitions
            if (propertiesToTransitionInJs.length) {
              var easing;

              if (isString(options.easing)) {
                easing = t.ractive.easing[options.easing];

                if (!easing) {
                  warnOnceIfDebug(missingPlugin(options.easing, 'easing'));
                  easing = linear$1;
                }
              } else if (isFunction(options.easing)) {
                easing = options.easing;
              } else {
                easing = linear$1;
              }

              new Ticker({
                duration: options.duration,
                easing: easing,
                step: function step(pos) {
                  var i = propertiesToTransitionInJs.length;
                  while (i--) {
                    var prop = propertiesToTransitionInJs[i];
                    style[prop.name] = prop.interpolator(pos) + prop.suffix;
                  }
                },
                complete: function complete() {
                  jsTransitionsComplete = true;
                  checkComplete();
                }
              });
            } else {
              jsTransitionsComplete = true;
            }

            if (changedProperties.length) {
              style[TRANSITION_PROPERTY] = changedProperties.join(',');
            } else {
              style[TRANSITION_PROPERTY] = 'none';

              // We need to cancel the transitionEndHandler, and deal with
              // the fact that it will never fire
              t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);
              cssTransitionsComplete = true;
              checkComplete();
            }
          }, 0);
        }, options.delay || 0);
      };
    }

    var createTransitions$1 = createTransitions;

    var getComputedStyle$1 = win && win.getComputedStyle;
    var resolved = Promise.resolve();

    var names = {
      t0: 'intro-outro',
      t1: 'intro',
      t2: 'outro'
    };

    var Transition = function Transition(options) {
      this.owner = options.owner || options.up.owner || findElement(options.up);
      this.element = this.owner.attributeByName ? this.owner : findElement(options.up);
      this.ractive = this.owner.ractive;
      this.template = options.template;
      this.up = options.up;
      this.options = options;
      this.onComplete = [];
    };
    var Transition__proto__ = Transition.prototype;

    Transition__proto__.animateStyle = function animateStyle (style, value, options) {
        var this$1 = this;

      if (arguments.length === 4) {
        throw new Error(
          't.animateStyle() returns a promise - use .then() instead of passing a callback'
        );
      }

      // Special case - page isn't visible. Don't animate anything, because
      // that way you'll never get CSS transitionend events
      if (!visible) {
        this.setStyle(style, value);
        return resolved;
      }

      var to;

      if (isString(style)) {
        to = {};
        to[style] = value;
      } else {
        to = style;

        // shuffle arguments
        options = value;
      }

      return new Promise(function (fulfil) {
        // Edge case - if duration is zero, set style synchronously and complete
        if (!options.duration) {
          this$1.setStyle(to);
          fulfil();
          return;
        }

        // Get a list of the properties we're animating
        var propertyNames = keys(to);
        var changedProperties = [];

        // Store the current styles
        var computedStyle = getComputedStyle$1(this$1.node);

        var i = propertyNames.length;
        while (i--) {
          var prop = propertyNames[i];
          var name = prefix$1(prop);

          var current = computedStyle[prefix$1(prop)];

          // record the starting points
          var init = this$1.node.style[name];
          if (!(name in this$1.originals)) { this$1.originals[name] = this$1.node.style[name]; }
          this$1.node.style[name] = to[prop];
          this$1.targets[name] = this$1.node.style[name];
          this$1.node.style[name] = init;

          // we need to know if we're actually changing anything
          if (current != to[prop]) {
            // use != instead of !==, so we can compare strings with numbers
            changedProperties.push(name);

            // if we happened to prefix, make sure there is a properly prefixed value
            to[name] = to[prop];

            // make the computed style explicit, so we can animate where
            // e.g. height='auto'
            this$1.node.style[name] = current;
          }
        }

        // If we're not actually changing anything, the transitionend event
        // will never fire! So we complete early
        if (!changedProperties.length) {
          fulfil();
          return;
        }

        createTransitions$1(this$1, to, options, changedProperties, fulfil);
      });
    };

    Transition__proto__.bind = function bind () {
      var options = this.options;
      var type = options.template && options.template.v;
      if (type) {
        if (type === 't0' || type === 't1') { this.element.intro = this; }
        if (type === 't0' || type === 't2') { this.element.outro = this; }
        this.eventName = names[type];
      }

      var ractive = this.owner.ractive;

      this.name = options.name || options.template.n;

      if (options.params) {
        this.params = options.params;
      }

      if (isFunction(this.name)) {
        this._fn = this.name;
        this.name = this._fn.name;
      } else {
        this._fn = findInViewHierarchy('transitions', ractive, this.name);
      }

      if (!this._fn) {
        warnOnceIfDebug(missingPlugin(this.name, 'transition'), { ractive: ractive });
      }

      setupArgsFn(this, options.template);
    };

    Transition__proto__.getParams = function getParams () {
      if (this.params) { return this.params; }

      // get expression args if supplied
      if (this.fn) {
        var values = resolveArgs(this, this.template, this.up).map(function (model) {
          if (!model) { return undefined; }

          return model.get();
        });
        return this.fn.apply(this.ractive, values);
      }
    };

    Transition__proto__.getStyle = function getStyle (props) {
      var computedStyle = getComputedStyle$1(this.node);

      if (isString(props)) {
        return computedStyle[prefix$1(props)];
      }

      if (!isArray(props)) {
        throw new Error(
          'Transition$getStyle must be passed a string, or an array of strings representing CSS properties'
        );
      }

      var styles = {};

      var i = props.length;
      while (i--) {
        var prop = props[i];
        var value = computedStyle[prefix$1(prop)];

        if (value === '0px') { value = 0; }
        styles[prop] = value;
      }

      return styles;
    };

    Transition__proto__.processParams = function processParams (params, defaults) {
      if (isNumber(params)) {
        params = { duration: params };
      } else if (isString(params)) {
        if (params === 'slow') {
          params = { duration: 600 };
        } else if (params === 'fast') {
          params = { duration: 200 };
        } else {
          params = { duration: 400 };
        }
      } else if (!params) {
        params = {};
      }

      return assign({}, defaults, params);
    };

    Transition__proto__.registerCompleteHandler = function registerCompleteHandler (fn) {
      addToArray(this.onComplete, fn);
    };

    Transition__proto__.setStyle = function setStyle (style, value) {
        var this$1 = this;

      if (isString(style)) {
        var name = prefix$1(style);
        if (!hasOwn(this.originals, name)) { this.originals[name] = this.node.style[name]; }
        this.node.style[name] = value;
        this.targets[name] = this.node.style[name];
      } else {
        var prop;
        for (prop in style) {
          if (hasOwn(style, prop)) {
            this$1.setStyle(prop, style[prop]);
          }
        }
      }

      return this;
    };

    Transition__proto__.shouldFire = function shouldFire (type) {
      if (!this.ractive.transitionsEnabled) { return false; }

      // check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively
      if (type === 'intro' && this.ractive.rendering && nearestProp('noIntro', this.ractive, true))
        { return false; }
      if (type === 'outro' && this.ractive.unrendering && nearestProp('noOutro', this.ractive, false))
        { return false; }

      var params = this.getParams(); // this is an array, the params object should be the first member
      // if there's not a parent element, this can't be nested, so roll on
      if (!this.element.parent) { return true; }

      // if there is a local param, it takes precedent
      if (params && params[0] && isObject(params[0]) && 'nested' in params[0]) {
        if (params[0].nested !== false) { return true; }
      } else {
        // use the nearest instance setting
        // find the nearest instance that actually has a nested setting
        if (nearestProp('nestedTransitions', this.ractive) !== false) { return true; }
      }

      // check to see if this is actually a nested transition
      var el = this.element.parent;
      while (el) {
        if (el[type] && el[type].starting) { return false; }
        el = el.parent;
      }

      return true;
    };

    Transition__proto__.start = function start () {
        var this$1 = this;

      var node = (this.node = this.element.node);
      var originals = (this.originals = {}); //= node.getAttribute( 'style' );
      var targets = (this.targets = {});

      var completed;
      var args = this.getParams();

      // create t.complete() - we don't want this on the prototype,
      // because we don't want `this` silliness when passing it as
      // an argument
      this.complete = function (noReset) {
        this$1.starting = false;
        if (completed) {
          return;
        }

        this$1.onComplete.forEach(function (fn) { return fn(); });
        if (!noReset && this$1.isIntro) {
          for (var k in targets) {
            if (node.style[k] === targets[k]) { node.style[k] = originals[k]; }
          }
        }

        this$1._manager.remove(this$1);

        completed = true;
      };

      // If the transition function doesn't exist, abort
      if (!this._fn) {
        this.complete();
        return;
      }

      var promise = this._fn.apply(this.ractive, [this].concat(args));
      if (promise) { promise.then(this.complete); }
    };

    Transition__proto__.toString = function toString () {
      return '';
    };

    Transition__proto__.unbind = function unbind () {
      if (!this.element.attributes || !this.element.attributes.unbinding) {
        var type = this.options && this.options.template && this.options.template.v;
        if (type === 't0' || type === 't1') { this.element.intro = null; }
        if (type === 't0' || type === 't2') { this.element.outro = null; }
      }
    };

    Transition__proto__.unregisterCompleteHandler = function unregisterCompleteHandler (fn) {
      removeFromArray(this.onComplete, fn);
    };

    var proto$8 = Transition.prototype;
    proto$8.destroyed = proto$8.firstNode = proto$8.rebound = proto$8.render = proto$8.unrender = proto$8.update = noop;

    function nearestProp(prop, ractive, rendering) {
      var instance = ractive;
      while (instance) {
        if (
          hasOwn(instance, prop) &&
          (isUndefined(rendering) || rendering ? instance.rendering : instance.unrendering)
        )
          { return instance[prop]; }
        instance = instance.component && instance.component.ractive;
      }

      return ractive[prop];
    }

    var elementCache = {};

    var ieBug;
    var ieBlacklist;

    try {
      createElement('table').innerHTML = 'foo';
    } catch (/* istanbul ignore next */ err) {
      ieBug = true;

      ieBlacklist = {
        TABLE: ['<table class="x">', '</table>'],
        THEAD: ['<table><thead class="x">', '</thead></table>'],
        TBODY: ['<table><tbody class="x">', '</tbody></table>'],
        TR: ['<table><tr class="x">', '</tr></table>'],
        SELECT: ['<select class="x">', '</select>']
      };
    }

    function insertHtml(html$$1, node) {
      var nodes = [];

      // render 0 and false
      if (html$$1 == null || html$$1 === '') { return nodes; }

      var container;
      var wrapper;
      var selectedOption;

      /* istanbul ignore if */
      if (ieBug && (wrapper = ieBlacklist[node.tagName])) {
        container = element('DIV');
        container.innerHTML = wrapper[0] + html$$1 + wrapper[1];
        container = container.querySelector('.x');

        if (container.tagName === 'SELECT') {
          selectedOption = container.options[container.selectedIndex];
        }
      } else if (node.namespaceURI === svg$1) {
        container = element('DIV');
        container.innerHTML = '<svg class="x">' + html$$1 + '</svg>';
        container = container.querySelector('.x');
      } else if (node.tagName === 'TEXTAREA') {
        container = createElement('div');

        if (typeof container.textContent !== 'undefined') {
          container.textContent = html$$1;
        } else {
          container.innerHTML = html$$1;
        }
      } else {
        container = element(node.tagName);
        container.innerHTML = html$$1;

        if (container.tagName === 'SELECT') {
          selectedOption = container.options[container.selectedIndex];
        }
      }

      var child;
      while ((child = container.firstChild)) {
        nodes.push(child);
        container.removeChild(child);
      }

      // This is really annoying. Extracting <option> nodes from the
      // temporary container <select> causes the remaining ones to
      // become selected. So now we have to deselect them. IE8, you
      // amaze me. You really do
      // ...and now Chrome too
      var i;
      if (node.tagName === 'SELECT') {
        i = nodes.length;
        while (i--) {
          if (nodes[i] !== selectedOption) {
            nodes[i].selected = false;
          }
        }
      }

      return nodes;
    }

    function element(tagName) {
      return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));
    }

    var Triple = (function (Mustache) {
      function Triple(options) {
        Mustache.call(this, options);
      }

      if ( Mustache ) Triple.__proto__ = Mustache;
      var Triple__proto__ = Triple.prototype = Object.create( Mustache && Mustache.prototype );
      Triple__proto__.constructor = Triple;

      Triple__proto__.detach = function detach () {
        var docFrag = createDocumentFragment();
        if (this.nodes) { this.nodes.forEach(function (node) { return docFrag.appendChild(node); }); }
        return docFrag;
      };

      Triple__proto__.find = function find (selector) {
        var this$1 = this;

        var len = this.nodes.length;
        var i;

        for (i = 0; i < len; i += 1) {
          var node = this$1.nodes[i];

          if (node.nodeType !== 1) { continue; }

          if (matches(node, selector)) { return node; }

          var queryResult = node.querySelector(selector);
          if (queryResult) { return queryResult; }
        }

        return null;
      };

      Triple__proto__.findAll = function findAll (selector, options) {
        var this$1 = this;

        var result = options.result;
        var len = this.nodes.length;
        var i;

        for (i = 0; i < len; i += 1) {
          var node = this$1.nodes[i];

          if (node.nodeType !== 1) { continue; }

          if (matches(node, selector)) { result.push(node); }

          var queryAllResult = node.querySelectorAll(selector);
          if (queryAllResult) {
            result.push.apply(result, queryAllResult);
          }
        }
      };

      Triple__proto__.findComponent = function findComponent () {
        return null;
      };

      Triple__proto__.firstNode = function firstNode () {
        return this.rendered && this.nodes[0];
      };

      Triple__proto__.render = function render (target, occupants, anchor) {
        var this$1 = this;

        if (!this.nodes) {
          var html = this.model ? this.model.get() : '';
          this.nodes = insertHtml(html, target);
        }

        var nodes = this.nodes;

        // progressive enhancement
        if (occupants) {
          var i = -1;
          var next;

          // start with the first node that should be rendered
          while (occupants.length && (next = this.nodes[i + 1])) {
            var n = (void 0);
            // look through the occupants until a matching node is found
            while ((n = occupants.shift())) {
              var t = n.nodeType;

              if (
                t === next.nodeType &&
                ((t === 1 && n.outerHTML === next.outerHTML) ||
                  ((t === 3 || t === 8) && n.nodeValue === next.nodeValue))
              ) {
                this$1.nodes.splice(++i, 1, n); // replace the generated node with the existing one
                break;
              } else {
                target.removeChild(n); // remove the non-matching existing node
              }
            }
          }

          if (i >= 0) {
            // update the list of remaining nodes to attach, excluding any that were replaced by existing nodes
            nodes = this.nodes.slice(i);
          }

          // update the anchor to be the next occupant
          if (occupants.length) { anchor = occupants[0]; }
        }

        // attach any remainging nodes to the parent
        if (nodes.length) {
          var frag = createDocumentFragment();
          nodes.forEach(function (n) { return frag.appendChild(n); });

          if (anchor) {
            target.insertBefore(frag, anchor);
          } else {
            target.appendChild(frag);
          }
        }

        this.rendered = true;
      };

      Triple__proto__.toString = function toString () {
        var value = this.model && this.model.get();
        value = value != null ? '' + value : '';

        return inAttribute() ? decodeCharacterReferences(value) : value;
      };

      Triple__proto__.unrender = function unrender () {
        if (this.nodes)
          { this.nodes.forEach(function (node) {
            // defer detachment until all relevant outros are done
            runloop.detachWhenReady({
              node: node,
              detach: function detach() {
                detachNode(node);
              }
            });
          }); }
        this.rendered = false;
        this.nodes = null;
      };

      Triple__proto__.update = function update () {
        if (this.rendered && this.dirty) {
          this.dirty = false;

          this.unrender();
          this.render(this.up.findParentNode(), null, this.up.findNextNode(this));
        } else {
          // make sure to reset the dirty flag even if not rendered
          this.dirty = false;
        }
      };

      return Triple;
    }(Mustache));

    // finds the component constructor in the registry or view hierarchy registries
    function getComponentConstructor(ractive, name) {
      var instance = findInstance('components', ractive, name);
      var Component;

      if (instance) {
        Component = instance.components[name];

        if (Component && !Component.isInstance) {
          if (Component.default && Component.default.isInstance) { Component = Component.default; }
          else if (!Component.then && isFunction(Component)) {
            // function option, execute and store for reset
            var fn = Component.bind(instance);
            fn.isOwner = hasOwn(instance.components, name);
            Component = fn();

            if (!Component) {
              warnIfDebug(noRegistryFunctionReturn, name, 'component', 'component', {
                ractive: ractive
              });
              return;
            }

            if (isString(Component)) {
              // allow string lookup
              Component = getComponentConstructor(ractive, Component);
            }

            Component._fn = fn;
            instance.components[name] = Component;
          }
        }
      }

      return Component;
    }

    function asyncProxy(promise, options) {
      var partials = options.template.p || {};
      var name = options.template.e;

      var opts = assign({}, options, {
        template: { t: ELEMENT, e: name },
        macro: function macro(handle) {
          handle.setTemplate(partials['async-loading'] || []);
          promise.then(
            function (cmp) {
              options.up.ractive.components[name] = cmp;
              if (partials['async-loaded']) {
                handle.partials.component = [options.template];
                handle.setTemplate(partials['async-loaded']);
              } else {
                handle.setTemplate([options.template]);
              }
            },
            function (err) {
              if (partials['async-failed']) {
                handle.aliasLocal('error', 'error');
                handle.set('@local.error', err);
                handle.setTemplate(partials['async-failed']);
              } else {
                handle.setTemplate([]);
              }
            }
          );
        }
      });
      return new Partial(opts);
    }

    function extract(tpl, type, name) {
      var p = tpl.f.find(function (s) { return s.t === type; });
      if (p) {
        if (p.n)
          { return [
            {
              t: 19,
              n: 54,
              f: p.f || [],
              z: [{ n: p.n, x: { r: ("__await." + name) } }]
            }
          ]; }
        else { return p.f || []; }
      } else { return []; }
    }

    function Await(options) {
      var tpl = options.template;

      var success = extract(tpl, THEN, 'value');
      var error = extract(tpl, CATCH, 'error');
      var pending = extract(tpl, SECTION);
      var undef = extract(tpl, ELSE);

      var opts = assign({}, options, {
        template: {
          t: ELEMENT,
          m: [
            {
              t: ATTRIBUTE,
              n: 'for',
              f: [{ t: INTERPOLATOR, r: tpl.r, rx: tpl.rx, x: tpl.x }]
            }
          ]
        },
        macro: function macro(handle, attrs) {
          handle.aliasLocal('__await');

          function update(attrs) {
            if (attrs.for && isFunction(attrs.for.then)) {
              handle.setTemplate(pending);

              attrs.for.then(
                function (v) {
                  handle.set('@local.value', v);
                  handle.setTemplate(success);
                },
                function (e) {
                  handle.set('@local.error', e);
                  handle.setTemplate(error);
                }
              );
            } else if (isUndefined(attrs.for)) {
              handle.setTemplate(undef);
            } else {
              handle.set('@local.value', attrs.for);
              handle.setTemplate(success);
            }
          }

          update(attrs);

          return {
            update: update
          };
        }
      });

      opts.macro.attributes = ['for'];

      return new Partial(opts);
    }

    var constructors = {};
    constructors[ALIAS] = Section;
    constructors[ANCHOR] = Component;
    constructors[AWAIT] = Await;
    constructors[DOCTYPE] = Doctype;
    constructors[INTERPOLATOR] = Interpolator;
    constructors[PARTIAL] = Partial;
    constructors[SECTION] = Section;
    constructors[TRIPLE] = Triple;
    constructors[YIELDER] = Partial;

    constructors[ATTRIBUTE] = Attribute;
    constructors[BINDING_FLAG] = BindingFlag;
    constructors[DECORATOR] = Decorator;
    constructors[EVENT] = EventDirective;
    constructors[TRANSITION] = Transition;
    constructors[COMMENT] = Comment;

    var specialElements = {
      doctype: Doctype,
      form: Form,
      input: Input,
      option: Option,
      select: Select,
      textarea: Textarea
    };

    function createItem(options) {
      if (isString(options.template)) {
        return new Text(options);
      }

      var ctor;
      var name;
      var type = options.template.t;

      if (type === ELEMENT) {
        name = options.template.e;

        // could be a macro partial
        ctor = findInstance('partials', options.up.ractive, name);
        if (ctor) {
          ctor = ctor.partials[name];
          if (ctor.styleSet) {
            options.macro = ctor;
            return new Partial(options);
          }
        }

        // could be component or element
        ctor = getComponentConstructor(options.up.ractive, name);
        if (ctor) {
          if (isFunction(ctor.then)) {
            return asyncProxy(ctor, options);
          } else if (isFunction(ctor)) {
            return new Component(options, ctor);
          }
        }

        ctor = specialElements[name.toLowerCase()] || Element;
        return new ctor(options);
      }

      var Item;

      // component mappings are a special case of attribute
      if (type === ATTRIBUTE) {
        var el = options.owner;
        if (!el || (el.type !== ANCHOR && el.type !== COMPONENT && el.type !== ELEMENT)) {
          el = findElement(options.up);
        }
        options.element = el;

        Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;
      } else {
        Item = constructors[type];
      }

      if (!Item) { throw new Error(("Unrecognised item type " + type)); }

      return new Item(options);
    }

    // TODO all this code needs to die
    function processItems(items, values, guid, counter) {
      if ( counter === void 0 ) counter = 0;

      return items
        .map(function (item) {
          if (item.type === TEXT) {
            return item.template;
          }

          if (item.fragment) {
            if (item.fragment.iterations) {
              return item.fragment.iterations
                .map(function (fragment) {
                  return processItems(fragment.items, values, guid, counter);
                })
                .join('');
            } else {
              return processItems(item.fragment.items, values, guid, counter);
            }
          }

          var placeholderId = guid + "-" + (counter++);
          var model = item.model || item.newModel;

          values[placeholderId] = model
            ? model.wrapper
              ? model.wrapperValue
              : model.get()
            : undefined;

          return '${' + placeholderId + '}';
        })
        .join('');
    }

    function resolveAliases(aliases, fragment, dest) {
      if ( dest === void 0 ) dest = {};

      for (var i = 0; i < aliases.length; i++) {
        if (!dest[aliases[i].n]) {
          var m = resolve(fragment, aliases[i].x);
          dest[aliases[i].n] = m;
          m.reference();
        }
      }

      return dest;
    }

    var Fragment = function Fragment(options) {
      this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute

      this.isRoot = !options.owner.up;
      this.parent = this.isRoot ? null : this.owner.up;
      this.ractive = options.ractive || (this.isRoot ? options.owner : this.parent.ractive);

      this.componentParent =
        this.isRoot && this.ractive.component
          ? this.ractive.component.up
          : this.owner.containerFragment || null;
      if (!this.isRoot || this.ractive.delegate) {
        this.delegate = this.owner.containerFragment
          ? this.owner.containerFragment && this.owner.containerFragment.delegate
          : (this.componentParent && this.componentParent.delegate) ||
            (this.parent && this.parent.delegate);
      } else {
        this.delegate = false;
      }

      this.context = null;
      this.rendered = false;

      // encapsulated styles should be inherited until they get applied by an element
      if ('cssIds' in options) {
        this.cssIds = options.cssIds && options.cssIds.length && options.cssIds;
      } else {
        this.cssIds = this.parent ? this.parent.cssIds : null;
      }

      this.dirty = false;
      this.dirtyValue = true; // used for attribute values

      this.template = options.template || [];
      this.createItems();
    };
    var Fragment__proto__ = Fragment.prototype;

    Fragment__proto__.bind = function bind (context) {
        var this$1 = this;

      this.context = context;

      if (this.owner.template.z) {
        this.aliases = resolveAliases(
          this.owner.template.z,
          this.owner.containerFragment || this.parent
        );
      }

      var len = this.items.length;
      for (var i = 0; i < len; i++) { this$1.items[i].bind(); }
      this.bound = true;

      // in rare cases, a forced resolution (or similar) will cause the
      // fragment to be dirty before it's even finished binding. In those
      // cases we update immediately
      if (this.dirty) { this.update(); }

      return this;
    };

    Fragment__proto__.bubble = function bubble () {
      this.dirtyValue = true;

      if (!this.dirty) {
        this.dirty = true;

        if (this.isRoot) {
          // TODO encapsulate 'is component root, but not overall root' check?
          if (this.ractive.component) {
            this.ractive.component.bubble();
          } else if (this.bound) {
            runloop.addFragment(this);
          }
        } else {
          this.owner.bubble(this.index);
        }
      }
    };

    Fragment__proto__.createItems = function createItems () {
        var this$1 = this;

      // this is a hot code path
      var max = this.template.length;
      this.items = [];
      for (var i = 0; i < max; i++) {
        this$1.items[i] = createItem({
          up: this$1,
          template: this$1.template[i],
          index: i
        });
      }
    };

    Fragment__proto__.destroyed = function destroyed () {
        var this$1 = this;

      var len = this.items.length;
      for (var i = 0; i < len; i++) { this$1.items[i].destroyed(); }
      if (this.pathModel) { this.pathModel.destroyed(); }
      if (this.rootModel) { this.rootModel.destroyed(); }
    };

    Fragment__proto__.detach = function detach () {
      var docFrag = createDocumentFragment();
      var xs = this.items;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        docFrag.appendChild(xs[i].detach());
      }
      return docFrag;
    };

    Fragment__proto__.find = function find (selector, options) {
      return findMap(this.items, function (i) { return i.find(selector, options); });
    };

    Fragment__proto__.findAll = function findAll (selector, options) {
      if (this.items) {
        this.items.forEach(function (i) { return i.findAll && i.findAll(selector, options); });
      }
    };

    Fragment__proto__.findComponent = function findComponent (name, options) {
      return findMap(this.items, function (i) { return i.findComponent(name, options); });
    };

    Fragment__proto__.findAllComponents = function findAllComponents (name, options) {
      if (this.items) {
        this.items.forEach(function (i) { return i.findAllComponents && i.findAllComponents(name, options); });
      }
    };

    Fragment__proto__.findContext = function findContext () {
      var base = findParentWithContext(this);
      if (!base || !base.context) { return this.ractive.viewmodel; }
      else { return base.context; }
    };

    Fragment__proto__.findNextNode = function findNextNode (item) {
        var this$1 = this;

      // search for the next node going forward
      if (item) {
        var it;
        for (var i = item.index + 1; i < this.items.length; i++) {
          it = this$1.items[i];
          if (!it || !it.firstNode) { continue; }

          var node = it.firstNode(true);
          if (node) { return node; }
        }
      }

      // if this is the root fragment, and there are no more items,
      // it means we're at the end...
      if (this.isRoot) {
        if (this.ractive.component) {
          return this.ractive.component.up.findNextNode(this.ractive.component);
        }

        // TODO possible edge case with other content
        // appended to this.ractive.el?
        return null;
      }

      if (this.parent) { return this.owner.findNextNode(this); } // the argument is in case the parent is a RepeatedFragment
    };

    Fragment__proto__.findParentNode = function findParentNode () {
      var fragment = this;

      do {
        if (fragment.owner.type === ELEMENT) {
          return fragment.owner.node;
        }

        if (fragment.isRoot && !fragment.ractive.component) {
          // TODO encapsulate check
          return fragment.ractive.el;
        }

        if (fragment.owner.type === YIELDER) {
          fragment = fragment.owner.containerFragment;
        } else {
          fragment = fragment.componentParent || fragment.parent; // TODO ugh
        }
      } while (fragment);

      throw new Error('Could not find parent node'); // TODO link to issue tracker
    };

    Fragment__proto__.firstNode = function firstNode (skipParent) {
      var node = findMap(this.items, function (i) { return i.firstNode(true); });
      if (node) { return node; }
      if (skipParent) { return null; }

      return this.parent.findNextNode(this.owner);
    };

    Fragment__proto__.getKey = function getKey () {
      return this.keyModel || (this.keyModel = new KeyModel(this.key));
    };

    Fragment__proto__.getIndex = function getIndex () {
      return this.idxModel || (this.idxModel = new KeyModel(this.index));
    };

    Fragment__proto__.rebind = function rebind (next) {
      this.context = next;
      if (this.rootModel) { this.rootModel.context = this.context; }
      if (this.pathModel) { this.pathModel.context = this.context; }
    };

    Fragment__proto__.rebound = function rebound (update$$1) {
      if (this.owner.template.z) {
        var aliases = this.aliases;
        for (var k in aliases) {
          if (aliases[k].rebound) { aliases[k].rebound(update$$1); }
          else {
            aliases[k].unreference();
            aliases[k] = 0;
          }
        }

        resolveAliases(this.owner.template.z, this.owner.containerFragment || this.parent, aliases);
      }

      this.items.forEach(function (x) { return x.rebound(update$$1); });
      if (update$$1) {
        if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }
        if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }
      }
    };

    Fragment__proto__.render = function render (target, occupants) {
      if (this.rendered) { throw new Error('Fragment is already rendered!'); }
      this.rendered = true;

      var xs = this.items;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        xs[i].render(target, occupants);
      }
    };

    Fragment__proto__.resetTemplate = function resetTemplate (template) {
      var wasBound = this.bound;
      var wasRendered = this.rendered;

      // TODO ensure transitions are disabled globally during reset

      if (wasBound) {
        if (wasRendered) { this.unrender(true); }
        this.unbind();
      }

      this.template = template;
      this.createItems();

      if (wasBound) {
        this.bind(this.context);

        if (wasRendered) {
          var parentNode = this.findParentNode();
          var anchor = this.findNextNode();

          if (anchor) {
            var docFrag = createDocumentFragment();
            this.render(docFrag);
            parentNode.insertBefore(docFrag, anchor);
          } else {
            this.render(parentNode);
          }
        }
      }
    };

    Fragment__proto__.shuffled = function shuffled$3 () {
      this.items.forEach(shuffled);
      if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }
      if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }
    };

    Fragment__proto__.toString = function toString (escape) {
      return this.items.map(escape ? toEscapedString : toString$1).join('');
    };

    Fragment__proto__.unbind = function unbind (view) {
        var this$1 = this;

      if (this.owner.template.z && !this.owner.yielder) {
        for (var k in this$1.aliases) {
          this$1.aliases[k].unreference();
        }

        this.aliases = {};
      }

      this.context = null;
      var len = this.items.length;
      for (var i = 0; i < len; i++) { this$1.items[i].unbind(view); }
      this.bound = false;

      return this;
    };

    Fragment__proto__.unrender = function unrender (shouldDestroy) {
        var this$1 = this;

      var len = this.items.length;
      for (var i = 0; i < len; i++) { this$1.items[i].unrender(shouldDestroy); }
      this.rendered = false;
    };

    Fragment__proto__.update = function update () {
        var this$1 = this;

      if (this.dirty) {
        if (!this.updating) {
          this.dirty = false;
          this.updating = true;
          var len = this.items.length;
          for (var i = 0; i < len; i++) { this$1.items[i].update(); }
          this.updating = false;
        } else if (this.isRoot) {
          runloop.addFragmentToRoot(this);
        }
      }
    };

    Fragment__proto__.valueOf = function valueOf () {
      if (this.items.length === 1) {
        return this.items[0].valueOf();
      }

      if (this.dirtyValue) {
        var values = {};
        var source = processItems(this.items, values, this.ractive._guid);
        var parsed = parseJSON(source, values);

        this.value = parsed ? parsed.value : this.toString();

        this.dirtyValue = false;
      }

      return this.value;
    };
    Fragment.prototype.getContext = getContext;
    Fragment.prototype.getKeypath = getKeypath;

    function getKeypath(root) {
      var base = findParentWithContext(this);
      var model;
      if (root) {
        if (!this.rootModel) {
          this.rootModel = new KeyModel(
            this.context.getKeypath(this.ractive.root),
            this.context,
            this.ractive.root
          );
          model = this.rootModel;
        } else { return this.rootModel; }
      } else {
        if (!this.pathModel) {
          this.pathModel = new KeyModel(this.context.getKeypath(), this.context);
          model = this.pathModel;
        } else { return this.pathModel; }
      }

      if (base && base.context) { base.getKeypath(root).registerChild(model); }

      return model;
    }

    function initialise(ractive, userOptions, options) {
      // initialize settable computeds
      var computed = ractive.viewmodel.computed;
      if (computed) {
        for (var k in computed) {
          if (k in ractive.viewmodel.value && computed[k] && !computed[k].isReadonly) {
            computed[k].set(ractive.viewmodel.value[k]);
          }
        }
      }

      // init config from Parent and options
      config.init(ractive.constructor, ractive, userOptions);

      // call any passed in plugins
      if (isArray(userOptions.use))
        { ractive.use.apply(ractive, userOptions.use.filter(function (p) { return !p.construct; })); }

      hooks.config.fire(ractive);

      hooks.init.begin(ractive);

      var fragment = (ractive.fragment = createFragment$1(ractive, options));
      if (fragment) { fragment.bind(ractive.viewmodel); }

      hooks.init.end(ractive);

      // general config done, set up observers
      subscribe(ractive, userOptions, 'observe');

      if (fragment) {
        // render automatically ( if `el` is specified )
        var el = (ractive.el = ractive.target = getElement(ractive.el || ractive.target));
        if (el && !ractive.component) {
          var promise = ractive.render(el, ractive.append);

          if (Ractive.DEBUG_PROMISES) {
            promise.catch(function (err) {
              warnOnceIfDebug(
                'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;'
              );
              warnIfDebug('An error happened during rendering', { ractive: ractive });
              logIfDebug(err);

              throw err;
            });
          }
        }
      }
    }

    function createFragment$1(ractive, options) {
      if ( options === void 0 ) options = {};

      if (ractive.template) {
        var cssIds = [].concat(ractive.constructor._cssIds || [], options.cssIds || []);

        return new Fragment({
          owner: ractive,
          template: ractive.template,
          cssIds: cssIds
        });
      }
    }

    function render$1(ractive, target, anchor, occupants) {
      // set a flag to let any transitions know that this instance is currently rendering
      ractive.rendering = true;

      var promise = runloop.start();
      runloop.scheduleTask(function () { return hooks.render.fire(ractive); }, true);

      if (ractive.fragment.rendered) {
        throw new Error(
          'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first'
        );
      }

      if (ractive.destroyed) {
        ractive.destroyed = false;
        ractive.fragment = createFragment$1(ractive).bind(ractive.viewmodel);
      }

      anchor = getElement(anchor) || ractive.anchor;

      ractive.el = ractive.target = target;
      ractive.anchor = anchor;

      // ensure encapsulated CSS is up-to-date
      if (ractive.cssId) { applyCSS(); }

      if (target) {
        (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(ractive);

        if (anchor) {
          var docFrag = doc.createDocumentFragment();
          ractive.fragment.render(docFrag);
          target.insertBefore(docFrag, anchor);
        } else {
          ractive.fragment.render(target, occupants);
        }
      }

      runloop.end();
      ractive.rendering = false;

      return promise.then(function () {
        if (ractive.torndown) { return; }

        hooks.complete.fire(ractive);
      });
    }

    function Ractive$render(target, anchor) {
      if (this.torndown) {
        warnIfDebug('ractive.render() was called on a Ractive instance that was already torn down');
        return Promise.resolve();
      }

      target = getElement(target) || this.el;

      if (!this.append && target) {
        // Teardown any existing instances *before* trying to set up the new one -
        // avoids certain weird bugs
        var others = target.__ractive_instances__;
        if (others) { others.forEach(teardown); }

        // make sure we are the only occupants
        if (!this.enhance) {
          target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive
        }
      }

      var occupants = this.enhance ? toArray(target.childNodes) : null;
      var promise = render$1(this, target, anchor, occupants);

      if (occupants) {
        while (occupants.length) { target.removeChild(occupants.pop()); }
      }

      return promise;
    }

    var shouldRerender = ['template', 'partials', 'components', 'decorators', 'events'];

    function Ractive$reset(data) {
      data = data || {};

      if (!isObjectType(data)) {
        throw new Error('The reset method takes either no arguments, or an object containing new data');
      }

      // TEMP need to tidy this up
      data = dataConfigurator.init(this.constructor, this, { data: data });

      var promise = runloop.start();

      // If the root object is wrapped, try and use the wrapper's reset value
      var wrapper = this.viewmodel.wrapper;
      if (wrapper && wrapper.reset) {
        if (wrapper.reset(data) === false) {
          // reset was rejected, we need to replace the object
          this.viewmodel.set(data);
        }
      } else {
        this.viewmodel.set(data);
      }

      // reset config items and track if need to rerender
      var changes = config.reset(this);
      var rerender;

      var i = changes.length;
      while (i--) {
        if (shouldRerender.indexOf(changes[i]) > -1) {
          rerender = true;
          break;
        }
      }

      if (rerender) {
        hooks.unrender.fire(this);
        this.fragment.resetTemplate(this.template);
        hooks.render.fire(this);
        hooks.complete.fire(this);
      }

      runloop.end();

      hooks.reset.fire(this, data);

      return promise;
    }

    function collect$1(source, name, attr, dest) {
      source.forEach(function (item) {
        // queue to rerender if the item is a partial and the current name matches
        if (item.type === PARTIAL && (item.refName === name || item.name === name)) {
          item.inAttribute = attr;
          dest.push(item);
          return; // go no further
        }

        // if it has a fragment, process its items
        if (item.fragment) {
          collect$1(item.fragment.iterations || item.fragment.items, name, attr, dest);
        } else if (isArray(item.items)) {
          // or if it is itself a fragment, process its items
          collect$1(item.items, name, attr, dest);
        } else if (item.type === COMPONENT && item.instance) {
          // or if it is a component, step in and process its items
          // ...unless the partial is shadowed
          if (item.instance.partials[name]) { return; }
          collect$1(item.instance.fragment.items, name, attr, dest);
        }

        // if the item is an element, process its attributes too
        if (item.type === ELEMENT) {
          if (isArray(item.attributes)) {
            collect$1(item.attributes, name, true, dest);
          }
        }
      });
    }

    function resetPartial(name, partial) {
      var collection = [];
      collect$1(this.fragment.items, name, false, collection);

      var promise = runloop.start();

      this.partials[name] = partial;
      collection.forEach(handleChange);

      runloop.end();

      return promise;
    }

    // TODO should resetTemplate be asynchronous? i.e. should it be a case
    // of outro, update template, intro? I reckon probably not, since that
    // could be achieved with unrender-resetTemplate-render. Also, it should
    // conceptually be similar to resetPartial, which couldn't be async

    function Ractive$resetTemplate(template) {
      templateConfigurator.init(null, this, { template: template });

      var transitionsEnabled = this.transitionsEnabled;
      this.transitionsEnabled = false;

      // Is this is a component, we need to set the `shouldDestroy`
      // flag, otherwise it will assume by default that a parent node
      // will be detached, and therefore it doesn't need to bother
      // detaching its own nodes
      var component = this.component;
      if (component) { component.shouldDestroy = true; }
      this.unrender();
      if (component) { component.shouldDestroy = false; }

      var promise = runloop.start();

      // remove existing fragment and create new one
      this.fragment.unbind().unrender(true);

      this.fragment = new Fragment({
        template: this.template,
        root: this,
        owner: this
      });

      var docFrag = createDocumentFragment();
      this.fragment.bind(this.viewmodel).render(docFrag);

      // if this is a component, its el may not be valid, so find a
      // target based on the component container
      if (component && !component.external) {
        this.fragment.findParentNode().insertBefore(docFrag, component.findNextNode());
      } else {
        this.el.insertBefore(docFrag, this.anchor);
      }

      runloop.end();

      this.transitionsEnabled = transitionsEnabled;

      return promise;
    }

    var reverse = makeArrayMethod('reverse').path;

    function Ractive$set(keypath, value, options) {
      var ractive = this;

      var opts = isObjectType(keypath) ? value : options;

      return set(build(ractive, keypath, value, opts && opts.isolated), opts);
    }

    var shift = makeArrayMethod('shift').path;

    var sort = makeArrayMethod('sort').path;

    var splice = makeArrayMethod('splice').path;

    function Ractive$subtract(keypath, d, options) {
      var num = isNumber(d) ? -d : -1;
      var opts = isObjectType(d) ? d : options;
      return add(this, keypath, num, opts);
    }

    function Ractive$toggle(keypath, options) {
      if (!isString(keypath)) {
        throw new TypeError(badArguments);
      }

      return set(
        gather(this, keypath, null, options && options.isolated).map(function (m) { return [m, !m.get()]; }),
        options
      );
    }

    function Ractive$toCSS() {
      var cssIds = [this.cssId ].concat( this.findAllComponents().map(function (c) { return c.cssId; }));
      var uniqueCssIds = keys(cssIds.reduce(function (ids, id) { return (ids[id] = true, ids); }, {}));
      return getCSS(uniqueCssIds);
    }

    function Ractive$toHTML() {
      return this.fragment.toString(true);
    }

    function toText() {
      return this.fragment.toString(false);
    }

    function Ractive$transition(name, node, params) {
      if (node instanceof HTMLElement) ; else if (isObject(node)) {
        // omitted, use event node
        params = node;
      }

      // if we allow query selector, then it won't work
      // simple params like "fast"

      // else if ( typeof node === 'string' ) {
      // 	// query selector
      // 	node = this.find( node )
      // }

      node = node || this.event.node;

      if (!node || !node._ractive) {
        fatal(("No node was supplied for transition " + name));
      }

      params = params || {};
      var owner = node._ractive.proxy;
      var transition = new Transition({ owner: owner, up: owner.up, name: name, params: params });
      transition.bind();

      var promise = runloop.start();
      runloop.registerTransition(transition);
      runloop.end();

      promise.then(function () { return transition.unbind(); });
      return promise;
    }

    function unlink(here) {
      var promise = runloop.start();
      this.viewmodel.joinAll(splitKeypath(here), { lastLink: false }).unlink();
      runloop.end();
      return promise;
    }

    function Ractive$unrender() {
      if (!this.fragment.rendered) {
        warnIfDebug('ractive.unrender() was called on a Ractive instance that was not rendered');
        return Promise.resolve();
      }

      this.unrendering = true;
      var promise = runloop.start();

      hooks.unrendering.fire(this);

      // If this is a component, and the component isn't marked for destruction,
      // don't detach nodes from the DOM unnecessarily
      var shouldDestroy =
        !this.component ||
        (this.component.anchor || {}).shouldDestroy ||
        this.component.shouldDestroy ||
        this.shouldDestroy;
      this.fragment.unrender(shouldDestroy);
      if (shouldDestroy) { this.destroyed = true; }

      removeFromArray(this.el.__ractive_instances__, this);

      hooks.unrender.fire(this);

      runloop.end();
      this.unrendering = false;

      return promise;
    }

    var unshift = makeArrayMethod('unshift').path;

    function Ractive$updateModel(keypath, cascade) {
      var promise = runloop.start();

      if (!keypath) {
        this.viewmodel.updateFromBindings(true);
      } else {
        this.viewmodel.joinAll(splitKeypath(keypath)).updateFromBindings(cascade !== false);
      }

      runloop.end();

      return promise;
    }

    function use() {
      var this$1 = this;
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

      plugins.forEach(function (p) {
        p({
          proto: this$1,
          Ractive: this$1.constructor.Ractive,
          instance: this$1
        });
      });
      return this;
    }

    var proto$9 = {
      add: Ractive$add,
      animate: Ractive$animate,
      attachChild: attachChild,
      compute: Ractive$compute,
      detach: Ractive$detach,
      detachChild: detachChild,
      find: Ractive$find,
      findAll: Ractive$findAll,
      findAllComponents: Ractive$findAllComponents,
      findComponent: Ractive$findComponent,
      findContainer: Ractive$findContainer,
      findParent: Ractive$findParent,
      fire: Ractive$fire,
      get: Ractive$get,
      getLocalContext: getLocalContext,
      getContext: getContext$2,
      insert: Ractive$insert,
      link: link,
      observe: observe,
      observeOnce: observeOnce,
      off: Ractive$off,
      on: Ractive$on,
      once: Ractive$once,
      pop: pop,
      push: push,
      readLink: readLink,
      render: Ractive$render,
      reset: Ractive$reset,
      resetPartial: resetPartial,
      resetTemplate: Ractive$resetTemplate,
      reverse: reverse,
      set: Ractive$set,
      shift: shift,
      sort: sort,
      splice: splice,
      subtract: Ractive$subtract,
      teardown: Ractive$teardown,
      toggle: Ractive$toggle,
      toCSS: Ractive$toCSS,
      toCss: Ractive$toCSS,
      toHTML: Ractive$toHTML,
      toHtml: Ractive$toHTML,
      toText: toText,
      transition: Ractive$transition,
      unlink: unlink,
      unrender: Ractive$unrender,
      unshift: unshift,
      update: Ractive$update,
      updateModel: Ractive$updateModel,
      use: use
    };

    function isInstance(object) {
      return object && object instanceof this;
    }

    function styleGet(keypath, opts) {
      return this._cssModel.joinAll(splitKeypath(keypath)).get(true, opts);
    }

    var styles = [];

    function addStyle(id, css) {
      if (styles.find(function (s) { return s.id === id; }))
        { throw new Error(("Extra styles with the id '" + id + "' have already been added.")); }
      styles.push({ id: id, css: css });

      if (!this.css) {
        Object.defineProperty(this, 'css', { configurable: false, writable: false, value: buildCSS });
      }

      if (!this._cssDef) {
        Object.defineProperty(this, '_cssDef', {
          configurable: true,
          writable: false,
          value: {
            transform: false,
            id: 'Ractive.addStyle'
          }
        });

        addCSS(this._cssDef);
      }

      recomputeCSS(this);
      applyCSS(true);
    }

    function buildCSS(data) {
      return styles
        .map(function (s) { return "\n/* ---- extra style " + (s.id) + " */\n" + (isFunction(s.css) ? s.css(data) : s.css); })
        .join('');
    }

    function hasStyle(id) {
      return !!styles.find(function (s) { return s.id === id; });
    }

    function sharedSet(keypath, value, options) {
      var opts = isObjectType(keypath) ? value : options;
      var model = SharedModel$1;

      return set(build({ viewmodel: model }, keypath, value, true), opts);
    }

    function sharedGet(keypath, opts) {
      return SharedModel$1.joinAll(splitKeypath(keypath)).get(true, opts);
    }

    function use$1() {
      var this$1 = this;
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

      plugins.forEach(function (p) {
        isFunction(p) &&
          p({
            proto: this$1.prototype,
            Ractive: this$1.Ractive,
            instance: this$1
          });
      });
      return this;
    }

    var callsSuper = /super\s*\(|\.call\s*\(\s*this/;

    function extend() {
      var options = [], len = arguments.length;
      while ( len-- ) options[ len ] = arguments[ len ];

      if (!options.length) {
        return extendOne(this);
      } else {
        return options.reduce(extendOne, this);
      }
    }

    function extendWith(Class, options) {
      if ( options === void 0 ) options = {};

      return extendOne(this, options, Class);
    }

    function extendOne(Parent, options, Target) {
      if ( options === void 0 ) options = {};

      var proto;
      var Child = isFunction(Target) && Target;

      if (options.prototype instanceof Ractive) {
        throw new Error("Ractive no longer supports multiple inheritance.");
      }

      if (Child) {
        if (!(Child.prototype instanceof Parent)) {
          throw new Error(
            "Only classes that inherit the appropriate prototype may be used with extend"
          );
        }
        if (!callsSuper.test(Child.toString())) {
          throw new Error("Only classes that call super in their constructor may be used with extend");
        }

        proto = Child.prototype;
      } else {
        Child = function(options) {
          if (!(this instanceof Child)) { return new Child(options); }
          if (options && options.component === true) { return; }

          construct(this, options || {});
          initialise(this, options || {}, {});
        };

        proto = create(Parent.prototype);
        proto.constructor = Child;

        Child.prototype = proto;
      }

      // Static properties
      defineProperties(Child, {
        // alias prototype as defaults
        defaults: { value: proto },

        extend: { value: extend, writable: true, configurable: true },
        extendWith: { value: extendWith, writable: true, configurable: true },
        extensions: { value: [] },
        use: { value: use$1 },

        isInstance: { value: isInstance },

        Parent: { value: Parent },
        Ractive: { value: Ractive },

        styleGet: { value: styleGet.bind(Child), configurable: true },
        styleSet: { value: setCSSData.bind(Child), configurable: true }
      });

      // extend configuration
      config.extend(Parent, proto, options, Child);

      // store event and observer registries on the constructor when extending
      Child._on = (Parent._on || []).concat(toPairs(options.on));
      Child._observe = (Parent._observe || []).concat(toPairs(options.observe));

      Parent.extensions.push(Child);

      // attribute defs are not inherited, but they need to be stored
      if (options.attributes) {
        var attrs;

        // allow an array of optional props or an object with arrays for optional and required props
        if (isArray(options.attributes)) {
          attrs = { optional: options.attributes, required: [] };
        } else {
          attrs = options.attributes;
        }

        // make sure the requisite keys actually store arrays
        if (!isArray(attrs.required)) { attrs.required = []; }
        if (!isArray(attrs.optional)) { attrs.optional = []; }

        Child.attributes = attrs;
      }

      dataConfigurator.extend(Parent, proto, options, Child);

      defineProperty(Child, 'helpers', { writable: true, value: proto.helpers });

      if (isArray(options.use)) { Child.use.apply(Child, options.use); }

      return Child;
    }

    defineProperties(Ractive, {
      sharedGet: { value: sharedGet },
      sharedSet: { value: sharedSet },
      styleGet: { configurable: true, value: styleGet.bind(Ractive) },
      styleSet: { configurable: true, value: setCSSData.bind(Ractive) },
      addCSS: { configurable: false, value: addStyle.bind(Ractive) },
      hasCSS: { configurable: false, value: hasStyle.bind(Ractive) }
    });

    function macro(fn, opts) {
      if (!isFunction(fn)) { throw new Error("The macro must be a function"); }

      assign(fn, opts);

      defineProperties(fn, {
        extensions: { value: [] },
        _cssIds: { value: [] },
        cssData: { value: assign(create(this.cssData), fn.cssData || {}) },

        styleGet: { value: styleGet.bind(fn) },
        styleSet: { value: setCSSData.bind(fn) }
      });

      defineProperty(fn, '_cssModel', { value: new CSSModel(fn) });

      if (fn.css) { initCSS(fn, fn, fn); }

      this.extensions.push(fn);

      return fn;
    }

    function findPlugin(name, type, instance) {
      return findInViewHierarchy(type, instance, name);
    }

    function Ractive(options) {
      if (!(this instanceof Ractive)) { return new Ractive(options); }
      if (options && options.component) { return; }

      construct(this, options || {});
      initialise(this, options || {}, {});
    }

    // check to see if we're being asked to force Ractive as a global for some weird environments
    if (win && !win.Ractive) {
      var opts$1 = '';
      var script =
        document.currentScript ||
        /* istanbul ignore next */ document.querySelector('script[data-ractive-options]');

      if (script) { opts$1 = script.getAttribute('data-ractive-options') || ''; }

      /* istanbul ignore next */
      if (~opts$1.indexOf('ForceGlobal')) { win.Ractive = Ractive; }
    } else if (win) {
      warn("Ractive already appears to be loaded while loading 1.4.2.");
    }

    assign(Ractive.prototype, proto$9, defaults);
    Ractive.prototype.constructor = Ractive;

    // alias prototype as `defaults`
    Ractive.defaults = Ractive.prototype;

    // share defaults with the parser
    shared.defaults = Ractive.defaults;
    shared.Ractive = Ractive;

    // static properties
    defineProperties(Ractive, {
      // debug flag
      DEBUG: { writable: true, value: true },
      DEBUG_PROMISES: { writable: true, value: true },

      // static methods:
      extend: { value: extend },
      extendWith: { value: extendWith },
      escapeKey: { value: escapeKey },
      evalObjectString: { value: parseJSON },
      findPlugin: { value: findPlugin },
      getContext: { value: getContext$1 },
      getCSS: { value: getCSS },
      isInstance: { value: isInstance },
      joinKeys: { value: joinKeys },
      macro: { value: macro },
      normaliseKeypath: { value: normalise },
      parse: { value: parse },
      splitKeypath: { value: splitKeypath$1 },
      // sharedSet and styleSet are in _extend because circular refs
      unescapeKey: { value: unescapeKey },
      use: { value: use$1 },

      // support
      enhance: { writable: true, value: false },
      svg: { value: svg },
      tick: {
        get: function get() {
          return batch && batch.promise;
        }
      },

      // version
      VERSION: { value: '1.4.2' },

      // plugins
      adaptors: { writable: true, value: {} },
      components: { writable: true, value: {} },
      decorators: { writable: true, value: {} },
      easing: { writable: true, value: easing },
      events: { writable: true, value: {} },
      extensions: { value: [] },
      helpers: { writable: true, value: defaults.helpers },
      interpolators: { writable: true, value: interpolators },
      partials: { writable: true, value: {} },
      transitions: { writable: true, value: {} },

      // CSS variables
      cssData: { configurable: true, value: {} },
      perComponentStyleElements: { get: splitTag, set: splitTag },

      // access to @shared without an instance
      sharedData: { value: data$1 },

      // for getting the source Ractive lib from a constructor
      Ractive: { value: Ractive },

      // to allow extending contexts
      Context: { value: extern.Context.prototype }
    });

    // cssData must already be in place
    defineProperty(Ractive, '_cssModel', {
      configurable: true,
      value: new CSSModel(Ractive)
    });

    defineProperty(Ractive.prototype, 'rendered', {
      get: function get() {
        return this.fragment && this.fragment.rendered;
      }
    });

    const template = {v:4,t:[{t:7,e:"div",m:[{t:13,n:"class",f:"syntax-editor",g:1},{t:8,r:"extra-attributes"},{n:"class-shrinky",t:13,f:[{t:2,rx:{r:"~/",m:[{r:[],s:"\"no-fill\""}]}}]}],f:[{t:4,f:[{t:7,e:"div",m:[{t:13,n:"class",f:"line-nos",g:1}],f:[{t:4,f:[{t:2,r:"."},{t:7,e:"br"}],n:52,r:"~/lines"}]}],n:50,x:{r:["~/lines.length"],s:"_0>4"}}," ",{t:7,e:"div",m:[{t:13,n:"class",f:"editor-pane",g:1}],f:[{t:7,e:"code",m:[{t:13,n:"class",f:"ast-nodes",g:1}],f:[{t:7,e:"pre",f:[{t:8,r:"ast-node",c:{r:"ast"}},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"ast-fail",g:1}],f:[{t:2,x:{r:["src","ast.end","src.length"],s:"_0.substring(_1,_2)"}}]}],n:50,x:{r:["ast.end","src.length"],s:"_0<_1"}},{t:4,f:[" "],n:50,x:{r:["src.length","src"],s:"_0>0&&_1[_0-1]===\"\\n\""}}]}]}," ",{t:7,e:"textarea",m:[{n:"autosize",t:71},{n:"class-expr-text",t:13},{t:4,f:[{n:"id",f:"expr-text",t:13}],n:50,r:"primary"},{n:"spellcheck",f:"false",t:13},{n:["keydown"],t:70,f:{r:["@this","@event"],s:"[_0.keydown(_1)]"}},{n:["focus"],t:70,f:{r:["@this"],s:"[_0.highlightSyntax()]"}}],f:[{t:2,r:"src"}]}]}]}],e:{"\"no-fill\"":function (){return("no-fill");},"_0>4":function (_0){return(_0>4);},"_0.substring(_1,_2)":function (_0,_1,_2){return(_0.substring(_1,_2));},"_0<_1":function (_0,_1){return(_0<_1);},"_0>0&&_1[_0-1]===\"\\n\"":function (_0,_1){return(_0>0&&_1[_0-1]==="\n");},"[_0.keydown(_1)]":function (_0,_1){return([_0.keydown(_1)]);},"[_0.highlightSyntax()]":function (_0){return([_0.highlightSyntax()]);},"(_0||\"\").substring(_1,_2)":function (_0,_1,_2){return((_0||"").substring(_1,_2));}},p:{viewer:[{t:7,e:"div",m:[{t:13,n:"class",f:"syntax-editor",g:1},{t:8,r:"extra-attributes"}],f:[{t:7,e:"code",m:[{t:13,n:"class",f:"ast-nodes",g:1}],f:[{t:7,e:"pre",f:[{t:8,r:"ast-node",c:{r:"ast"}},{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"ast-fail",g:1}],f:[{t:2,x:{r:["src","ast.end","src.length"],s:"_0.substring(_1,_2)"}}]}],n:50,x:{r:["ast.end","src.length"],s:"_0<_1"}},{t:4,f:[" "],n:50,x:{r:["src.length","src"],s:"_0>0&&_1[_0-1]===\"\\n\""}}]}]}]}],"ast-node":[{t:7,e:"span",m:[{n:"class",f:[{t:2,r:".name"}],t:13}],f:[{t:4,f:[{t:4,f:[{t:4,f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"ast-extra",g:1}],f:[{t:2,x:{r:["~/src","./0","./1"],s:"(_0||\"\").substring(_1,_2)"}}]}],n:54,rx:{r:"^^/extra",m:[{t:30,n:"@index"}]}}],n:50,rx:{r:"^^/extra",m:[{t:30,n:"@index"}]}},{t:8,r:"ast-node"}],n:52,r:".children"},{t:4,f:[{t:4,f:[{t:7,e:"span",m:[{t:13,n:"class",f:"ast-extra",g:1}],f:[{t:2,x:{r:["~/src","./0","./1"],s:"(_0||\"\").substring(_1,_2)"}}]}],n:54,rx:{r:".extra",m:[{t:30,n:".children.length"}]}}],n:50,rx:{r:".extra",m:[{t:30,n:".children.length"}]}}],n:50,r:".children.length"},{t:4,f:[{t:2,x:{r:["~/src",".start",".end"],s:"(_0||\"\").substring(_1,_2)"}}],n:51,l:1}]}]}};
    const css = function(data) { return [(function () { return this.Ractive({ template: {v:4,t:[".syntax-editor { position: relative; color: ",{t:2,r:"@style.code.c1"},"; display: flex; } .syntax-editor:not(.shrinky) { min-height: 99% !important; } .syntax-editor > .line-nos { height: 100%; flex-grow: 0; flex-shrink: 0; font-family: monospace; font-size: 0.875rem !important; line-height: 1rem !important; padding: 0.5rem !important; color: ",{t:2,r:"@style.fg"},"; background-color: ",{t:2,r:"@style.border"},"; border-right: 1px solid ",{t:2,r:"@style.dark"},"; text-align: right; border: none !important; } .syntax-editor > .editor-pane { position: relative; flex-grow: 1; flex-shrink: 1; } .ast-extra { color: ",{t:2,r:"@style.code.c1"},"; } .comment { color: ",{t:2,r:"@style.code.c14"},"; } .syntax-editor textarea { position: absolute; top: 0; font-family: monospace; color: transparent !important; background: transparent !important; caret-color: ",{t:2,r:"@style.fg"},"; min-height: 99% !important; overflow: hidden; resize: none; margin: 0 !important; padding: 0.5rem !important; line-height: 1rem !important; font-size: 0.875rem !important; white-space: pre-wrap; word-break: break-all; border: none !important; } .syntax-editor code { padding: 0.5rem !important; font-family: monospace; display: block; box-sizing: border-box; min-height: 99% !important; overflow: hidden; line-height: 1rem !important; font-size: 0.875rem !important; min-height: 1.75rem !important; border: none !important; } .syntax-editor > .editor-pane > code > pre { word-break: break-all; white-space: pre-wrap; margin: 0 !important; padding: 0 !important; } .ast-nodes .reference { color: ",{t:2,r:"@style.code.c2"},"; font-weight: 500; } .ast-nodes .primitive, .ast-nodes .number, .ast-nodes .date, .ast-nides .timespan { color: ",{t:2,r:"@style.code.c3"},"; font-weight: 500; } .ast-nodes .format-op { color: ",{t:2,r:"@style.code.c4"},"; } .ast-nodes .string, .ast-nodes .string > .ast-extra { color: ",{t:2,r:"@style.code.c5"},"; } .ast-nodes .string > .string-interpolation { font-style: oblique; } .ast-nodes .binary-op > .ast-extra, .ast-nodes .conditional > .ast-extra { color: ",{t:2,r:"@style.code.c6"},"; } .ast-nodes .typelit, .ast-nodes .typelit > .ast-extra { color: ",{t:2,r:"@style.code.c7"},"; } .ast-nodes .typelit .type { color: ",{t:2,r:"@style.code.c9"},"; font-weight: 500; } .ast-nodes .typelit .key, .ast-nodes .typelit .literal { font-weight: 500; color: ",{t:2,r:"@style.code.c10"},"; } .ast-nodes .typelit .key { color: ",{t:2,r:"@style.code.c8"},"; } .ast-nodes .typelit .condition { font-weight: 700; } .ast-nodes .ast-fail { color: ",{t:2,r:"@style.code.c20"},"; } .ast-nodes .interpolator, .ast-nodes .each-block > .ast-extra, .ast-nodes .if-block > .ast-extra, .ast-nodes .unless-block > .ast-extra, .ast-nodes .case-block > .ast-extra, .ast-nodes .with-block > .ast-extra { font-weight: 600; } .ast-nodes .each-block > .ast-extra { color: ",{t:2,r:"@style.code.c11"},"; } .ast-nodes .case-block > .ast-extra, .ast-nodes .unless-block > .ast-extra, .ast-nodes .if-block > .ast-extra { color: ",{t:2,r:"@style.code.c12"},"; } .ast-nodes .with-block > .ast-extra { color: ",{t:2,r:"@style.code.c13"},"; } ",{t:2,x:{r:["extra"],s:"_0||\"\""}}],e:{"_0||\"\"":function (_0){return(_0||"");}}}, data: this.cssData }).fragment.toString(false); }).call(this)].join(' '); };

    function autosize(node) {
        const helper = node.cloneNode();
        helper.style.position = 'absolute';
        helper.style.left = '-110%';
        helper.style.zIndex = '-1';
        helper.style.height = '0.875rem';
        helper.style.fontSize = '0.875rem';
        helper.style.lineHeight = '0.875rem';
        helper.style.padding = '0.875rem';
        helper.style.wordBreak = 'break-all';
        helper.style.whiteSpace = 'pre-wrap';
        document.body.appendChild(helper);
        function resize() {
            const style = getComputedStyle(node);
            helper.style.boxSizing = style.boxSizing;
            helper.style.width = `${node.clientWidth}px`;
            helper.value = node.value;
            node.style.height = `${helper.scrollHeight + 8}px`;
        }
        function defer() {
            setTimeout(resize, 500);
        }
        node.addEventListener('focus', defer);
        node.addEventListener('input', defer);
        node.style.overflow = 'hidden';
        return {
            teardown() {
                helper.remove();
                node.removeEventListener('focus', defer);
                node.removeEventListener('input', defer);
            }
        };
    }

    function debounce(fn, time) {
        let tm;
        function wrapper(...args) {
            if (tm) {
                clearTimeout(tm);
            }
            tm = setTimeout(() => {
                tm = null;
                fn.apply(this, args);
            }, time);
        }
        return wrapper;
    }

    const notSpace = /[^\s]/;
    const initSpace = /^(\s*).*/;
    class Editor extends Ractive {
        constructor(opts) {
            super(opts);
        }
        highlightSyntax() {
            const expr = this.get('src') || '';
            if (typeof expr !== 'string')
                return;
            const parser = this.get('template') ? parse$3 : parse$4;
            const ast = parser(expr, { tree: true, compact: true });
            this.set('ast', ast);
            if (!this.rendered)
                return;
            const pre = this.find('pre');
            if (pre)
                this.set('lines', breakLines(expr, pre.clientWidth));
        }
        keydown(ev) {
            let key = ev.key;
            let shift = ev.shiftKey;
            if (key === 'Backspace') {
                const n = ev.target;
                const txt = n.value;
                if (n.selectionStart === n.selectionEnd) {
                    const idx = txt.lastIndexOf('\n', n.selectionStart - 1);
                    const str = txt.substring(idx > 0 ? idx + 1 : 0, n.selectionStart);
                    if (str && !notSpace.test(str) && str.length > 1) {
                        key = 'Tab';
                        shift = true;
                    }
                }
            }
            if (key === 'Home') {
                const n = ev.target;
                const txt = n.value;
                if (n.selectionStart) {
                    const idx = txt.lastIndexOf('\n', n.selectionStart - 1);
                    let line = txt.substring(idx > 0 ? idx + 1 : 0, n.selectionStart);
                    let space = line.replace(initSpace, '$1');
                    if (!line || notSpace.test(line)) {
                        if (!line) {
                            let nidx = line.indexOf('\n', idx);
                            if (!~nidx)
                                nidx = txt.length;
                            let i = n.selectionStart;
                            for (i; i < nidx; i++)
                                if (notSpace.test(txt[i]))
                                    break;
                            n.selectionStart = i;
                        }
                        else {
                            n.selectionStart = n.selectionStart - line.length + space.length;
                        }
                    }
                    else {
                        n.selectionStart = n.selectionStart - line.length;
                    }
                    if (!shift)
                        n.selectionEnd = n.selectionStart;
                    return false;
                }
            }
            else if (key === 'Tab') {
                const n = ev.target;
                let txt = n.value;
                let pos = [n.selectionStart, n.selectionEnd];
                let idx;
                if (pos[0] === pos[1]) {
                    idx = txt.lastIndexOf('\n', pos[0]);
                    if (this.get('tabout')) {
                        if (txt.length === 0)
                            return true;
                        if (!shift && notSpace.test(txt.substring(idx === -1 ? 0 : idx, pos[0])))
                            return true;
                    }
                    if (idx === pos[0])
                        idx = txt.lastIndexOf('\n', idx - 1);
                    if (idx === -1)
                        idx = 0;
                    else
                        idx += 1;
                    if (shift) {
                        if (txt.substr(idx, 2) === '  ') {
                            txt = txt.substring(0, idx) + txt.substr(idx + 2);
                            pos[0] = pos[0] - 2;
                            pos[1] = pos[1] - 2;
                        }
                    }
                    else {
                        txt = txt.substring(0, idx) + '  ' + txt.substr(idx);
                        pos[0] = pos[0] + 2;
                        pos[1] = pos[1] + 2;
                    }
                }
                else {
                    idx = txt.lastIndexOf('\n', n.selectionEnd);
                    if (idx === pos[0] && idx == pos[1])
                        idx = txt.lastIndexOf('\n', idx - 1);
                    for (; ~idx && idx > n.selectionStart;) {
                        if (shift) {
                            if (txt.substr(idx + 1, 2) === '  ') {
                                txt = txt.substring(0, idx + 1) + txt.substr(idx + 3);
                                pos[1] = pos[1] - 2;
                            }
                        }
                        else {
                            txt = txt.substring(0, idx + 1) + '  ' + txt.substr(idx + 1);
                            pos[1] = pos[1] + 2;
                        }
                        idx = txt.lastIndexOf('\n', idx - 1);
                    }
                    idx = txt.lastIndexOf('\n', n.selectionStart);
                    if (!~idx)
                        idx = 0;
                    else
                        idx += 1;
                    if (~idx) {
                        if (shift) {
                            if (txt.substr(idx, 2) === '  ') {
                                txt = txt.substring(0, idx) + txt.substr(idx + 2);
                                pos[0] = pos[0] - 2;
                                pos[1] = pos[1] - 2;
                            }
                        }
                        else {
                            txt = txt.substring(0, idx) + '  ' + txt.substr(idx);
                            pos[0] = pos[0] + 2;
                            pos[1] = pos[1] + 2;
                        }
                    }
                }
                n.value = txt;
                n.selectionStart = pos[0];
                n.selectionEnd = pos[1];
                n.dispatchEvent(new InputEvent('input'));
                n.dispatchEvent(new InputEvent('change'));
                return false;
            }
            else if (ev.key === 'Enter') {
                if (ev.ctrlKey) {
                    this.fire('run');
                    return false;
                }
                const n = ev.target;
                let txt = n.value;
                let pos = [n.selectionStart, n.selectionEnd];
                let idx = txt.lastIndexOf('\n', pos[0] - 1);
                const line = txt.substring(idx >= 0 ? idx + 1 : 0, pos[0]);
                const space = line.replace(initSpace, '$1');
                txt = txt.substr(0, pos[0]) + '\n' + space + txt.substr(pos[1]);
                n.value = txt;
                n.selectionStart = n.selectionEnd = pos[0] + space.length + 1;
                n.dispatchEvent(new InputEvent('input'));
                n.dispatchEvent(new InputEvent('change'));
                return false;
            }
        }
    }
    Ractive.extendWith(Editor, {
        template, css, cssId: 'raport-editor',
        on: {
            init() {
                this.observe('src template', debounce(function () {
                    this.highlightSyntax();
                }, 150));
            },
        },
        decorators: { autosize },
        attributes: ['src', 'template', 'tabout', 'primary', 'no-fill'],
    });
    class Viewer extends Ractive {
        constructor(opts) {
            super(opts);
        }
        highlightSyntax() {
            const expr = this.get('src') || '';
            if (typeof expr !== 'string')
                return;
            const parser = this.get('template') ? parse$3 : parse$4;
            const ast = parser(expr, { tree: true, compact: true });
            this.set('ast', ast);
            if (!this.rendered)
                return;
            const pre = this.find('pre');
            if (pre)
                this.set('lines', breakLines(expr, pre.clientWidth));
        }
    }
    Ractive.extendWith(Viewer, {
        template: { v: template.v, t: template.p.viewer }, cssId: 'raport-ast-view',
        css,
        cssData: {
            extra: `
      pre { margin: 0; white-space: pre-wrap; font-size: 0.875rem; }
      .syntax-editor code { padding: 0; flex-grow: 1; }
      .syntax-editor { max-height: 100%; overflow: auto; }
      .syntax-editor code { font-size: inherit; line-height: 1rem; }
      `,
        },
        partials: {
            'ast-node': template.p['ast-node'],
        },
        on: {
            init() {
                this.observe('src template', debounce(function () {
                    this.highlightSyntax();
                }, 350));
            },
        },
        attributes: ['src', 'template'],
    });
    function breakLines(src, width) {
        if (width < 16)
            return [];
        const char = 8.4;
        const count = width / char;
        const res = [];
        const lines = src.split('\n');
        for (let il = 0; il < lines.length; il++) {
            const l = lines[il];
            const base = l.length / count;
            let vert = Math.ceil(base);
            let factor = (width - Math.floor(width / char) * char) / char;
            if (factor < 0.2)
                factor = 0.5;
            vert = Math.ceil(base + (vert * factor) / count);
            res.push(il + 1);
            if (vert > 1)
                for (let i = 1; i < vert; i++)
                    res.push('');
        }
        return res;
    }
    const _highlight = new Ractive({ template: { v: template.v, t: [{ t: 8, r: 'ast-node', c: { r: 'ast' } }], p: { 'ast-node': template.p['ast-node'] } } });
    function highlight(src) {
        const ast = parse$4(src, { tree: true, compact: true });
        ast.name = 'ast-nodes';
        _highlight.set({ ast, src });
        return _highlight.toHTML();
    }

    const lasts = {};
    function getLastFocus(slot) {
        return lasts[slot || ''];
    }
    function trackfocus(node, slot) {
        function listen(ev) {
            const el = ev.target;
            if ('selectionStart' in el)
                lasts[slot || ''] = el;
        }
        node.addEventListener('focus', listen, { capture: true });
        return {
            teardown() { node.removeEventListener('focus', listen, { capture: true }); }
        };
    }

    const operators = `[
  { op:['%' 'modulus'] sig:[
    { bin:1 proto:'...any => number' desc:'Returns the modulus of the given values starting with the first.' }
  ]}
  { op:['*' 'multiply'] sig:[
    { bin:1 proto:'...number => number' desc:'Multiplies the given values starting with the first.

If there is context-local rounding set, it will be applied to the result (see set-defaults).' }
    { bin:1 proto:'(string, number) => string' desc:'Returns the given string copied number times if the number is positive.'}
    { bin:1 proto:'(any[], number) => any[]' desc:'Returns the given array concatenated number times if the array has fewer than 1,000 elements and the number is positive and less than 10,000.'}
  ]}
  { op:['**' 'pow'] sig:[
    { bin:1 proto:'...number => number' desc:'Applies exponentiation to the given arguments with right associativity.

If there is context-local rounding set, it will be applied to the result (see set-defaults).' eg:'(** 1 2 3) is 1^(2^3)'}
  ]}
  { op:['+' 'add'] sig:[
    { bin:1 proto:'...number => number' desc:'Adds the given numbers together.

If there is context-local rounding set, it will be applied to the result (see set-defaults).' }
    { bin:1 proto:'...any => string' desc:'Concatenates the given arguments as strings.' }
    { bin:1 proto:'...object => object' desc:'Creates a shallow copy comprised of each given object where overlapping keys in later arguments override keys in earlier arguments.' }
    { bin:1 proto:'...any[] => object' desc:'Creates a shallow copy comprised of each given array concatenated.' }
    { bin:1 proto:'(date, timespan) => date' desc:'Adds the given timespan to the given date.' }
    { bin:1 proto:'...timespan => timespan' desc:'Adds the given timespans together.' }
    { un:1 proto:'any => number' desc:'The unary + operator converts the given value to a number.' }
  ]}
  { op:['-' 'subtract'] sig:[
    { bin:1 proto:'...any => number' desc:'Subtracts the given values as numbers starting with the first.

If there is context-local rounding set, it will be applied to the result (see set-defaults).' }
    { bin:1 proto:'(date, date) => timespan' desc:'Subtracts the second date from the first, resulting in the timespan between the two dates.' }
    { bin:1 proto:'(date, timespan) => date' desc:'Subtracts the second date from the first, resulting in the timespan between the two dates.' }
    { un:1 proto:'any => number' desc:'The unary - operator converts the given value to a number and negates it.' }
  ]}
  { op:['/' 'divide'] sig:[
    { bin:1 proto:'...any => number' desc:'Divides the given values starting with the first.

If there is context-local rounding set, it will be applied to the result (see set-defaults).' }
  ]}
  { op:['/%' 'intdiv'] sig:[
    { bin:1 proto:'...any => number' desc:'Divides the given values with integer division starting with the first.'}
  ]}
  { op:['<' 'lt'] sig:[
    { bin:1 proto:'(any, any) => boolean' desc:'Returns true if the first value is less than the second.' }
  ]}
  { op:['<=' 'lte'] sig:[
    { bin:1 proto:'(any, any) => boolean' desc:'Returns true if the first value is less than or equal to the second.' }
  ]}
  { op:['==' 'is'] sig:[
    { bin:1 proto:'(any, any) => boolean' desc:'Returns true if the given values are equal (not strict).' }
    { bin:1 proto:'(any, schema) => boolean' desc:'(Only applies to the \\'is\\' alias) Returns true if the given value loosely conforms to the given schema.' }
  ]}
  { op:['!=' 'is-not'] sig:[
    { bin:1 proto:'(any, any) => boolean' desc:'Returns true if the given values are not equal (not strict).' }
    { bin:1 proto:'(any, schema) => boolean' desc:'(Only applies to the \\'is-not\\' alias) Returns true if the given value does not loosely conform to the given schema.' }
  ]}
  { op:['===' 'deep-is'] sig:[
    { bin:1 proto: '(any, any) => boolean' desc:'Do a deep equality check on the first two arguments using loose equality for primitives.' }
    { proto: "(any, any, 'strict'|'loose'|'sql'|application) => boolean" desc:'Do a deep equality check on the first two arguments using the comparison method specified by the third argument. If an application is given, it will be called with each item being checked at each step in the recursive check to determine equality.' }
  ] opts:[
    { name::equal type:"'strict'|'loose'|'sql'|(any, any) => boolaen" desc:'What type of equality check should be used to determine whether two values are different.

The strings strict (===), loose (==), and sql (loose plus numbers, dates, and booleans have special handling when they are or are compared to strings) will use a built-in equality check.' }
  ]}
  { op:['!==' 'deep-is-not'] sig:[
    { bin:1 proto: '(any, any) => boolean' desc:'Do a deep inequality check on the first two arguments using loose equality for primitives.' }
    { proto: "(any, any, 'strict'|'loose'|'sql'|application) => boolean" desc:'Do a deep inequality check on the first two arguments using the comparison method specified by the third argument. If an application is given, it will be called with each item being checked at each step in the recursive check to determine equality.' }
  ] opts:[
    { name::equal type:"'strict'|'loose'|'sql'|(any, any) => boolaen" desc:'What type of equality check should be used to determine whether two values are different.

The strings strict (===), loose (==), and sql (loose plus numbers, dates, and booleans have special handling when they are or are compared to strings) will use a built-in equality check.' }
  ]}
  { op:['>' 'gt'] sig:[
    { bin:1 proto: '(any, any) => boolean' desc:'Returns true if the first value is greater than the second value.' }
  ]}
  { op:['>=' 'gte'] sig:[
    { bin:1 proto: '(any, any) => boolean' desc:'Returns true if the first value is greater than or equal to the second value.' }
  ]}
  { op:'??' sig:[
    { bin:1 proto:'...any => any' desc:'Returns the first non-null, non-undefined value.'}
  ]}
  { op:['||' 'or'] sig:[
    { bin:1 proto: '(any, any) => any' desc:"Lazily evaluates its arguments and returns the first truthy value or \`false\` if there aren't any." }
  ]}
  { op:['&&' 'and'] sig:[
    { bin:1 proto: '(any, any) => any' desc:'Lazily evaluates its arguments and returns the final value or \`false\` if any of the values are not truthy.' }
  ]}
  { op:'abs' sig:[
    { proto:'number => number' desc:'Returns the absolute value of the given number.'}
  ]}
  { op:'array' sig:[
    { proto:'...any => any[]' desc:'Returns all of its arguments in an array.'}
    { proto: 'range => number[]' desc:'Convert a range to an array of numbers covered by the range. The maximum number of elements in the resulting array is 10,000, and the default bounds are -100 to 200.'}
  ] opts:[
    { name::range type::boolean desc:'Use the range prototype of the operator. Without this, even a parsed range will result in an array with the range as the only element.' }
    { name::bounds type:'[number, number]' desc:'Sets the lower and upper bounds, respectively, of the resulting array. If the bounds are more than 10,000 apart, the lower bound will be set to 10,000 less than the upper bound.' }
  ]}
  { op:'avg' sig:[
    { agg:1 proto: '() => number' desc:'Computes the average of the current source.' }
    { proto:'number[] => number' desc:'Computes the average of the given array of numbers.' }
    { proto:'(any[], application) => number' desc:'Computes the average of the applications for the given array of values.' }
    { agg:1 proto:'application => number' desc:'Computes the average of the applications for the current source.' }
  ]}
  { op:'block' sig:[
    { proto:'...any => any' desc:'Evaluates each of its arguments and returns the value of the final argument.' }
  ]}
  { op:['case' 'switch'] sig:[
    { proto:'(any, ...(any|application, any)) => any' desc:'Evaluates its first argument and uses it as a basis for comparison for each subsequent pair of arguments, called matchers.

The first value in a matcher is used for the comparison, and the second value is returned if the comparison holds. If the matcher first value is an application, the matcher matches if the application returns a truthy value when given the basis value. If the matcher first value is a value, the matcher matches if the first value and the basis value are loosely equal.

The basis value is available as @case or the shorthand _ in each matcher.' eg:['case 1+1 when 1 then :nope when =>4 - _ == _ then :yep else :other end' 'case(1+1 1 :nope =>4 - _ == _ :yep :other)'] }
  ]}
  { op:'ceil' sig:[
    { proto:'number => number' desc:'Returns the given number rounded up to the nearest integer.' }
  ]}
  { op:'clamp' sig:[
    { proto:'(number, number, number) => number' desc:'Takes a minimum, a value, and a maximum, and returns the minimum if the value is less than the minimum, the maximum if the value is more than the maximum, or the value otherwise.' }
  ]}
  { op:'coalesce' sig:[
    { proto:'...any => any' desc:'Lazily evalutes its arguments to return the first non-nullish one it encounters.' }
  ]}
  { op:'coalesce-truth' sig:[
    { proto:'...any => any' desc:'Lazily evalutes its arguments to return the first truthy one it encounters.' }
  ]}
  { op:'contains' sig:[
    { bin:1 proto:'(any[], any) => boolean' desc:'Returns true if the second argument is found in the first argument array using indexOf.' }
    { bin:1 proto:'(any[], any[]) => boolean' desc:'Returns true if each entry in the second argument is found in the first argument array using indexOf.' }
    { bin:1 proto:'(any[], application) => boolean' desc:'Returns true if the second argument application returns true for one of the values in the first argument array.' }
    { bin:1 proto:'(object, application) => boolean' desc:'Returns true if the second argument application returns true for one of the [value, index, key] tuples in the first argument array.' }
    { bin:1 proto:'(string, string) => boolean' desc:'Returns true if the second argument is a substring of the first argument.' }
    { bin:1 proto:'(daterange, date) => boolean' desc:'Returns true if the second argument is a falls within the first argument range.' }
  ]}
  { op:'count' sig:[
    { proto:'any[] => number' desc:'Returns the number of entries in the given array.' }
    { agg:1 proto:'() => number' desc:'Counts the number of entries in the current source.' }
  ]}
  { op:'date' sig:[
    { proto:'string => date' desc:'Parses the given date as a platform date (JS), using the builtin parser first and the platform parser if that fails.' }
    { proto:'(string, string) => date' desc:'Parses the given date as a platform date (JS), using the builtin parser first and the platform parser if that fails. If the second argument is parseable as a time, the date is shifted to that time.' }
    { proto:'(date, string) => date' desc:'If the second argument is parseable as a time, the given date is shifted to that time.' }
    { proto:'date => date' desc:'Processes the given date and return the result with optional named arguments applied.' }
  ] opts:[
    { name:['rel' 'parse'] type:'boolean' desc:'Return a raport date rather than a platform date.' }
    { name:'shift' type:'boolean' desc:'When combined with a relative date and time argument with a timezone, will shift the time along with the timezone in the resulting date rather than just changing the timezone and leaving the time as is.' }
    { name:'y' type:'number' desc:'Set the target year on the resulting date. This is not applicable for relative dates.' }
    { name:'m' type:'number' desc:'Set the target month on the resulting date with a 1 indexed number e.g. January is 1 rather than 0. This is not applicable for relative dates.' }
    { name:'d' type:'number' desc:'Set the target day on the resulting date. This is not applicable for relative dates.' }
    { name:'clamp' type:'boolean' desc:'If m or d is specified, setting a number not in the normal range will cause the date to shift outside its bounds e.g. m:13 would be January of the following year. This option will prevent that behavior.' }
  ]}
  { op:'detect-delimeters' sig:[
    { proto:'string => CSVOptions' desc:'Detects the field, record, and quote delimiters from the first 2048 characters of the given string.' }
    { proto:'(string, number) => CSVOptions' desc:'Detects the field, record, and quote delimiters from the first given number of characters of the given string.' }
  ]}
  { op:'diff' sig:[
    { proto:'(any, any) => Diff' desc:'Does a deep comparison of the two arguments returning a map of deep keypath to a tuple of the left value and right value for differing paths.' }
    { proto:'(any, any, equal) => Diff' desc:'Does a deep comparison of the two arguments returning a map of deep keypath to a tuple of the left value and right value for differing paths. The third argument is used as the equality check for comparisons (see equal named argument).' }
  ] opts:[
    { name::equal type:"'strict'|'loose'|'sql'|(any, any) => boolaen" desc:'What type of equality check should be used to determine whether two values are different. The strings strict (===), loose (==), and sql (loose plus numbers, dates, and booleans have special handling when they are or are compared to strings) will use a built-in equality check.' }
  ]}
  { op:'does-not-contain' sig:[
    { bin:1 proto:'(any[], any) => boolean' desc:'Returns false if the second argument is found in the first argument array using indexOf.' }
    { bin:1 proto:'(any[], any[]) => boolean' desc:'Returns false if each entry in the second argument is found in the first argument array using indexOf.' }
    { bin:1 proto:'(any[], application) => boolean' desc:'Returns false if the second argument application returns true for one of the values in the first argument array.' }
    { bin:1 proto:'(object, application) => boolean' desc:'Returns false if the second argument application returns true for one of the [value, index, key] tuples in the first argument array.' }
    { bin:1 proto:'(string, string) => boolean' desc:'Returns false if the second argument is a substring of the first argument.' }
    { bin:1 proto:'(daterange, date) => boolean' desc:'Returns false if the second argument is a falls within the first argument range.' }
  ]}
  { op:'each' sig:[
    { proto:'(any[], application) => string' desc:'Iterates over the given array, executes the application for each value, and returns ther results joined with an empty string.' }
    { proto:'(any[], application, ...(boolean, result)) => string' desc:'Iterates over the given array, executes the application for each value, and returns ther results joined with an empty string. If the array is empty, then the final array of condition/result pairs are lazily evaluated to return one that matches.' }
    { proto:'(object, application) => string' desc:'Iterates over the given object entries, executes the application for each value, and returns ther results joined with an empty string.' }
    { proto:'(object, application, ...(boolean, result)) => string' desc:'Iterates over the given object entries, executes the application for each value, and returns ther results joined with an empty string. If the object is empty, then the final array of condition/result pairs are lazily evaluated to return one that matches.' }
  ] opts:[
    { name:'join' type:'string' desc:'An alternate string to use to join the results.' }
  ]}
  { op:'eval' sig:[
    { proto:'string => any' desc:'Evaluates the given string as an expression.' }
  ] opts: [
    { name:'template' type:'boolean' desc:'Evaluate the given string as a template in the current context.' }
    { name:'context' type:'Context' desc:'The context in which to evaluate the expression. If not given, the current context will be used.' }
  ]}
  { op:'filter' sig:[
    { proto:'(any[], application) => any[]' desc:'Filters the given array using the given application to remove entries that return a false-y result.' }
    { proto:'(object, application) => object' desc:'Filters the given object using the given application to remove entries that return a false-y result.' }
    { proto:'(any[], application, sort[]) => any[]' desc:'Filters the given array using the given application to remove entries that return a false-y result. The result is then sorted using the given sort array.' }
    { proto:'(object, application, sort[]) => object' desc:'Filters the given object using the given application to remove entries that return a false-y result. The result is then sorted using the given sort array.' }
    { proto:'(any[], application, sort[], application|application[]) => any[]' desc:'Filters the given array using the given application to remove entries that return a false-y result. The result is then sorted using the given sort array. The result is finally grouped by the final application or array of applications.' }
  ]}
  { op:'find' sig:[
    { proto:'(any[], application) => any' desc:'Finds the first element in the given array that matches the given application and returns it.' }
    { proto:'(object, application) => any' desc:'Finds the first value in the given object that matches the given application and returns it. The application is passed the value, index, and key of each entry.' }
    { agg:1 proto:'application => any' desc:'Finds the first element in the current source that matches the given application and returns it.' }
  ]}
  { op:'first' sig:[
    { proto:'any[] => any' desc:'Returns the first element in the given array.' }
    { agg:1 proto:'() => any' desc:'Returns the first element in the current source.' }
  ]}
  { op:'flatten' sig:[
    { agg:1 proto:'any[] => any[]' desc:'Flattens nested arrays into a single non-nested array.' }
    { agg:1 proto:'(any[], number) => any[]' desc:'Flattens nested arrays into a single non-nested array, up to as many levels as specified by the second argument.' }
  ], opts: [
    { name:'flat' type:'number' desc:'The number of levels of nested arrays to flatten. If this is not supplied or not a number, it defaults to 1.' }
  ]}
  { op:'floor' sig:[
    { proto:'number => number' desc:'Returns the given number rounded down to the nearest integer.' }
  ]}
  { op:['format' 'fmt'] sig:[
    { proto:'(any, string, ...args) => string' desc:'Applies the named formatted indicated by the second argument string to the given value, passing along any additional arguments to the formatter.' }
  ]}
  { op:'generate' sig:[
    { proto:'(application) => any[]' desc:'Calls the given application, aggregating values until the application returns undefined.

If the result is an array, the elements of the array are added to the result.
If the result is an object matching { value?: any, state?: any }, then the value will be added to the result and the state, if supplied, will replace the state of the generator.
Any other value will be added to the result.

Each application is passed the state, last value, and index of the call. Each of the arguments is also available a special reference, @state, @last, and @index, respectively.

The global defaults for generate have a max property, defaulting to 10000, that limits the number of iterations that can be run to avoid non-terminating generators.' }
  ], opts: [
    { name:'[state]' type:'any' desc:'Any options passed to the operator are sent into the initial application as the state.' }
  ]}
  { op:'get' sig:[
    { proto:'(any, string) => any' desc:'Safely retrieves the value at the given path string from the value passed as the first argument.' }
  ]}
  { op:'group' sig:[
    { proto:'(any[], application|application[]) => any[]' desc:'Groups the given array using the given application or application array.' }
  ]}
  { op:'if' sig:[
    { proto:'(...(boolean, any)) => any' desc:'Lazily evaluates each odd argument and returns the first subsequent even argument when a truthy odd argument is found. If no truthy odd argument is found and there is not a final even argument, the final odd argument is returned.' }
  ]}
  { op:'ilike' sig:[
    { bin:1 proto:'(string, string) => any' desc:'Checks to see if the first string matches the second string used as a pattern case insensitively.' }
    { bin:1 proto:'(string[], string) => any' desc:'Checks to see if any of the strings in the first argument array matches the second string used as a pattern case insensitively.' }
    { bin:1 proto:'(string, string[]) => any' desc:'Checks to see if first string matches any of the second argument strings used as patterns case insensitively.' }
    { bin:1 proto:'(string[], string[]) => any' desc:'Checks to see if any of the strings in the first argument array matches any of the second argument strings used as patterns case insensitively.' }
  ] opts: [
    { name:'free' type:'boolean' desc:'Causes the patterns not to be anchored to the start and end of the target string.' }
  ]}
  { op:'in' sig:[
    { bin:1 proto:'(any, any[]) => boolean' desc:'Returns true if the first argument is found in the second argument array using indexOf.' }
    { bin:1 proto:'(any[], any[]) => boolean' desc:'Returns true if each entry in the first argument is found in the second argument array using indexOf.' }
    { bin:1 proto:'(application, any[]) => boolean' desc:'Returns true if the first argument application returns true for one of the values in the second argument array.' }
    { bin:1 proto:'(application, object) => boolean' desc:'Returns true if the first argument application returns true for one of the [value, index, key] tuples in the second argument array.' }
    { bin:1 proto:'(string, string) => boolean' desc:'Returns true if the first argument is a substring of the second argument.' }
    { bin:1 proto:'(string|string[], object) => boolean' desc:'Returns true if the strings in the first argument are all keys in the given object.' }
    { bin:1 proto:'(date, daterange) => boolean' desc:'Returns true if the first argument falls within the second argument range.' }
    { bin:1 proto:'(number, range) => boolean' desc:'Returns true if the first argument falls within the second argument range.' }
  ]}
  { op:'index' sig:[
    { agg:1 proto:'(array, application) => object' desc:'Returns a map of the given array keyed on the result of the application.

If the application returns a tuple, the values in the map will be the second value in the tuple and the keys will be the first. If the key portion of the tuple is an array, the value will be set for each key in the keys array.
If the application returns an empty tuple, the value in the array will be omitted from the result.
The value may also be an object with a "key" or "keys" key and, optionally, a "value" key.
The value may also be an object with a "many" key with an array value of multiple entries of any of the previous types to be added to the map.' }
  ] opts: [
    { name:'many' type::boolean desc:'If enabled, the values in the map will be arrays aggregating all of the values with the same key. Otherwise, the last entry for a key will be the value for that key in the map.' }
  ]}
  { op:'inspect' sig:[
    { proto:'(any) => schema' desc:'Inspects the given value and returns a schema based on its contents.' }
  ] opts:[
    { name:'mode' type:"'schema'" desc:"If set to 'schema' the result will be unparsed into a schema literal." }
    { name:'flat' type:'boolean' desc:'If enabled, deeply introspect objects to include nested types in the schema.' }
  ]}
  { op:'intersect' sig:[
    { proto:'(any[], any[]) => any[]' desc:'Returns the intersection of the two given arrays with no duplicates.' }
  ]}
  { op:'interval' sig:[
    { proto:'string => interval' desc:'Parses the given string as an interval.' }
  ]}
  { op:'join' sig:[
    { proto:'(any[], string) => string' desc:'Joins all of the elements in the given array with the given string.' }
    { proto:'(any[], application, string) => string' desc:'Joins all of the results of the given application of each element in the given array with the given string.' }
    { proto:'(any[], string, string) => string' desc:'Joins all of the elements in the given array with the given string. The last element is appended using the final string if there are more than two elements.' }
    { proto:'(any[], application, string, string) => string' desc:'Joins all of the results of the given application of each element in the given array with the given string. The last element is appended using the final string if there are more than two elements.' }
    { proto:'(any[], string, string, string) => string' desc:'Joins all of the elements in the given array with the given string. The elements are joined using the final string if there are only two elements. The last element is appended using the second string if there are more than two elements.' }
    { proto:'(any[], application, string, string, string) => string' desc:'Joins all of the results of the given application of each element in the given array with the given string. The elements are joined using the final string if there are only two elements. The last element is appended using the second string if there are more than two elements.' }
    { agg:1 proto:'string => string' desc:'Joins all of the elements in the current source with the given string.' }
    { agg:1 proto:'(application, string) => string' desc:'Joins all of the results of the given application of each element in the current source with the given string.' }
    { agg:1 proto:'(string, string) => string' desc:'Joins all of the elements in the current source with the given string. The last element is appended using the final string if there are more than two elements.' }
    { agg:1 proto:'(application, string, string) => string' desc:'Joins all of the results of the given application of each element in the current source with the given string. The last element is appended using the final string if there are more than two elements.' }
    { agg:1 proto:'(string, string, string) => string' desc:'Joins all of the elements in the current source with the given string. The elements are joined with the final string if there are only two elements. The last element is appended using the second string if there are more than two elements.' }
    { agg:1 proto:'(application, string, string, string) => string' desc:'Joins all of the results of the given application of each element in the current source with the given string. The elements are joined with the final string if there are only two elements. The last element is appended using the second string if there are more than two elements.' }
  ]}
  { op:'keys' sig:[
    { proto:'object => string[]' desc:'Returns an array of all of the keys in the given object.' }
    { proto:'(object, true) => string[]' desc:'Returns an array of all of the keys in the given object, including any from the prototype chain.' }
  ]}
  { op:'label-diff' sig:[
    { proto:'(Diff, LabelMap) => Diff' desc:'Takes the given diff and label map and swaps out paths in the diff for labels in the map.

The label map is a nested object with the keys being single key paths in the diff and the values being a label or tuple of a label and label map for nested sub structures.' eg:'label-diff(d { foo:[:Company { bar::Address }] }) where d = { :foo.bar: [:street :avenue] } will result in { "Company Address": [:street :avenue] }' }
  ] opts:[
    { name:'omit' type:'boolean' desc:'Remove any unlabelled diff entries from the output.' }
  ]}
  { op:'last' sig:[
    { proto:'any[] => any' desc:'Returns the last element in the given array.' }
    { agg:1 proto:'() => any' desc:'Returns the last element in the current source.' }
  ]}
  { op:'let' sig:[
    { proto:'(string, any) => interval' desc:'Sets the local value specified by the given path in the first argument the value supplied as the second argument and returns the value that was replaced, if any.' }
  ]}
  { op:['len' 'length'] sig:[
    { proto:'any => number' desc:'Returns the length of the given value or 0 if it has none.' }
  ]}
  { op:'like' sig:[
    { bin:1 proto:'(string, string) => any' desc:'Checks to see if the first string matches the second string used as a pattern case sensitively.' }
    { bin:1 proto:'(string[], string) => any' desc:'Checks to see if any of the strings in the first argument array matches the second string used as a pattern case sensitively.' }
    { bin:1 proto:'(string, string[]) => any' desc:'Checks to see if first string matches any of the second argument strings used as patterns case sensitively.' }
    { bin:1 proto:'(string[], string[]) => any' desc:'Checks to see if any of the strings in the first argument array matches any of the second argument strings used as patterns case sensitively.' }
  ] opts: [
    { name:'free' type:'boolean' desc:'Causes the patterns not to be anchored to the start and end of the target string.' }
  ]}
  { op:'lower' sig:[
    { proto:'string => string' desc:'Returns the given string in lower case.' }
  ]}
  { op:'map' sig:[
    { proto:'(any[], application) => any[]' desc:'Applies the given application to each element in the given array and returns an array containing the results.' }
    { proto:'application => any[]' desc:'Applies the given application to each element in the current source and returns an array containing the results.' }
    { proto:'(object, application) => object' desc:'Applies the given application to each [value, index, key] tuple in the given object and returns an object containing the results. If the application return a null, that entry will be left out of the result. If it returns a 2-tuple with a string as the first entry, the result will replace that entry. Otherwise, the entry will have its value replaced with the result of the application.' }
  ] opts: [
    { name:'array' type:'boolean' desc:'When truthy for an object map call, this will cause the result to be the array of application results rather than an object. The application in this case should only return result values.'}
    { name:'entries' type:'boolean' desc:'When truthy for an object map call, this will cause the result to be the array of resulting application entries rather than an object. The same handling for object entries still applies to this option as the operation without it.'}
    { name:'flat' type:'number' desc:'When applied to an array or an object call that results in an array, this will cause the array to be flattened up to the level specified by the value of the option. If the value is not a number but still truthy, the number defaults to 1.' }
  ]}
  { op:'max' sig:[
    { agg:1 proto: '() => number' desc:'Returns the largest entry in the current source.' }
    { proto:'number[] => number' desc:'Returns the largest entry in the given array of numbers.' }
    { proto:'(any[], application) => number' desc:'Returns the largest entry in the applications for the given array of values.' }
    { agg:1 proto:'application => number' desc:'Returns the largest entry in the applications for the current source.' }
    { proto:'...number => number' desc:'Returns the largest entry in the given list of number arguments. If no arguments are given the result will be 0.' }
  ]}
  { op:'min' sig:[
    { agg:1 proto: '() => number' desc:'Returns the smallest entry in the current source.' }
    { proto:'number[] => number' desc:'Returns the smallest entry in the given array of numbers.' }
    { proto:'(any[], application) => number' desc:'Returns the smallest entry in the applications for the given array of values.' }
    { agg:1 proto:'application => number' desc:'Returns the smallest entry in the applications for the current source.' }
    { proto:'...number => number' desc:'Returns the smallest entry in the given list of number arguments. If no arguments are given the result will be 0.' }
  ]}
  { op:'not' sig:[
    { un:1 proto:'any => boolean' desc:'Negates the truthiness of the given value.' }
  ]}
  { op:'not-ilike' sig:[
    { bin:1 proto:'(string, string) => any' desc:'Checks to see if the first string does not match the second string used as a pattern case insensitively.' }
    { bin:1 proto:'(string[], string) => any' desc:'Checks to see if all of the strings in the first argument array do not match the second string used as a pattern case insensitively.' }
    { bin:1 proto:'(string, string[]) => any' desc:'Checks to see if first string does not match any of the second argument strings used as patterns case insensitively.' }
    { bin:1 proto:'(string[], string[]) => any' desc:'Checks to see if all of the strings in the first argument array do not match any of the second argument strings used as patterns case insensitively.' }
  ] opts: [
    { name:'free' type:'boolean' desc:'Causes the patterns not to be anchored to the start and end of the target string.' }
  ]}
  { op:'not-in' sig:[
    { bin:1 proto:'(any, any[]) => boolean' desc:'Returns false if the first argument is found in the second argument array using indexOf.' }
    { bin:1 proto:'(any[], any[]) => boolean' desc:'Returns false if each entry in the first argument is found in the second argument array using indexOf.' }
    { bin:1 proto:'(application, any[]) => boolean' desc:'Returns false if the first argument application returns true for one of the values in the second argument array.' }
    { bin:1 proto:'(application, object) => boolean' desc:'Returns false if the first argument application returns true for one of the [value, index, key] tuples in the second argument array.' }
    { bin:1 proto:'(string, string) => boolean' desc:'Returns false if the first argument is a substring of the second argument.' }
    { bin:1 proto:'(string|string[], object) => boolean' desc:'Returns false if the strings in the first argument are all keys in the given object.' }
    { bin:1 proto:'(date, daterange) => boolean' desc:'Returns false if the first argument falls within the second argument range.' }
    { bin:1 proto:'(number, range) => boolean' desc:'Returns false if the first argument falls within the second argument range.' }
  ]}
  { op:'not-like' sig:[
    { bin:1 proto:'(string, string) => any' desc:'Checks to see if the first string does not match the second string used as a pattern case sensitively.' }
    { bin:1 proto:'(string[], string) => any' desc:'Checks to see if all of the strings in the first argument array do not match the second string used as a pattern case sensitively.' }
    { bin:1 proto:'(string, string[]) => any' desc:'Checks to see if first string does not match any of the second argument strings used as patterns case sensitively.' }
    { bin:1 proto:'(string[], string[]) => any' desc:'Checks to see if all of the strings in the first argument array do not match any of the second argument strings used as patterns case sensitively.' }
  ] opts: [
    { name:'free' type:'boolean' desc:'Causes the patterns not to be anchored to the start and end of the target string.' }
  ]}
  { op:'nth' sig:[
    { proto:'(any[], number) => any' desc:'Returns the nth item in the given array using a 1-based index. If the number is negative, the offset is from the end rather than the beginning.' }
    { agg:1 proto:'number => any' desc:'Returns the nth item in the current source using a 1-based index. If the number is negative, the offset is from the end rather than the beginning.' }
  ]}
  { op:'num' sig:[
    { proto:'string => number' desc:'Returns the first positive number found in the string, including an optional decimal.' }
  ]}
  { op:'object' sig:[
    { proto:'(...(string, any)) => object' desc:'Returns an object assembled from the arguments where each odd argument is a key and the subsequent even argument is its value.' eg: 'object(:key1 99 :key2 73)' }
  ]}
  { op:'overlap' sig:[
    { proto:'(string, string, number = 0.5) => string' desc:"Returns the first overlapping substring within the two given strings that is at least the given percentage of the smallest string's length long using the similar operator." }
  ]}
  { op:'pad' sig:[
    { proto:'(string, number) => string' desc:'Pads the given string with spaces at both ends such that it is at least the given number of characters long.' }
    { proto:'(string, number, string) => string' desc:'Pads the given string with the final string at both ends such that it is at least the given number of characters long.' }
  ]}
  { op:'padl' sig:[
    { proto:'(string, number) => string' desc:'Pads the given string with spaces at the beginning such that it is at least the given number of characters long.' }
    { proto:'(string, number, string) => string' desc:'Pads the given string with the final string at the beginning such that it is at least the given number of characters long.' }
  ]}
  { op:'padr' sig:[
    { proto:'(string, number) => string' desc:'Pads the given string with spaces at the end such that it is at least the given number of characters long.' }
    { proto:'(string, number, string) => string' desc:'Pads the given string with the final string at the end such that it is at least the given number of characters long.' }
  ]}
  { op:'parse' sig:[
    { proto:'string => any' desc:'Parses the given string using the expression parser.' }
  ] opts: [
    { name:'date' type:'boolean' desc:'Use the date parser rather than the expression parser.' }
    { name:'template' type:'boolean' desc:'Use the template parser rather than the expression parser.' }
    { name:'time' type:'boolean' desc:'Use the time parser rather than the expression parser.' }
    { name:'schema' type:'boolean' desc:'Use the schema parser rather than the expression parser.' }
    { name:'base64' type:'boolean' desc:'Use a base64 parser to decode a base64 encoded string.' }
    { name:'xml' type:'boolean' desc:'Use the XML parser to read data. Properties and children are equivalent. Duplicate names result in all of the duplicate values being aggregated into an array rather than last in winning.' }
    { name:'strict' type:'boolean' desc:'For the XML parser, be less forgiving about malformed content. Defaults to false.' }
    { name:'csv' type:'boolean' desc:'Use the delimited text parser rather than the expression parser.' }
    { name:'detect' type:'boolean' desc:'If using the delimited parser, detect the delimiters and use them to parse.' }
    { name:'header' type:'boolean' desc:'If using the delimited parser, treat the first result as a header and use it to build objects with field names based on the header.' }
    { name:'field' type:'string' desc:'If using the delimited parser, use the given string as the field delimiter.' }
    { name:'record' type:'string' desc:'If using the delimited parser, use the given string as the record delimiter.' }
    { name:'quote' type:'string' desc:'If using the delimited parser, use the given string as the field quote.' }
  ]}
  { op:'pipe' sig:[
    { proto:'...any => any' desc:'This is a special built-in operator that evaluates its first argument, supplies that as an input to the next argument, supplies that result as an input to the next argument, and so on until the result of the last argument evaluation is returned. If any argument is an operation that does not reference \`@pipe\` or \`_\` as one of its arguments, then \`@pipe\` will be added as the first argument of that operation. Arguments that are applications are automatically applied with the piped value.' }
  ]}
  { op:['rand' 'random'] sig:[
    { proto:'() => number' desc:'Returns a random floating point number between 0 and 1, inclusive.' }
    { proto:'number => number' desc:'Returns a random integer between 1 and the given number, inclusive.' }
    { proto:'(number, true) => number' desc:'Returns a random floating point number between 1 and the given number, inclusive.' }
    { proto:'(number, number) => number' desc:'Returns a random integer between the given numbers, inclusive.' }
    { proto:'(number, number, true) => number' desc:'Returns a random floating point number between the given numbers, inclusive.' }
  ]}
  { op:'reduce' sig:[
    { proto:'(any[], application, any) => any' desc:'Folds the given array into the final argument value by passing each element in the given array into the application with the result of the last application (or the final argument for the first iteration) and returns the result of the final application.' }
    { agg:1 proto:'(application, any) => any' desc:'Folds the current source into the final argument value by passing each element in the current source into the application with the result of the last application (or the final argument for the first iteration) and returns the result of the final application.' }
  ]}
  { op:'replace-all' sig:[
    { proto:'(string, string, string) => string' desc:'Replaces all instances of the second string found in the first string with the third string.' }
    { proto:'(string, string, string, string) => string' desc:'Replaces all instances of a regular expression constructed with the seconds string as the expression and the fourth string as the flags, which may be empty, found in the first string with the third string.' }
  ]}
  { op:'replace' sig:[
    { proto:'(string, string, string) => string' desc:'Replaces the first instance of the second string found in the first string with the third string.' }
    { proto:'(string, string, string, string) => string' desc:'Replaces the first instance of a regular expression constructed with the seconds string as the expression and the fourth string as the flags, which may be empty, found in the first string with the third string.' }
  ]}
  { op:'reverse' sig:[
    { proto:'string => string' desc:'Reverses the given string.' }
    { proto:'any[] => any[]' desc:'Reverses the given array.' }
  ]}
  { op:'round' sig:[
    { proto:'number => number' desc:'Rounds the given number to the nearest integer.' }
    { proto:'(number, number, string) => number' desc:'Rounds the given number to the nearest decimal specified by the second number using the method specified by the string, defaulting to half-even. Supported methods are half-up, half-down, to-0, from-0, half-even, and half-odd. If the number of places negative, the number will be rounded left from the decimal point.' }
  ] note:"By default, the single-number signature will round to an integer, but if the round defaults are updated to include all-numeric as true, then it will return numbers rounded to the nearest default place. Round defaults are { places:2 all-numeric:false method::half-even }."}
  { op:'set' sig:[
    { proto:'(string, any) => interval' desc:'Sets the root value specified by the given path in the first argument the value supplied as the second argument and returns the value that was replaced, if any.' }
  ]}
  { op:'set-defaults' sig:[
    { proto:"('format', string) => any" desc:'Sets the defaults for the given named formatter. Defaults should be passed in as named options that depend on the decorator.' }
    { proto:"('round') => any" desc:'Sets the defaults for rounding operations. Defaults should be passed in as named options, which can be places, all-numeric, and method. 

If a truthy option named context is supplied, the defaults will only be set in the current context and any derived from it in the future. With a context-local round default set, math operations performed in the context or its children will apply rounding as they are performed.

To clear a context-local round default, call this with truthy context and unset named options.' }
    { proto:"('generate') => any" desc:'Sets the defaults for generate operations. Defaults should be passed in as named options, which can be max. The default max is 10000.' }
  ]}
  { op:'similar' sig:[
    { proto:'(string, string, number = 0.5, number = 2) => [string, string, number]' desc:'Finds the first similar substrings within the two given strings based on a threshhold (3rd argument, defaults to 50%) and fudge factor (4th argument, defaults to 2). The two similar substrings are returned in a tuple with the similarity percentage.' }
  ]}
  { op:'similarity' sig:[
    { proto:'(string, string, number = 0.5, number = 2) => [string, string, number]' desc:'Finds the similarity percentage of the first similar substrings within the two given strings using the similar operator.' }
  ]}
  { op:['slice' 'substr'] sig:[
    { proto:'any[] => any[]' desc:'Returns a copy of the given array.' }
    { proto:'(any[], number) => any[]' desc:'Returns a copy of the given array starting from the element at the given index.' }
    { proto:'(any[], number, number) => any[]' desc:'Returns a copy of the given array starting from the element at the given index and ending immediately before the final given index. If the final index is negative, it is an offset from the end of the array.' }
    { proto:'(string, number) => string' desc:'Returns a substring of the given string starting from the character at the given index.' }
    { proto:'(string, number, number) => any[]' desc:'Returns a substring of the given string starting from the character at the given index and ending immediately before the final given index. If the final index is negative, it is an offset from the end of the string.' }
  ]}
  { op:'sort' sig:[
    { proto:'(any[], sort[]) => any[]' desc:'Sorts the given array using the given sort array.

Any array elements that are strings may indicate direction with a leading + or - for ascending and descending, respectively. The remainder of the string is parsed and used as an application.
Any array elements that are applications are applied directly to get a comparison value.
Any arguments that are objects may include a by key with an application value along with asc, desc, or dir flags.
If no sorts are provided, an identity sort will be applied.' }
    { proto:'(object, sort[]) => object' desc:'Sorts the given object keys using the given sort array.

Any array elements that are strings may indicate direction with a leading + or - for ascending and descending, respectively. The remainder of the string is parsed and used as an application.
Any array elements that are applications are applied directly to get a comparison value.
Any arguments that are objects may include a by key with an application value along with asc, desc, or dir flags.
If no sorts are provided, an identity sort will be applied to the keys.' }
  ]}
  { op:'source' sig:[
    { proto:'any => DataSet' desc:'Creates a DataSet from the given value, or returns the value if it is already a DataSet.' }
    { proto:'(any, application) => any' desc:'Creates a DateSet from the given value if it is not already a DataSet, and then sets that as the @source to call the given application. The result of the application is returned.' }
  ]}
  { op:'split' sig:[
    { proto:'string => string[]' desc:'Splits the given string into an array containing each of its characters.' }
    { proto:'(string, string) => string[]' desc:'Splits the given string into an array containing substrings delimited by the second argument.' }
  ]}
  { op:'strict-is' sig:[
    { bin:1 proto:'(any, any) => boolean' desc:'Returns true if the two arguments are the same literal value or are pointers to the same object.' }
    { bin:1 proto:'(any, schema) => boolean' desc:'(Only applies to the \\'strict-is\\' alias) Returns true if the given value strictly conforms to the given schema.' }
  ]}
  { op:'strict-is-not' sig:[
    { bin:1 proto:'(any, any) => boolean' desc:'Returns false if the two arguments are the same literal value or are pointers to the same object.' }
    { bin:1 proto:'(any, schema) => boolean' desc:'(Only applies to the \\'strict-is-not\\' alias) Returns true if the given value does not strictly conform to the given schema.' }
  ]}
  { op:'string' sig:[
    { proto:'any => string' desc:'Politely stringifies the given value, meaning that there are no undefined, null, or object prototype values strings returned.' }
  ] opts: [
    { name:'json' type:'boolean' desc:'Forces the output string to be JSON.' }
    { name:'raport' type:'boolean' desc:'Forces the output string to be a raport expresion. This can be paired with any options to the stringify function supplied by raport.' }
    { name:'string' type:'boolean' desc:'Processes the value as a styled string.' }
  ]}
  { op:'wrap-count' sig:[
    { proto:'string,number?,font?' desc:'Calculates the number of lines that the given string will occupy in the given width in rem using the given font. If the width is not specified, the @widget.width or @placement.availableX will be used. If the font is not specified, the @widget.font will be used. Inherited fonts are not considered.' }
  ] opts: [
    { name:'width' type:'number' desc:'A named version of the second positional argument.' }
    { name:'font' type:'font' desc:'A named version of the third positional argument. This is an object with the relevant parts of the interface conforming to { family?:string, size?:number, line?:number, metric?: number }. family defaults to "sans", size defaults to 0.83, line defaults to size, and metric defaults to the constant pixel width of the font at 16px per em e.g. sans: 7.4, serif: 6.7, mono: 7.85, and narrow: 5.9.' }
    { name:'family' type:'string' desc:'Overrides the given font family.' }
    { name:'size' type:'number' desc:'Overrides the given font size.' }
    { name:'line' type:'number' desc:'Overrides the given font line height.' }
    { name:'metric' type:'string' desc:'Overrides the given font metric.' }
    { name:'break-word' type:'boolean' desc:'Determines whether words that exceed the width should be broken, defaulting to true.' }
  ]}
  { op:'sum' sig:[
    { agg:1 proto: '() => number' desc:'Computes the sum of the current source.' }
    { proto:'number[] => number' desc:'Computes the sum of the given array of numbers.' }
    { proto:'(any[], application) => number' desc:'Computes the sum of the applications for the given array of values.' }
    { agg:1 proto:'application => number' desc:'Computes the sum of the applications for the current source.' }
  ]}
  { op:['time-span' 'time-span-ms'] sig:[
    { proto:'number => number[]' desc:'Returns an array of time units based on options given that represent the number of milliseconds passed as the first argument.' }
    { proto:'(date, date) => number[]' desc:'Returns an array of time units based on options given that represent the distance between the two dates.' }
    { proto:'timespan => number[]' desc:'Returns an array of time units based on options given that represent the distance between the start and end of the given timespan.' }
  ] opts:[
    { name:'unit' type:'string|string[]' desc:"The units desired in the result. This can be either a string or array of strings with the units represented by [y]ears, [M|mo]nths, [w]eeks, [d]ays, [h]ours, [m|mm]inutes, [s]econds, [ms] where 'M' will get months and 'mm' or 'm' not followed by an 'o' will get minutes. The string form can only be used for unambiguous single character units. Units must be specified in descending order by size." }
    { name:'string' type:'boolean' desc:'Causes the output to be a string rather than an array.' }
    { name:'round' type:"'floor'|'ceil'|'round'" desc:"Determines how the results should be rounded. By default they are 'floor'ed, but this can also be 'ceil' or 'round'. Rounding is done based on the next largest available unit after the smallest requiested unit e.g. hours if days are requested last or months if years are the only requested unit." }
  ] note:"If there's no way to get an accurate result from the given timespan e.g. you want years or months from a span specified in ms, approximations will be used. The approximations are 365.25 days in a year and 30.45 days in a month." }
  { op:'trim' sig:[
    { proto:'string => string' desc:'Trims whitespace from both ends of the given string.' }
  ]}
  { op:'triml' sig:[
    { proto:'string => string' desc:'Trims whitespace from the beginning of the given string.' }
  ]}
  { op:'trimr' sig:[
    { proto:'string => string' desc:'Trims whitespace from the end of the given string.' }
  ]}
  { op:'unique' sig:[
    { proto:'any[] => any[]' desc:'Returns a copy of the given array with no duplicate elements.' }
    { agg:1 proto:'() => any[]' desc:'Returns a copy of the current source with no duplicate elements.' }
    { proto:'(any[], application) => any[]' desc:'Returns a copy of the given array with no duplicate application results.' }
    { agg:1 proto:'application => any[]' desc:'Returns a copy of the current source with no duplicate application results.' }
  ]}
  { op:'unique-map' sig:[
    { proto:'(any[], application) => any[]' desc:'Returns an array of application results from the given array with no duplicate elements.' }
    { agg:1 proto:'application => any[]' desc:'Returns an array of application results of the current source with no duplicate elements.' }
  ]}
  { op:'unless' sig:[
    { proto:'(...(boolean, any)) => any' desc:'Lazily evaluates each odd argument and returns the first subsequent even argument when a false-y odd argument is found. If no false-y odd argument is found and there is not a final even argument, the final odd argument is returned.' }
  ]}
  { op:'unparse' sig:[
    { proto:'any => string' desc:'Stringifies the given value as a raport expression.' }
  ]}
  { op:'upper' sig:[
    { proto:'string => string' desc:'Converts the given string to upper case.' }
  ]}
  { op:'valid' sig:[
    { proto:'(any, schema) => boolean' desc:'Returns true if the given value validates against the given schema.' }
  ] opts:[
    { name:'strict' type:'boolean' desc:'Validate in strict mode rather than the default loose mode.' }
    { name: 'mode' type:"'strict'|'loose'|'missing'" desc:'Sets the mode of validation e.g. strict or loose or missing.'}
  ]}
  { op:'validate' sig:[
    { proto:'(any, schema) => true|error[]' desc:'Returns true if the given value validates against the given schema or an array of errors if it does not.' }
  ] opts:[
    { name:'strict' type:'boolean' desc:'Validate in strict mode rather than the default loose mode.' }
    { name: 'mode' type:"'strict'|'loose'|'missing'" desc:'Sets the mode of validation e.g. strict or loose or missing.'}
  ] note:"The schema of an error is @[{ error: string; type?: 'strict'; path?: string; actual?: string; expected?: string; value?: any }]. If the error is the result of a strict check, the type will be set to 'strict'. The path is the keypath from the root of the given value to the piece of data that caused the error. Missing mode requires that any referenced named types be declared. Strict mode additionally requires that there be no unspecified properties in objects and tuples." }
  { op:'values' sig:[
    { proto:'object => any[]' desc:'Returns an array of all of the values in the given object.' }
  ]}
  { op:'with' sig:[
    { proto:'(object, application) => any' desc:'Evaluates the given application with the given value as the context, returning the result of the application.' }
    { proto:'(object, application, any) => any' desc:'Evaluates the given application with the given value as the context, returning the result of the application. If the value is false-y, the final argument is returned instead.' }
  ]}
]`;
    const formats = `let dateparts = 'Available placeholders are:\\n\\n* y - year\\n* M - month\\n* d - date\\n* E - day of week\\n* H - hour (24 hour)\\n* h or k - hour (12 hour)\\n* m - minute\\n* s - second\\n* S - millisecond\\n* a - AM/PM\\n* z - timezone offset'
[
  { name:'base' desc:'Converts the given number to the given base' opts:[
    { name:'base' req:1 type:'number' desc:'The target base e.g. 2 or 8 or 16.' }
  ]}
  { name:'base64' desc:'Converts the given value to a base64 encoded string.' }
  { name:'case' desc:'Change the casing of the value.' opts:[
    { name:'case' req:1 type:"'upper'|'lower'|'snake'|'kebab'|'pascal'|'camel'|'proper'" desc:'The case format to use.'}
  ]}
  { name:'date' desc:'Formats the value as a date string using placeholder characters, where repeated characters render more descriptive or padded values. Any non-placeholder characters are rendered as entered. The default format is yyyy-MM-dd. Available placeholders are:\\n\\n* y - year\\n* M - month\\n* d - date\\n* E - day of week\\n* H - hour (24 hour)\\n* h or k - hour (12 hour)\\n* m - minute\\n* s - second\\n* S - millisecond\\n* a - AM/PM\\n* z - timezone offset' opts:[
    { name:'format' type:'string' desc:'The format template to apply.'}
  ]}
  { name:'dollar' desc:'Formats the value as a dollar amount with two decimal places by default.' opts:[
    { name:'dec' type:'number' desc:'The number of decimal places to render.' }
    { name:'group' type:'string' desc:'The string to use as a grouping divider.' }
    { name:'sign' type:'string' desc:'The currency symbol to render.' }
    { name:'neg' type:"'sign'|'wrap'|'both'" desc:'How to display negative values. Sign shows a leading minus symbol. Wrap wraps the value in parenteses.' }
  ]}
  { name:['hex'] desc:'Formats the given number in hexadecimal, or if the value is not a number, encodes it as string in hexadecimal.' }
  { name:['int' 'integer'] desc:'Formats the value as an integer.' opts:[
    { name:'group' type:'string' desc:'The string to use as a grouping divider.' }
    { name:'neg' type:"'sign'|'wrap'|'both'" desc:'How to display negative values. Sign shows a leading minus symbol. Wrap wraps the value in parenteses.' }
  ]}
  { name:'iso8601' desc:'Formats the value as an ISO-8601 timestamp.' }
  { name:'noxml' desc:'Escapes special XML characters so that the value may be safely rendered into xml.' }
  { name:['num' 'number'] desc:'Formats the value as an number.' opts:[
    { name:'dec' type:'number' desc:'The number of decimal places to render.' }
    { name:'group' type:'string' desc:'The string to use as a grouping divider.' }
    { name:'neg' type:"'sign'|'wrap'|'both'" desc:'How to display negative values. Sign shows a leading minus symbol. Wrap wraps the value in parenteses.' }
  ]}
  { name:'ordinal' desc:'Render the value as an ordinal number.' opts:[
    { name:'group' type:'string' desc:'The string to use as a grouping divider.' }
  ]}
  { name:'phone' desc:'Formats the value as phone number e.g. 111-2222, (111) 222-3333, 1-888-777-6666' }
  { name:'time' desc:'Formats a date value as a time string using placeholder characters, where repeated characters render more descriptive or padded values. Any non-placeholder characters are rendered as entered. The default format is HH:mm:ss. {dateparts}' opts:[
    { name:'format' type:'string' desc:'The format template to apply.'}
  ]}
  { name:'styled' desc:'Processes the value as a styled string.' }
  { name:'timestamp' desc:'Formats a date value as a timestamp using placeholder characters, where repeated characters render more descriptive or padded values. Any non-placeholder characters are rendered as entered. The default format is yyyy-MM-dd HH:mm:ss. {dateparts}' opts:[
    { name:'format' type:'string' desc:'The format template to apply.'}
  ]}
  { name:'timestamptz' desc:'Formats a date value as a timestamp with timezone offset using placeholder characters, where repeated characters render more descriptive or padded values. Any non-placeholder characters are rendered as entered. The default format is yyyy-MM-dd HH:mm:sszzz. {dateparts}' opts:[
    { name:'format' type:'string' desc:'The format template to apply.'}
  ]}
  { name:'xml' desc:'Converts the given value to XML if possible.' opts:[
    { name:'indent' type:'number' desc:'Indent each successive set of child nodes with this number of spaces.' }
  ]}
   { name:'[operator]' desc:'Calls the named operator as a formatter, passing the target value as the first argument with any arguments to the formatter following. Any set defaults for the formatter are passed as options to the operator.' }
]`;
    function languageReference(zoom = 100, theme = 'dark') {
        return `<html>
<head><title>Raport Expression Language Reference</title>
<style>
  html {
    font-family: sans-serif;
    font-size: ${zoom}%;
  }
  h2 { margin-top: 3em; }
  h3 { margin-top: 1.5em; }
  body { padding: 1em; max-width: 60em; margin: auto; }
  body.dark { color: #ccc; }
  body.light { color: #222; }
  code {
    font-family: monospace;
    padding: 0.4em;
    vertical-align: baseline;
    font-size: 1.1em;
    line-height: 1em;
    box-sizing: border-box;
    display: inline-block;
    border: 1px solid;
  }
  li { margin: 0.5rem 0; line-height: 1.75rem; }
  .dark code { border-color: #777; }
  .light code { border-color: #ddd; }

  div.indent {
    padding-left: 1em;
  }

  .ast-nodes .reference {
    color: #43b;
    font-weight: 500;
  }
  .dark .ast-nodes .reference { color: #98d; }

  .ast-nodes .primitive,
  .ast-nodes .number,
  .ast-nodes .date,
  .ast-nides .timespan {
    color: #087;
    font-weight: 500;
  }
  .dark .ast-nodes .primitive,
  .dark .ast-nodes .number,
  .dark .ast-nodes .date,
  .dark .ast-nides .timespan {
    color: #0ca;
  }

  .ast-nodes .format-op {
    color: #e81;
  }

  .ast-nodes .string,
  .ast-nodes .string > .ast-extra {
    color: #170;
  }
  .dark .ast-nodes .string,
  .dark .ast-nodes .string > .ast-extra {
    color: #1a0;
  }

  .ast-nodes .string > .string-interpolation {
    font-style: oblique;
  }

  .ast-nodes .binary-op > .ast-extra,
  .ast-nodes .conditional > .ast-extra {
    color: #a66;
  }
  .dark .ast-nodes .binary-op > .ast-extra,
  .dark .ast-nodes .conditional > .ast-extra {
    color: #b88;
  }

  .ast-nodes .typelit,
  .ast-nodes .typelit > .ast-extra {
    color: #361;
  }
  .dark .ast-nodes .typelit,
  .dark .ast-nodes .typelit > .ast-extra {
    color: #491;
  }

  .ast-nodes .typelit .type {
    color: #67f;
    font-weight: 500;
  }

  .ast-nodes .typelit .key,
  .ast-nodes .typelit .literal {
    font-weight: 500;
    color: #557;
  }
  .dark .ast-nodes .typelit .key,
  .dark .ast-nodes .typelit .literal {
    font-weight: 500;
    color: #99b;
  }

  .ast-nodes .typelit .key {
    color: #b61;
  }

  .ast-nodes .typelit .condition {
    font-weight: 700;
  }

  .ast-nodes .ast-fail {
    color: #f00;
  }

  .ast-nodes .interpolator,
  .ast-nodes .each-block > .ast-extra,
  .ast-nodes .if-block > .ast-extra,
  .ast-nodes .unless-block > .ast-extra,
  .ast-nodes .case-block > .ast-extra,
  .ast-nodes .with-block > .ast-extra {
    font-weight: 600;
  }

  .ast-nodes .each-block > .ast-extra {
    color: #4bc;
  }

  .ast-nodes .case-block > .ast-extra,
  .ast-nodes .unless-block > .ast-extra,
  .ast-nodes .if-block > .ast-extra {
    color: #1de;
  }

  .ast-nodes .with-block > .ast-extra {
    color: #29c;
  }
</style>
</head>
<body class="${theme}">

<h2 id="raport-expression-language-reference" style="text-align: center; margin-top: 1rem;">Raport Expression Language Reference</h2>
<p>As implied by Raport Expression Language (REL), the language is composed entirely of expessions. There are no statements. The expressions are composed only of operations and values.</p>
<h2 id="syntax">Syntax</h2>
<div class=indent>
<p>The root syntax is based on LISP, but the most common usage relies on sugared syntax that more closely resembles other common languages. The general LISP-y syntax is <code>([operator] ...args)</code>, where <code>args</code> are values or operations. The default parser will accept multiple expressions in sequence and automatically wrap them in a <code>block</code> operation.</p>
</div>

<h2 id="values">Values</h2>
<div class=indent>
<p>Built-in data types include numbers, strings, booleans, objects, arrays, applications, null, undefined, dates, and schemas. There is also a range pseudo-value available to certain operators that automaically parse it from a string in certain circumstances.</p>
<h3 id="numbers">Numbers</h3>
<p>Numbers may have an optional leading <code>-</code>, one or more digits, optionally separated by <code>_</code>, an optional <code>.</code> followed by one or more digits, optionally separated by <code>_</code>, and an optional <code>e</code> followed by an optional <code>-</code> and one or more digits, optionally separated by <code>_</code>.</p>
<p>Example: <code><span class=ast-nodes><span class="number">1</span></span></code>, <code><span class=ast-nodes><span class="number">-1</span></span></code>, <code><span class=ast-nodes><span class="number">0.1</span></span></code>, <code><span class=ast-nodes><span class="number">-0.1</span></span></code>, <code><span class=ast-nodes><span class="number">111_000</span></span></code>, <code><span class=ast-nodes><span class="number">-5_0</span></span></code>, <code><span class=ast-nodes><span class="number">3.14159e-10</span></span></code></p>
<h3 id="strings">Strings</h3>
<p>Strings come in three different flavors: symbolic, single-quoted with optional interpolation, and double-quoted. The symbolic form is constructed of a leading <code>:</code> followed character that is not whitespace or one of <code>():{}[]&lt;&gt;,;\\&amp;#</code> or a quote.</p>
<p>Single-quoted strings may be quoted with <code>&#39;</code> or <code>&#96;</code>, and interpolators are contained within <code>{}</code>, optionally prefixed with <code>$</code>.</p>
<p>Quoted strings may have any character within escaped with <code>\\</code>, including the interpolation delimiters within single-quoted strings. Any characters that are not the terminating quote are included in the string, including newlines.</p>
<p>Example: <code><span class=ast-nodes><span class="string">:foo22</span></span></code>, <code><span class=ast-nodes><span class="string">'test string'</span></span></code>, <code><span class=ast-nodes><span class="string">&quot;test string&quot;</span></span></code>, <code><span class=ast-nodes><span class="string"><span class="ast-extra">'an </span><span class="string-interpolation"><span class="ast-extra">{</span><span class="reference">interpolated</span><span class="ast-extra">}</span></span><span class="ast-extra"> string'</span></span></span></code></p>
<h3 id="booleans">Booleans</h3>
<p><code><span class="ast-nodes"><span class="primitive">true</span></span></code> and <code><span class="ast-nodes"><span class="primitive">false</span></span></code>. REL uses truthiness so as not to require explicit conversion of values to booleans. Anything that is not <code><span class="ast-nodes"><span class="primitive">null</span></span></code>, <code><span class="ast-nodes"><span class="primitive">undefined</span></span></code>, <code><span class="ast-nodes"><span class="primitive">false</span></span></code>, <code><span class="ast-nodes"><span class="number">0</span></span></code>, <code>NaN</code>, or an empty string is considered equivalent to <code><span class="ast-nodes"><span class="primitive">true</span></span></code>.</p>
<h3 id="objects">Objects</h3>
<p>Object literals consist of key/value pairs contained within <code>{}</code>s. Keys may be quoted, though it&#39;s only necessary for non-symbolic names or interpolation. Key/value pairs may be separated with <code>,</code>s, and the last pair may have a trailing <code>,</code>.</p>
<p>Example: <code><span class="ast-nodes"><span class="object"><span class="ast-extra">{ foo:</span><span class="string">:bar</span><span class="ast-extra"> baz:</span><span class="string">'bat'</span><span class="ast-extra"> bip:</span><span class="binary-op"><span class="reference">bop</span><span class="ast-extra"> * </span><span class="number">22</span></span><span class="ast-extra"> </span><span class="string">'some str'</span><span class="ast-extra">:</span><span class="number">99</span><span class="ast-extra"> </span><span class="string"><span class="ast-extra">'nine</span><span class="string-interpolation"><span class="ast-extra">{</span><span class="binary-op"><span class="number">9</span><span class="ast-extra"> + </span><span class="number">1</span></span><span class="ast-extra">}</span></span><span class="ast-extra">'</span></span><span class="ast-extra">:</span><span class="number">19</span><span class="ast-extra"> }</span></span></span></code></p>
<h3 id="arrays">Arrays</h3>
<p>Array literals consist of values contained within <code>[]</code>s. Values may be separated by <code>,</code>s, and the last value may have a trailing <code>,</code>.</p>
<p>Example: <code><span class="ast-nodes"><span class="array"><span class="ast-extra">[</span><span class="string">:a</span><span class="ast-extra"> </span><span class="string">:b</span><span class="ast-extra"> </span><span class="string">:c</span><span class="ast-extra"> </span><span class="number">1</span><span class="ast-extra"> </span><span class="number">2</span><span class="ast-extra"> </span><span class="number">3</span><span class="ast-extra">]</span></span></span></code></p>
<h3 id="applications">Applications</h3>
<p>An application is an expression that isn&#39;t immediately evaluated. Applications may optionally start with an argument list with named arguments listed between <code>||</code>s, then a required big arrow <code>=&gt;</code>, and an expression that may be enclosed in a block.</p>
<p>Example: <code><span class="ast-nodes"><span class="application"><span class="ast-extra">=&gt; </span><span class="binary-op"><span class="reference">_</span><span class="ast-extra"> + </span><span class="number">10</span></span></span></span></code>, <code><span class="ast-nodes"><span class="application"><span class="ast-extra">|a b c| =&gt; </span><span class="binary-op"><span class="reference">a</span><span class="ast-extra"> * </span><span class="reference">b</span><span class="ast-extra"> + </span><span class="reference">c</span></span></span></span></code></p>
<h3 id="null">Null</h3>
<p><code><span class="ast-nodes"><span class="primitive">null</span></span></code>. Null in a language with <code><span class="ast-nodes"><span class="primitive">undefined</span></span></code> is a bit of a strange concept, but it can be useful as a sort of &quot;this field intentionally left blank&quot; indicator. It also survives in JSON.</p>
<h3 id="undefined">Undefined</h3>
<p><code><span class="ast-nodes"><span class="primitive">undefined</span></span></code>. This will be omitted in JSON.</p>
<h3 id="dates">Dates</h3>
<p>Date literals include single dates, date ranges, and intervals of time. Dates are specified in a relaxed ISO-8601 format enclosed in <code>##</code>s. A date that isn&#39;t specified down to the millisecond is a range from the start of the specified time to the end e.g. <code><span class="ast-nodes"><span class="date">#2022-01-01#</span></span></code> spans from midnight to a millisecond before midnight on 2022-01-02. When dates are converted to an instant, the default is to resolve to the start of the range. To default to the end of the range, there can be a <code>&lt;</code> immediately before the closing <code>#</code>.</p>
<p>Example: <code><span class="ast-nodes"><span class="date">#2020#</span></span></code>, <code><span class="ast-nodes"><span class="date">#1999-01-01 17:45#</span></span></code>, <code><span class="ast-nodes"><span class="date">#1970-06-15T00:00:01.443+04:30#</span></span></code></p>
<p>Intervals are also specified enclosed in <code>##</code>s with each portion of the interval, optionally separated by spaces. Intervals may include years, months, weeks, days, hours, minutes, seconds, and milliseconds.</p>
<p>Example: <code><span class="ast-nodes"><span class="date">#2 years#</span></span></code>, <code><span class="ast-nodes"><span class="date">#5M3d#</span></span></code>, <code><span class="ast-nodes"><span class="date">#15 weeks 2 days 9 minutes 17 seconds#</span></span></code></p>
<p>There are also a few special relative dates available: <code><span class="ast-nodes"><span class="date">#yesterday#</span></span></code>, <code><span class="ast-nodes"><span class="date">#today#</span></span></code>, <code><span class="ast-nodes"><span class="date">#tomorrow#</span></span></code>, <code><span class="ast-nodes"><span class="date">#last week#</span></span></code>, <code><span class="ast-nodes"><span class="date">#this week#</span></span></code>, <code><span class="ast-nodes"><span class="date">#next week#</span></span></code>, <code><span class="ast-nodes"><span class="date">#last month#</span></span></code>, <code><span class="ast-nodes"><span class="date">#this month#</span></span></code>, <code><span class="ast-nodes"><span class="date">#next month#</span></span></code>, <code><span class="ast-nodes"><span class="date">#last year#</span></span></code>, <code><span class="ast-nodes"><span class="date">#this year#</span></span></code>, and <code><span class="ast-nodes"><span class="date">#next year#</span></span></code>. Like the ISO-ish dates, these are ranges that cover their narrowest specification, so last week is from midnight on the first day of the week to the last millisecond of the last day of the week.</p>
<h3 id="schemas">Schemas</h3>
<p>Schemas describe the type structure of a value. They consist of any number of type definitions followed by the root definition and are contained within <code>@[]</code>.</p>
<ul>
<li>Built-in primitive types include <code>number</code>, <code>string</code>, <code>boolean</code>, <code>date</code>, and <code>any</code>.</li>
<li>Types may also be followed by <code>[]</code> to indicate an array of that type of any length e.g. <code>string[]</code>. Complex array types may also be specified by wrapping a type within an <code>Array&lt;&gt;</code> e.g. <code>Array&lt;string|number&gt;</code>.</li>
<li>Literal values are also accepted as types e.g. <code>12</code> is a type that only matches the number <code>12</code>, and <code>&#39;yes&#39;</code> is a type that only matches the string <code>&quot;yes&quot;</code>.<ul>
<li>Other supported literal values are <code>true</code>, <code>false</code>, <code>null</code>, and <code>undefined</code>.</li>
</ul>
</li>
<li>Tuple types are composed of an array literal of other types e.g. <code>[number number boolean]</code> will match the value <code>[10 12 false]</code>.</li>
<li>Type unions are composed by separating types with a <code>|</code> e.g. <code>string|number</code> will match a string or number.</li>
<li>Object types are specified as object literals with types as the values of their pairs e.g. <code>{ a:number b:string }</code> will match the value <code>{ a:21 b::sure }</code>.<ul>
<li>Any key within an object type may be marked as optional by following its name with a <code>?</code> e.g. <code>{ a:number b?:date }</code> will match the value <code>{ a:21 }</code>.</li>
<li>All remaining keys can be matched with the special key <code>...</code> to ensure that any other keys within an object match a certain type e.g. <code>{ a:number ...:string }</code> will match any object with an <code>a</code> key that is a number and all other keys, if any, that have string values.</li>
</ul>
</li>
<li>Type aliases may be defined using the <code>type</code> keyword followed by a name and a definition e.g. <code>type Foo = { a:number b:string }</code>, followed by at least one whitespace or <code>;</code>. Type aliases may be used anywhere a primitive type would be, including in unions, tuples, and with array specifiers.</li>
<li>Any type may have conditions that are specified as applications that receive the value being validated and return true or false. Conditions are specified with a trailing <code>?</code> and application e.g. <code>type LargeNumber = number ? =&gt; _ &gt; 100000000</code>. More than one condition may be applied to a type.</li>
</ul>
<p>Example: <code><span class="ast-nodes"><span class="typelit"><span class="ast-extra">@[</span><span class="type">number</span><span class="ast-extra">|</span><span class="type">string</span><span class="ast-extra">]</span></span></span></code>, <code><span class="ast-nodes"><span class="typelit"><span class="ast-extra">@[type </span><span class="type">Foo</span><span class="ast-extra"> = { </span><span class="key">t</span><span class="ast-extra">:</span><span class="literal">'strings'</span><span class="ast-extra">, ...:</span><span class="type">string</span><span class="ast-extra"> }; type </span><span class="type">Bar</span><span class="ast-extra"> = { </span><span class="key">t</span><span class="ast-extra">:</span><span class="literal">'numbers'</span><span class="ast-extra">, ...:</span><span class="type">number</span><span class="ast-extra"> }; Array&lt;</span><span class="type">Foo</span><span class="ast-extra">|</span><span class="type">Bar</span><span class="ast-extra">&gt;]</span></span></span></code></p>
<h3 id="ranges">Ranges</h3>
<p>Ranges don&#39;t have any special syntax built directly into REL, but there is a built-in parser that several operators use to see if numbers fall into ranges. The range itself is an array of arrays or numbers, where a number is considered to be in the range if it appears directly in the array or in the inclusive range bounded by the first and second elements of an inner array. The components of a range may be specified by any of the following, separated by whitespace and optionally <code>,</code>s:</p>
<ul>
<li>Any integer, indicating exactly that integer</li>
<li>Two integers with nothing but a <code>-</code> between them, indicating any number that falls within the inclusive range of the left and right integer</li>
<li>a <code>&lt;</code> followed by an integer with optional preceding whitespace, indicating any number less than the integer</li>
<li>a <code>&gt;</code> followed by an integer with optional preceding whitespace, indicating any number greater than the integer</li>
<li>a <code>!</code> followed by any of the preceding range types, indicating that the range type should be excluded from the range</li>
<li>a <code>*</code>, indicating any number</li>
</ul>
<p>Exmaple: <code><span class="ast-nodes"><span class="string">'1, 3, 5, 7, &gt;10'</span></span></code>, <code><span class="ast-nodes"><span class="string">'22-33 44 55-66'</span></span></code>, <code><span class="ast-nodes"><span class="string">'1-100 !23 !34 !88'</span></span></code></p>
</div>

<h2 id="references">References</h2>
<div class=indent>
<p>REL is built around contexts that are somewhat analogous to stack frames that have an inherent base value. When an expression is being evaluated there is usually some value that is currently in scope as the focus of the context. The value of at the base of the current scope is available as the special reference <code><span class="ast-nodes"><span class="reference">@value</span></span></code> or <code>_</code>. If the value happens to have properties, they can be referenced directly by their names e.g. in a context with a value of <code>{ foo: 21, bar: 22 }</code>, the reference <code><span class="ast-nodes"><span class="reference">foo</span></span></code> will resolve to <code>21</code> when evaluated.</p>
<p>Each context also has a local lexical scope attached to it that is not directly connected with the underlying data in the context. This allows for passing named arguments to applications or utilyzing locally scoped variables without clobbering the associated data in the context. Some operators will introduce a new lexical scope while retaining the exising context, while others may introduce both a new context and a new lexical scope.</p>
<p>If the value resolved by a reference happens to have a nested structure built of objects and/or arrays, further children of the primary property can be accessed using dotted path or bracketed path notation e.g. <code><span class="ast-nodes"><span class="reference">foo.bar</span></span></code>, <code><span class="ast-nodes"><span class="reference">array.1.prop</span></span></code> or <code><span class="ast-nodes"><span class="reference"><span class="ast-extra">array[</span><span class="number">1</span><span class="ast-extra">].prop</span></span></span></code>, and <code><span class="ast-nodes"><span class="reference"><span class="ast-extra">foo[</span><span class="binary-op"><span class="string">:ba</span><span class="ast-extra"> + </span><span class="string">:r</span></span><span class="ast-extra">]</span></span></span></code>. The bracketed notation allows for expressions to be used when resolving names. References are always resolved safely to <code>undefined</code>, so doing something like <code><span class="ast-nodes"><span class="binary-op"><span class="object"><span class="ast-extra">{ foo:</span><span class="string">:bar</span><span class="ast-extra"> }</span></span><span class="ast-extra">.baz.bat</span></span></span></code> does not cause an error.</p>
<p>Any variables defined in the lexical scope will take precedent over values of the same name in the local context. To access a value in the context that has the same name as a local variable, you can start from the context special reference e.g. <code><span class="ast-nodes"><span class="reference">_.foo</span></span></code> would refer to the context <code>foo</code> value where <code><span class="ast-nodes"><span class="reference">foo</span></span></code> refers to a local variable.</p>
<h3 id="prefixes">Prefixes</h3>
<p>As indicated above, there are certain special references available in certain contexts. These references have the prefix <code>@</code>, and <code><span class="ast-nodes"><span class="reference">@value</span></span></code> is always available. Another example of a special reference is <code><span class="ast-nodes"><span class="reference">@index</span></span></code>, which is often available in contexts where iteration is taking place.</p>
<p>Report definitions may include named parameters that are kept in a separate namespace from the report root context value. These values are available in any context by prefixing their name with a <code>!</code> e.g. <code><span class="ast-nodes"><span class="reference">!date</span></span></code> would resolve the value passed for the <code>date</code> parameter.</p>
<p>Parent contexts are also available from their children by applying the context pop prefix <code>^</code> one or more times to a reference e.g. <code><span class="ast-nodes"><span class="reference">^foo</span></span></code> will resolve to whatever <code><span class="ast-nodes"><span class="reference">foo</span></span></code> would resolve to in the parent context, and <code><span class="ast-nodes"><span class="reference"><span class="ast-extra">^^^foo.bar[</span><span class="number">9</span><span class="ast-extra">]</span></span></span></code> will resolve to whatever <code><span class="ast-nodes"><span class="reference"><span class="ast-extra">foo.bar[</span><span class="number">9</span><span class="ast-extra">]</span></span></span></code> would resolve to in the great-grandparent context.</p>
<p>The root context value is also available in any context by prefixing a reference with the root context prefix <code>~</code> e.g. <code><span class="ast-nodes"><span class="reference">~foo.bar</span></span></code> will resolve to <code><span class="ast-nodes"><span class="reference">foo.bar</span></span></code> in the root context.</p>
<p>Report definitions may include named data sources that are kept in a separate namespace from the report root context value.  These data sources are available in any context by prefixing their name with a <code>*</code> e.g. <code><span class="ast-nodes"><span class="reference">*people</span></span></code> would resolve to the data passed or retrieved for the <code>people</code> data source.</p>
</div>

<h2 id="comments">Comments</h2>
<div class=indent>
<p>Any expression may be preceeded by any number of line comments, which start with <code>//</code> and include any subsequent characters up to a newline. The final line may not be comment, as comments must be followed by an expression.</p>
<p>Example: <pre><code><span class="ast-nodes"><span class="comment">// add a and b
</span><span class="binary-op"><span class="reference">a</span><span class="ast-extra"> + </span><span class="reference">b</span></span></span></code></pre></p>
</div>

<h2 id="variables">Variables</h2>
<div class=indent>
<p>Most of the data accessed in REL comes from a data source, and as such, it doesn&#39;t often make sense to change any values. There are some cases where local variables can be quite useful to allow breaking up complex calculations into steps or to foward an alias into an algorithm. For these purposes, REL has <code>let</code> and <code>set</code> operators, which change a value in the local lexical scope and local context, respectively. The <code>let</code> operator works with the <code>^</code> prefix to allow accessing parent scopes. The <code>set</code> operator works with <code>~</code> and <code>^</code> prefixes to allow working with the root and parent contexts.</p>
<p>Example: <code><span class="ast-nodes"><span class="let"><span class="ast-extra">let </span><span class="reference">foo</span><span class="ast-extra"> = </span><span class="number">10</span></span></span></code>, <code><span class="ast-nodes"><span class="set"><span class="ast-extra">set </span><span class="reference">~name</span><span class="ast-extra"> = </span><span class="string">:Joe</span></span></span></code>, <code><span class="ast-nodes"><span class="let"><span class="ast-extra">let </span><span class="reference">^^type</span><span class="ast-extra"> = </span><span class="object"><span class="ast-extra">{ size: </span><span class="number">22</span><span class="ast-extra">, id:</span><span class="string">:1</span><span class="ast-extra"> }</span></span></span></span></code></p>
</div>

<h2 id="operations">Operations</h2>
<div class=indent>
<p>Operators are the foundational component of REL, as everything within REL other than a few of the primitive literals, references, and comments are built as operators. An operator may be called using LISP syntax, call syntax, or in many cases special syntax such as unary or boolean syntax. The following are equivalent:</p>
<ul>
<li><code><span class="ast-nodes"><span class="s-expression"><span class="ast-extra">(if </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &gt; </span><span class="number">10</span></span><span class="ast-extra"> </span><span class="string">:large</span><span class="ast-extra"> </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &lt; </span><span class="number">5</span></span><span class="ast-extra"> </span><span class="string">:small</span><span class="ast-extra"> </span><span class="string">:medium</span><span class="ast-extra">)</span></span></span></code></li>
<li><code><span class="ast-nodes"><span class="call"><span class="ast-extra">if(</span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &gt; </span><span class="number">10</span></span><span class="ast-extra"> </span><span class="string">:large</span><span class="ast-extra"> </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &lt; </span><span class="number">5</span></span><span class="ast-extra"> </span><span class="string">:small</span><span class="ast-extra"> </span><span class="string">:medium</span><span class="ast-extra">)</span></span></span></code></li>
<li><code><span class="ast-nodes"><span class="conditional"><span class="ast-extra">if </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &gt; </span><span class="number">10</span></span><span class="ast-extra"> then </span><span class="string">:large</span><span class="ast-extra"> elif </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &lt; </span><span class="number">5</span></span><span class="ast-extra"> then </span><span class="string">:small</span><span class="ast-extra"> else </span><span class="string">:medium</span></span></span></code></li>
<li><code><span class="ast-nodes"><span class="conditional"><span class="ast-extra">if </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &gt; </span><span class="number">10</span></span><span class="ast-extra"> </span><span class="block"><span class="ast-extra">{ </span><span class="string">:large</span><span class="ast-extra"> }</span></span><span class="ast-extra"> elif </span><span class="binary-op"><span class="reference">foo</span><span class="ast-extra"> &lt; </span><span class="number">5</span></span><span class="ast-extra"> </span><span class="block"><span class="ast-extra">{ </span><span class="string">:small</span><span class="ast-extra"> }</span></span><span class="ast-extra"> else </span><span class="block"><span class="ast-extra">{ </span><span class="string">:medium</span><span class="ast-extra"> }</span></span></span></span></code></li>
</ul>
<p>Most operators are limited to LISP and call syntax because that&#39;s how they&#39;re most reasonably used. <code>+</code>, <code>-</code>, and <code>not</code> are available as unary operators. Supported binary operators in order of precedence are exponentiation (<code>**</code>), mutiplication/division/modulus/int division (<code>*</code>, <code>/</code>, <code>%</code>, <code>/%</code>), addition/subtraction (<code>+</code>, <code>-</code>), comparison (<code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>ilike</code>, <code>in</code>, <code>like</code>, <code>not-ilike</code>, <code>not-like</code>, <code>not-in</code>, <code>contains</code>, <code>does-not-contain</code>, <code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code>), equality (<code>is</code>, <code>is-not</code>, <code>==</code>, <code>!=</code>, <code>deep-is</code>, <code>deep-is-not</code>, <code>strict-is</code>, <code>strict-is-not</code>, <code>===</code>, <code>!==</code>), boolean and (<code>and</code>, <code>&amp;&amp;</code>), boolean or (<code>or</code>, <code>\|\|</code>) and nullish coalescing (<code>??</code>). At least one space is required on either side of a binary operator.</p>
<p>Most operators take a number of arguments, which are passed within their <code>()</code>s. Some operators will evaluate their arguments lazily, like <code>and</code> and <code>or</code>, and others will evaluate all of their arguments before processing them. Some operators will implicitly operate on their nearest data source, and these are internally configured as aggregate operators, including <code>sum</code> and <code>avg</code>.</p>
<p>Call operations may be attached to a reference such that the reference further refines the result of the call operation.</p>
<p>Example: <code><span class="ast-nodes"><span class="binary-op"><span class="call"><span class="ast-extra">find(</span><span class="reference">list</span><span class="ast-extra"> </span><span class="application"><span class="ast-extra">=&gt;</span><span class="binary-op"><span class="call"><span class="ast-extra">len(</span><span class="reference">parts</span><span class="ast-extra">)</span></span><span class="ast-extra"> &gt; </span><span class="number">10</span></span></span><span class="ast-extra">)</span></span><span class="ast-extra">.name</span></span></span></code></p>
<h3 id="named-arguments">Named arguments</h3>
<p>Operators that are called in LISP or call syntax may also accept named arguments that are specified as key/value pairs at the end of the argument list. These are often used to control specialized behavior or the operator using flags that would otherwise be cumbersome as positional arguments e.g. <code><span class="ast-nodes"><span class="call"><span class="ast-extra">parse(</span><span class="string">'1 3 5 7'</span><span class="ast-extra"> range:</span><span class="number">1</span><span class="ast-extra">)</span></span></span></code>, which asks the <code>parse</code> operator to parse the given string as a range rather than the default REL expression.</p>
<h3 id="formats">Formats</h3>
<p>There is a built-in format operator that formats values as strings using registered formatters. One example is the <code>date</code> formatter that outputs <code>date</code> values as strings in the <code>yyyy-MM-dd</code> format by default. It can also accept an argument that specifies the format to use when converting the date to a string. The <code>format</code> operator can be called explicitly or, since formatting values as strings is a fairly common need, using a special postfix format operation syntax that is a <code>#</code> followed by the name of the formatter and optionally any argument expressions separated by <code>,</code>s with no whitespaces. The following are equivalent:</p>
<ul>
<li><code><span class="ast-nodes"><span class="call"><span class="ast-extra">format(</span><span class="reference">@date</span><span class="ast-extra"> </span><span class="string">:date</span><span class="ast-extra"> </span><span class="string">'MM/dd/yyyy'</span><span class="ast-extra">)</span></span></span></code></li>
<li><code><span class="ast-nodes"><span class="binary-op"><span class="reference">@date</span><span class="format-op"><span class="ast-extra">#date,</span><span class="string">'MM/dd/yyyy'</span></span></span></span></code></li>
</ul>
<h3 id="pipes">Pipes</h3>
<p>Processing data often calls operators on the results of calling operators on the results of calling operators, resulting in large nested argument lists that can become hard to keep track of. To address this, REL has a special built-in <code>pipe</code> operator that accepts a starting value and forwards it through the list of calls supplied to it as arguments, replacing the value with the result of the previous call each time. If one of the arguments to a call is <code>_</code>, the call will be evaluated as-is, but if no reference to <code>_</code> appears in the call arguments list, <code>_</code> will be supplied as the first argument. The following are equivalent:</p>
<ul>
<li><code><span class="ast-nodes"><span class="call"><span class="ast-extra">join(</span><span class="call"><span class="ast-extra">map(</span><span class="call"><span class="ast-extra">filter(</span><span class="reference">things</span><span class="ast-extra"> </span><span class="application"><span class="ast-extra">=&gt;</span><span class="binary-op"><span class="reference">count</span><span class="ast-extra"> &gt; </span><span class="number">10</span></span></span><span class="ast-extra">)</span></span><span class="ast-extra"> </span><span class="application"><span class="ast-extra">=&gt;</span><span class="reference">name</span></span><span class="ast-extra">)</span></span><span class="ast-extra"> </span><span class="string">', '</span><span class="ast-extra">)</span></span></span></code></li>
<li><code><span class="ast-nodes"><span class="call"><span class="ast-extra">pipe(</span><span class="reference">things</span><span class="ast-extra"> </span><span class="call"><span class="ast-extra">filter(</span><span class="application"><span class="ast-extra">=&gt;</span><span class="binary-op"><span class="reference">count</span><span class="ast-extra"> &gt; </span><span class="number">10</span></span></span><span class="ast-extra">)</span></span><span class="ast-extra"> </span><span class="call"><span class="ast-extra">map(</span><span class="application"><span class="ast-extra">=&gt;</span><span class="reference">name</span></span><span class="ast-extra">)</span></span><span class="ast-extra"> </span><span class="call"><span class="ast-extra">join(</span><span class="string">', '</span><span class="ast-extra">)</span></span><span class="ast-extra">)</span></span></span></code></li>
</ul>
<p>The latter is a bit longer, but considerably more easy to follow.</p>
</div>

<h2 id="flow-control">Flow Control</h2>
<div class=indent>
<h3 id="block">block</h3>
<p>A block isn&#39;t really flow control, but being an expression-based language, a way to execute a number of expressions ignoring results until the final expression is quite useful. The <code>block</code> operator does just that. The built-in syntax for a block operation is one or more expressions placed with <code>{}</code>s, separated by whitespace and/or <code>;</code>s.</p>
<p>Blocks introduce their own lexical scope, so any variables declared within them will not escape their scope. You can still access parent contexts though, so it is possible to <code>let</code> variables from any context that is parent to the block scope using the appropriate reference.</p>
<p>Exmaple: <code><span class="ast-nodes"><span class="block"><span class="ast-extra">{ </span><span class="let"><span class="ast-extra">let </span><span class="reference">a</span><span class="ast-extra"> = </span><span class="number">10</span></span><span class="ast-extra">; </span><span class="let"><span class="ast-extra">let </span><span class="reference">b</span><span class="ast-extra"> = </span><span class="number">20</span></span><span class="ast-extra">; </span><span class="binary-op"><span class="reference">a</span><span class="ast-extra"> + </span><span class="reference">b</span></span><span class="ast-extra"> }</span></span></span></code></p>
<h3 id="if">if</h3>
<p>The primary form of conditional flow control is handled by the <code>if</code> operator, which takes a conditional argument followed by a truth case expression, any number of additional conditional and truth case expressions, and then an optional alternate expression. As an operator, <code>if</code> may be called as any other operator, but there is also built-in syntax to make it slightly more readable in the form <code>if</code> followed by a condition, <code>then</code>, and an expression; followed by any number of alternate conditions and expressions in the form <code>else if</code> or <code>elseif</code> or <code>elsif</code> or <code>elif</code> followed by <code>then</code> and the value expression; optionally followed by <code>else</code> and a final alternate value expression.</p>
<p>The result of an <code>if</code> expression is the value of the value expression paired with the first matching conditional branch, the value of the final alternate branch if no conditions matched, or <code>undefined</code> if there were no matches and no final alternate value.</p>
<p>If an <code>if</code> needs to be nested in a way that may make further conditionals ambiguous, the expression can be ended with <code>end</code> or <code>fi</code>. The value expression of a branch may also be a block, which will also remove any ambiguity.</p>
<p>Example: <code><span class="ast-nodes"><span class="conditional"><span class="ast-extra">if </span><span class="binary-op"><span class="reference">count</span><span class="ast-extra"> &gt; </span><span class="number">23</span></span><span class="ast-extra"> then </span><span class="string">'there are dozens of us!'</span><span class="ast-extra"> elif </span><span class="binary-op"><span class="reference">count</span><span class="ast-extra"> &lt; </span><span class="number">0</span></span><span class="ast-extra"> then </span><span class="string">'not sure what happened'</span><span class="ast-extra"> else </span><span class="string">'something else'</span></span></span></code>, <code><span class="ast-nodes"><span class="conditional"><span class="ast-extra">if </span><span class="binary-op"><span class="reference">a</span><span class="ast-extra"> &gt; </span><span class="reference">b</span></span><span class="ast-extra"> then </span><span class="conditional"><span class="ast-extra">if </span><span class="binary-op"><span class="reference">b</span><span class="ast-extra"> &lt; </span><span class="number">12</span></span><span class="ast-extra"> then </span><span class="string">:c</span><span class="ast-extra"> else </span><span class="string">:d</span><span class="ast-extra"> end</span></span><span class="ast-extra"> elif </span><span class="binary-op"><span class="reference">b</span><span class="ast-extra"> &gt; </span><span class="reference">a</span></span><span class="ast-extra"> then </span><span class="string">:e</span><span class="ast-extra"> else </span><span class="string">:f</span></span></span></code></p>
<h3 id="unless">unless</h3>
<p>Unless is a negated <code>if</code>. If the conditional expression evaluates to a truthy value, then the value expression will be the result. <code>unless</code> also allows for an alternate value expression but does not allow additional condition cases. The built-in unless syntax starts with <code>unless</code> followed by a conditional expression, followed by <code>then</code> and a value expression, optionally followed by <code>else</code> and an alternate value expression, optionally followed by <code>end</code>.</p>
<p>Example: <code><span class="ast-nodes"><span class="conditional"><span class="ast-extra">unless </span><span class="reference">loggedIn</span><span class="ast-extra"> then </span><span class="string">'Please log in'</span></span></span></code></p>
<h3 id="case">case</h3>
<p>REL also has a case operator that allows for an alternate branch style that may be more comprehensible in some cases. Each branch condition is evaluated lazily, and if it is an expression will have the value being evaluated available as the special <code>@case</code> reference. If using the built-in syntax, <code>_</code> will also evaluate to <code>@case</code>. <code>case</code> expressions begin with <code>case</code> followed by a value expression, followed by any number of branches that start with <code>when</code> followed by a conditional value or expression, followed by <code>then</code> and a value expression, and finally optionally ending with an alternate <code>else</code> and value expression and optional <code>end</code> or <code>esac</code>.</p>
<p>Example:</p>
<pre><code><span class="ast-nodes"><span class="ast-extra">case </span><span class="reference">age</span><span class="ast-extra">
  when </span><span class="binary-op"><span class="reference">_</span><span class="ast-extra"> &lt; </span><span class="number">13</span></span><span class="ast-extra"> then </span><span class="string">'ask a parent'</span><span class="ast-extra">
  when </span><span class="number">15</span><span class="ast-extra"> then </span><span class="string">'happy quinceanera'</span><span class="ast-extra">
  when </span><span class="number">99</span><span class="ast-extra"> then </span><span class="string">'last year for legos, friend'</span><span class="ast-extra">
  when </span><span class="binary-op"><span class="reference">_</span><span class="ast-extra"> &gt;= </span><span class="number">18</span></span><span class="ast-extra"> then </span><span class="string">'ok'</span><span class="ast-extra">
  else </span><span class="string">'NaN, I guess'</span></span>
</code></pre>
</div>

<h2>Styled Text</h2>
<div class=indent>
<p>Reports often benefit from styled text, and while most of the raport controls include properties that style their rendered text, it is usually only easily applied to the entire string at once. Labels can be split into an array of parts that are individually styled, but that makes interpolation within the label text difficult when flow control and styling interleave. To address this, raport also provides a light markup language that can be used to apply styling to plain text.</p>
<p>The syntax consists of markup tags interspersed within the text, where each tag may include multiple properties that are inline or block and boolean or valued. Inline properties are typically boolean and can be enabled and disabled at any place within the text. Block properties are grouped with other block properties within their initial tag and are enabled and disabled together. Boolean properties are toggled with each tag, and valued properties form a stack.</p>
<p>A tag is delimited by <code>|</code>s, and the properties within are delimited with <code>,</code>s. Valued properties specify their value with an <code>=</code>, which pushes a value onto the stack. Valued properties specified without a value will pop a value from the stack. Properties are named as identifiers, some of which also have shorthand aliases.</p>
<h3>Inline Properties</h3>
<p>Inline properties are treated as a flat structure, so that they can be interleaved. For instance, <code>this |b|is |i|a|b| test|i| string</code> will yield <code>this</code> plain, <code>is</code> bolded, <code>a</code> bolded and italicized, test italicized, and string plain. <code>|b,u|this is bold and underlined</code> will render the entire text bolded and underlined.</p>
<ul>
<li><code>background</code>, <code>back</code>, <code>bg</code> - sets the background color of the marked text to the given color specified in hexadecimal <code>rgb</code>, <code>rgba</code>, <code>rrggbb</code>, or <code>rrggbbaa</code>, optionally prefixed with a <code>#</code> e.g., <code>|bg=000|</code> or <code>|bg=#08296b|</code>.</li>
<li><code>bold</code>, <code>b</code> - bolds the marked text</li>
<li><code>br</code> - a special tag that inserts a line break. Multiple <code>br</code> tags may appear together to insert multiple line breaks e.g., <code>|br,br,br|</code> produces three line breaks.</li>
<li><code>color</code>, <code>fore</code>, <code>fg</code> - sets the text color of the marked text to the given color specified in hexadecimal <code>rgb</code>, <code>rgba</code>, <code>rrggbb</code>, or <code>rrggbbaa</code>, optionally prefixed with a <code>#</code> e.g., <code>|fg=#f00|</code>.</li>
<li><code>font</code> - sets the font for the marked text to the given value, which is read up to the next <code>,</code> or <code>|</code> e.g., <code>|font=liberation sans narrow|</code>.</li>
<li><code>italic</code>, <code>i</code> - italicizes the marked text</li>
<li><code>line</code> - sets the line height of the marked text to the given value in <code>rem</code> e.g., <code>|line=2.2|</code> sets the line height to 220% of the default 1rem. The decimal is optional.</li>
<li><code>overline</code> - adds an overline to the marked text</li>
<li><code>pre</code> - treats the marked text as white space sensitive</li>
<li><code>size</code> - sets the font size of the marked text to the given size in <code>rem</code> e.g., <code>|font=2.2|</code> sets the font size to 220% of the default. The decimal is optional.</li>
<li><code>strike</code> - adds a strike-through to the marked text</li>
<li><code>sub</code> - sets the marked text as subscripted</li>
<li><code>sup</code> - sets the marked text as superscripted</li>
<li><code>valign</code> - sets the marked text to vertically align with surrounding text to the given value, which may be <code>top</code>, <code>middle</code>, <code>base</code>, or <code>bottom</code>, corresponding to the top, center, baseline, and bottom e.g., <code>|valign=bottom|</code>.</li>
</ul>
<h3>Block Properties</h3>
<p>Block properties create a block around their content and contain any subsequent content until a closing property for one of the values in the initial tag is encountered e.g., <code>|w=10,align=middle center,border=1|this is in the block.|i|as is this.|w| this is not, but is still italicized</code>. By default, the contents of a block may not exceed its bounds.</p>
<ul>
<li><code>align</code> - sets the vertical and/or horizontal alignment of the block content. One or two values may be specified in any order with <code>top</code>, <code>middle</code>, <code>base</code>, and <code>bottom</code> specifying vertical alignment and <code>left</code>, <code>center</code>, and <code>right</code> specifying horizontal alignment.</li>
<li><code>background</code>, <code>back</code>, <code>bg</code> - sets the background color of the block. This is a special case of the inline <code>bg</code> property that will also end with the block.</li>
<li><code>border</code> - sets the border of block. The value given for a border property must include at least one width, but the rest of the properties are optional. The full signature is <code>[solid|dash|dot|double] &lt;width1&gt; [width2] [width3] [width4] [/ &lt;radius&gt; [radius2] [radius3] [radius4]] [color]</code>. If a type is not specified, it defaults to <code>solid</code>. The behavior of width1-4 depends on how many are supplied: 1 makes all four borders to width1; 2 sets the top and bottom to width1 and the left and right to width2; 3 sets top to width 1, right and left to width2, and bottom to width3; and 4 sets the top, right, bottom, and left to width1, width2, width3, and width4, respectively. Width values are integers and specify pixels. The radius value behaves similarly, but corresponds to the top-left, top-right, bottom-right, and bottom-left radii. Radius values can be decimals and specify <code>rem</code>. The color can be specified in hexadecimal <code>rgb</code>, <code>rgba</code>, <code>rrggbb</code>, or <code>rrggbbaa</code> with an optional leading <code>#</code>.</li>
<li><code>height</code>, <code>h</code> - sets the height of the block in <code>rem</code>, e.g., <code>|h=10|this is 10rem tall</code>. The height does not include any padding or margin, in contrast to the behavior of the height and margin properties of raport widgets. Height may also be set as a percentage of its container, making it easier to align text within a widget e.g., <code>|h=100%,align=middle|this is centered in the container</code>.</li>
<li><code>margin</code> - sets the margin of the block in <code>rem</code>. The value specified may be a decimal, and up to four values may be provided. If one is provided, all four sides will have the given value. If two are specified, the top and left will be set to the first, and the left and right will be set to the second. If three are specified, the top will be set to the first, the left and right will be set to the second, and the bottom will be set to the third. If four are specified, they will correspond to the top, right, bottom, and left values. Margins will add to any height or width values given.</li>
<li><code>move</code> - translates the block by the given <code>x</code> and <code>y</code> amounts. The coordinates may be specified as numbers corresponding to <code>rem</code> or percentages. The order of <code>move</code> and <code>rotate</code> tags will affect how they are applied.</li>
<li><code>nowrap</code> - specifies that text within the block should not wrap.</li>
<li><code>overflow</code> - specifies that the contents of the block may exceed its bounds.</li>
<li><code>pad</code> - sets the padding of the block in <code>rem</code>. The value specified may be a decimal, and up to four values may be provided. If one is provided, all four sides will have the given value. If two are specified, the top and left will be set to the first, and the left and right will be set to the second. If three are specified, the top will be set to the first, the left and right will be set to the second, and the bottom will be set to the third. If four are specified, they will correspond to the top, right, bottom, and left values. Padding will add to any height or width values given.</li>
<li><code>rotate</code> - rotates the block by the given number of turns. The direction may be specified as <code>left</code> or <code>right</code> and defaults to right. An addition set of coordinates may be supplied to set the point of rotation, and they may be numbers corresponding to <code>rem</code>, percentages, or relative values <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, and <code>center</code>. The order of <code>move</code> and <code>rotate</code> tags will affect how they are applied.</li>
<li><code>width</code>, <code>w</code> - sets the width of the block in <code>rem</code>, e.g., <code>|w=10|this is 10rem wide</code>. The width does not include any padding or margin, in contrast to the behavior of the width and margin properties of raport widgets. Width may also be set as a percentage of its container, making it easier to align text within a widget e.g., <code>|w=100%,align=center|this is centered in the container</code>.</li>
</ul>
</div>

</body>
</html>`;
    }

    const docs = {
        operators: [],
        operatorText: {},
    };
    {
        const ops = evaluate(operators);
        for (const doc of ops) {
            const op = Array.isArray(doc.op) ? doc.op[0] : doc.op;
            const txt = `${op}${Array.isArray(doc.op) ? ` (alias ${doc.op.filter(n => n !== op).join(', ')})` : ''}
---${doc.note ? `
NOTE: ${doc.note}
` : ''}
${doc.sig.map(s => `${s.proto}${s.bin ? '        (can be binary)' : ''}${s.un ? '        (can be unary)' : ''}\n  ${s.desc}\n`).join('\n')}${doc.opts ? `

Options
---
${doc.opts.map(o => `${Array.isArray(o.name) ? `${o.name[0]} (alias ${o.name.slice(1).join(', ')})` : o.name} - ${o.type}\n  ${o.desc}\n`).join('\n')}` : ''}`;
            const all = Array.isArray(doc.op) ? doc.op : [doc.op];
            all.forEach((n, i) => {
                docs.operatorText[n] = txt;
                docs.operators.push(Object.assign({}, doc, i === 0 ? { op: n } : { op: n, alias: all[0] }));
            });
        }
        const fmts = evaluate(formats);
        for (const f of fmts) {
            const all = Array.isArray(f.name) ? f.name : [f.name];
            all.forEach((n, i) => {
                const op = `#${n}`;
                const val = { op, sig: [{ fmt: 1, proto: op, desc: f.desc }], opts: f.opts };
                if (i > 0)
                    val.alias = true;
                docs.operators.push(val);
                const txt = `${n}${all.length > 1 ? ` (alias: ${all.filter(nn => n !== nn).join(', ')})` : ''}${f.opts ? ` - #${n},${f.opts.map(o => `${o.name}${o.req ? '' : '?'}`).join(',')}` : ''}
${f.desc ? `${f.desc}
` : ''}
${f.opts ? `
Arguments
---
${f.opts.map(o => `${o.name} - ${o.type}\n  ${o.desc}\n`).join('\n')}` : ''}`;
                docs.operatorText[op] = txt;
            });
        }
    }
    let sourceTm;
    const darkTheme = { fg: '#ccc', bg: '#222', border: '#555555', highlight: '#ddd', dark: '#444444', active: '#265189', hover: '#167808', error: '#a00', btntxt: '#ddd', code: { c1: '#ccc', c2: '#ccc', c3: '#1ca', c4: '#e81', c5: '#2a0', c6: '#e78', c7: '#6c3', c8: '#e82', c9: '#67f', c10: '#89d', c11: '#4bc', c12: '#1de', c13: '#29c', c14: '#888', c20: '#f00', }, };
    const lightTheme = { fg: '#222', bg: '#fff', border: '#cccccc', highlight: '#000', dark: '#999999', active: '#4596ff', hover: '#26bf10', error: '#8b0000', btntxt: '#fff', code: { c1: '#555', c2: '#222', c3: '#164', c4: '#951', c5: '#a11', c6: '#708', c7: '#371', c8: '#630', c9: '#45c', c10: '#239', c11: '#167', c12: '#189', c13: '#145', c14: '#888', c20: '#f00', }, };
    let autosizeTm;
    const binops = ['**', '*', '/%', '/', '%', '+', '-', '>=', '>', '<=', '<', '??', 'gt', 'gte', 'lt', 'lte', 'in', 'like', 'ilike', 'not-in', 'not-like', 'not-ilike', 'contains', 'does-not-contain', 'is', 'is-not', '==', '!=', '===', '!==', 'strict-is', 'strict-is-not', 'deep-is', 'deep-is-not', 'and', '&&', 'or', '||'];
    const form_els = ['INPUT', 'TEXTAREA', 'SELECT'];
    class Designer extends Ractive {
        constructor(opts) {
            super(opts);
            this.evalLock = false;
            this._scrollers = [];
            this._undo = [];
            this._redo = [];
            this._inited = false;
            this._isplay = false;
            this.langref = languageReference;
        }
        addWidget(type) {
            const widget = { type };
            const path = this.get('temp.widget');
            if (type === 'label') {
                if (path !== 'report')
                    widget.width = 10;
                widget.text = ':label';
            }
            else if (type === 'html') {
                widget.html = '<div>html</div>';
                widget.font = { line: 0 };
            }
            this.push(`${path}.widgets`, widget);
        }
        async run() {
            const report = this.get('report');
            this._isplay = true;
            const ctx = new Root(cloneDeep(report.context || {}), { parameters: this.get('params') });
            const srcs = await this.buildSources();
            this._isplay = false;
            let text;
            this.fire('running');
            try {
                text = run(report, srcs, ctx, {
                    foot: this.frameExtra(),
                    table: this.get('settings.delimitedTable'),
                });
            }
            catch (e) {
                console.error(e);
                text = `<html><head><style>.page { width: 63rem; height: 48rem; position: absolute; overflow: hidden; left: 1.5rem; top: 1.5rem; } .page-back { width: 66rem; height: 51rem; } body { font-size: 0.83rem; } @media screen { html { min-width: 68rem; } body { background-color: #999; display: flex; flex-direction: column; align-items: center; } .page-back { background-color: #fff; box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.4); position: relative; overflow: hidden; box-sizing: border-box; margin: 0.5em; } } @media print { body { margin: 0; padding: 0; width:66rem;background-color: none; display: block; height: 357rem } .page-back { position: absolute; box-shadow: none; background-color: none; margin: 0; padding: 0; left: 0rem; } .pb0 { top: 0rem; } .pb1 { top: 51rem; } .pb2 { top: 102rem; } .pb3 { top: 153rem; } .pb4 { top: 204rem; } .pb5 { top: 255rem; } .pb6 { top: 306rem; } } @page { size: 66em 51em; } .container { position:absolute;box-sizing:border-box; } .label {position:absolute;box-sizing:border-box;} pre { margin: 1rem; } h2 { color: red; margin: 1rem; }</style></head><body><div class="page-back"><h2>Report Exception</h2><code><pre>${e}\n${e.stack}</pre></code></div></body></html>`;
            }
            this.fire('run');
            this.set('result', text);
            return true;
        }
        frameExtra() {
            const typ = this.get('report.type');
            return `
      <style>
        @media screen {
          :root {
            --fg: ${this.get('@style.out.fg') || this.get('@style.fg')};
            --bg: ${this.get('@style.out.bg') || this.get('@style.bg')};
          }
          html:before, html:after { content: ' '; position: fixed; display: block; z-index: 2; box-shadow: 0 0 10px #000; transition: opacity 0.4s ease-in-out; opacity: 1; width: 100%; height: 5px; }
          html:before { top: -5px; }
          html:after { bottom: -5px; }
          html.scrolled-top:before { opacity: 0; }
          html.scrolled-bottom:after { opacity: 0; }

          html { font-size: ${this.get('settings.scale')}% !important;
          body {
            background-color: ${this.get('@style.out.dark') || this.get('@style.dark')};
            padding: 2em;
          }${typ === 'delimited' ? `
          body {
            display: inline-block;
          }
          table { border-collapse: collapse; }
          th, td { padding: 0.15em 0.4em; border: 1px solid rgba(128, 128, 128, 0.5); }
          tr.header th { position: sticky; top: 0; border-bottom: 2px solid; background: var(--bg); z-index: 10; }
          tr.row th { position: sticky; left: 0; padding: 0.15em 0.5em; text-align: right; border-right: 2px solid; background: var(--bg); z-index: 9; }
          tr:hover td, tr.row:hover th { background: rgba(128, 128, 128, 0.2); }` : ''}
          .page-back {
            color: var(--fg);
            background-color: var(--bg);
          }
        }
      </style>
      <script>
        const html = document.scrollingElement || document.documentElement;
        const listener = ev => {
          if (html.scrollTop === 0) html.classList.add('scrolled-top');
          else html.classList.remove('scrolled-top');

          if (html.scrollTop + html.clientHeight >= html.scrollHeight) html.classList.add('scrolled-bottom');
          else html.classList.remove('scrolled-bottom');
        };
        html.addEventListener('scroll', listener, { passive: true });
        window.addEventListener('resize', listener);
        window.addEventListener('scroll', listener);
        window.addEventListener('keydown', ev => {
          if (ev.ctrlKey && ev.shiftKey && ev.key === 'Enter') window.parent.postMessage('run', '*');
        });
        html.classList.add('scrolled-top');
      </script>
    `;
        }
        paperSize() {
            const size = this.get('pageSize');
            const type = this.get('report.type');
            if (type === 'flow') {
                if (size.width)
                    return `width: ${size.width}rem;`;
            }
            if (size) {
                return `width: ${size.width}rem; box-sizing: border-box; margin: auto; box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.4); padding: ${size.margin[0]}rem ${size.margin[1]}rem; min-height: ${size.height}rem; background-size: 1rem 1rem; background-position: ${10.5 - size.margin[0]}rem ${10.5 - size.margin[1]}rem; background-image: radial-gradient(circle, ${this.get('@style.border')}80 1px, transparent 1px);`;
            }
            return '';
        }
        calcHeight(w) {
            if (typeof w.height === 'number')
                return `${w.height}rem`;
            else if (typeof w.height === 'object' && 'percent' in w.height && w.height.percent)
                return `${w.height.percent}%`;
            else if (w.type === 'label') {
                let n = 1;
                if (w.font && !isComputed(w.font.size) && w.font.size > n)
                    n = w.font.size;
                if (Array.isArray(w.text)) {
                    for (let i = 0; i < w.text.length; i++) {
                        const t = w.text[i];
                        if (typeof t === 'object' && 'font' in t && t.font && t.font.size > n)
                            n = +t.font.size;
                    }
                }
                return `${n}rem`;
            }
            else if (w.type !== 'container' && w.type !== 'repeater')
                return '1rem';
            else if (w.macro)
                return '1rem';
            else
                return 'min-content';
        }
        calcHeightWithMargin(w) {
            const h = this.calcHeight(w);
            if (!w.margin || isComputed(w.margin))
                return h;
            if (typeof w.margin === 'number')
                return `calc(${h} + ${2 * w.margin}rem)`;
            else if (w.margin.length === 2)
                return `calc(${h} + ${2 * w.margin[0]}rem)`;
            else if (w.margin.length === 4)
                return `calc(${h} + ${w.margin[0] + w.margin[2]}rem)`;
            return h;
        }
        calcWidth(w, context) {
            if (!w.width || isComputed(w.width))
                return '100%';
            else if (w.width === 'grow' && Array.isArray(context.get('../../layout')))
                return `(100% - ${context.get(`../../layout[${context.get('@index')}][0]`) || 0}rem)`;
            else if (typeof w.width === 'object' && 'percent' in w.width)
                return `${w.width.percent}%`;
            else if (typeof w.width === 'number')
                return `${w.width}rem`;
            else
                return '100%';
        }
        calcWidthWithMargin(w, context) {
            if (/^report\.widgets\.\d+$/.test(context.resolve()))
                return '100%';
            const width = this.calcWidth(w, context);
            if (!w.margin && w.font && w.font.right)
                return `calc(${width} + ${w.font.right}rem)`;
            if (!w.margin || isComputed(w.margin))
                return ~width.indexOf('(') ? `calc${width}` : width;
            if (typeof w.margin === 'number')
                return `calc(${width} + ${2 * w.margin}rem)`;
            else if (w.margin.length === 2)
                return `calc(${width} + ${2 * w.margin[1]}rem)`;
            else if (w.margin.length === 4)
                return `calc(${width} + ${w.margin[1] + w.margin[3]}rem)`;
        }
        calcMargin(w) {
            const m = w.margin;
            if (!m || isComputed(m))
                return '';
            if (typeof m === 'number')
                return `padding: ${m}rem;`;
            else if (m.length === 2)
                return `padding: ${m[0]}rem ${m[1]}rem;`;
            else if (m.length === 4)
                return `padding: ${m[0]}rem ${m[1]}rem ${m[2]}rem ${m[3]}rem;`;
            return '';
        }
        calcBorder(w) {
            const b = w.border;
            if (!b)
                return '';
            const color = this.get('@style.border');
            if (typeof b === 'number')
                return `border-bottom:${b * 0.0625}rem solid ${color};`;
            else if (Array.isArray(b)) {
                if (b.length === 1)
                    return `border:${b[0] * 0.0625}rem solid ${color};`;
                else if (b.length === 2)
                    return `border-style:solid;border-width:${b[0] * 0.0625}rem ${b[1] * 0.0625}rem;`;
                else if (b.length === 4)
                    return `border-style:solid;border-width:${b[0] * 0.0625}rem ${b[1] * 0.0625}rem ${b[2] * 0.0625}rem ${b[3] * 0.0625}rem;`;
            }
            else if (typeof b === 'string') {
                return `border: 1px dotted green;`;
            }
            else
                return `border-style:solid;border-width:${(b.top || 0) * 0.0625}rem ${(b.right || 0) * 0.0625}rem ${(b.bottom || 0) * 0.0625}rem ${(b.left || 0) * 0.0625}rem;`;
            return '';
        }
        calcFont(w) {
            const f = w.font;
            let res = '';
            if (f.size && !isComputed(f.size))
                res += `font-size: ${f.size}rem;`;
            if (f.line && !isComputed(f.line))
                res += `line-height: ${f.line}rem;`;
            if (f.align && !isComputed(f.align))
                res += `text-align: ${f.align};`;
            if (f.color && !isComputed(f.color))
                res += `color: ${f.color} !important;`;
            if (f.family && !isComputed(f.family))
                res += `font-family: ${f.family};`;
            if (f.weight && !isComputed(f.weight))
                res += `font-weight: ${f.weight};`;
            if (f.right)
                res += `padding-right: ${f.right}rem;`;
            return res;
        }
        calcManualLayout(l, width, height) {
            l = l || [];
            const x = l[0] || 0;
            const y = l[1] || 0;
            let res = '';
            if (x < 0)
                res += `margin-left: calc(100% - ${width} - ${-x - 1}rem); margin-right: -100%;`;
            else
                res += `margin-left: ${x}rem; margin-right: calc(${-x}rem - ${width});`;
            if (y < 0)
                res += `margin-top: calc(100% - ${height} - ${-y - 1}rem); margin-bottom: ${-y - 1}rem;`;
            else
                res += `margin-top: ${y}rem;`;
            return res;
        }
        split(path, pop, ...add) {
            const res = Ractive.splitKeypath(path);
            if (pop)
                res.splice(-pop, pop);
            if (add)
                res.push(...add);
            return res;
        }
        lastKey(path, count = 1) {
            const keys = Ractive.splitKeypath(path);
            for (let i = 1; i < count; i++)
                keys.pop();
            return keys.pop();
        }
        selectWidget(path) {
            var _a;
            const two = (path || '').split('.')[1] || 'report';
            const base = `report${two === 'overlay' || two === 'watermark' ? `.${two}` : ''}`;
            if (((_a = this.readLink('widget', { canonical: false })) === null || _a === void 0 ? void 0 : _a.keypath) === path)
                path = base;
            this.link(path, 'widget');
            this.set('temp.name', nameForWidget(this.get(path + '.type'), path));
            this.set('temp.widget', path);
            const w = this.get('widget');
            if (w.type === 'html')
                this.editExpr(`${path}.html`, { html: true });
            else if (w.type === 'label' || w.type === 'measured')
                this.editExpr(`${path}.text`, { label: true });
            else if (w.type === 'image')
                this.editExpr(`${path}.url`);
            else if (w.type === 'container' && w.macro)
                this.editExpr(`${path}.macro`);
            else if (w.type === 'repeater' && typeof w.source === 'string')
                this.editExpr(`${path}.source`);
            this.treeScrollToActive();
        }
        treeScrollToActive() {
            setTimeout(() => {
                const el = document.querySelector('.tree .node.active > .line');
                if (el && typeof el.scrollIntoView === 'function')
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }
        async eval() {
            const start = Date.now();
            const str = this.get('temp.expr.str');
            let v = this.get('temp.expr.path');
            if (v && v.startsWith('widget.'))
                v = v.replace('widget', this.get('temp.widget'));
            const ctx = await this.buildLocalContext(v);
            const res = Array.isArray(str) ?
                str.map(p => {
                    if (typeof p === 'string')
                        return evaluate(ctx, p);
                    else if (p && typeof p === 'object' && typeof p.text === 'string')
                        return evaluate(ctx, p.text);
                    return '';
                }).join('') :
                evaluate(ctx, this.get('temp.expr.html') || this.get('temp.expr.template') ? parse$3(str) : str);
            console.log(`eval: ${Date.now() - start}ms`);
            this.set('temp.expr.result', res);
            this.set('temp.expr.tab', 'result');
        }
        evalExpr(expr, template, ctx) {
            if (ctx)
                return evaluate(ctx, template ? parse$3(expr) : parse$4(expr));
            return evaluate(template ? parse$3(expr) : parse$4(expr));
        }
        autosizeHtml(ctx) {
            const preview = ctx.get('ctx.preview');
            ctx.set('ctx.preview', true);
            ctx.set('ctx.autosize', true);
            ctx.set('.height', Math.ceil(ctx.node.nextElementSibling.offsetHeight / 16));
            ctx.set('ctx.autosize', false);
            ctx.set('ctx.preview', preview);
        }
        async editProvidedData(ctx) {
            ctx.link(ctx.resolve(), '~/data');
            const source = ctx.get();
            let val;
            if ('type' in source && source.type === 'fetch')
                val = await this.fetchData();
            else if ('input' in source)
                val = source.input;
            else if ('data' in source || 'values' in source)
                val = source.data ? source.data : await source.values();
            if (typeof val === 'object' && 'value' in val)
                val = val.value;
            if (typeof val === 'string')
                this._importText.value = val;
            else
                this._importText.value = JSON.stringify(val, null, 2);
            if (!this.get('show.proppop'))
                this.set('show.props', false);
            this.set('tab', 'import');
        }
        async logData(source) {
            console.log(await this.loadSourceData(source));
        }
        editExpr(path, options) {
            if (this.event)
                path = this.getContext(this.event.node).resolve(path);
            if (path.startsWith('widget.'))
                path = path.replace('widget', this.get('temp.widget'));
            let val = this.get(path);
            if (Array.isArray(val)) {
                val.forEach((v, i) => {
                    if (typeof v === 'object' && !('text' in v))
                        val[i] = stringify(v);
                });
            }
            else if (typeof val !== 'string')
                val = val === undefined ? '' : stringify(val);
            this.set('temp.expr.path', path);
            const html = options && options.html;
            const tab = this.get('temp.expr.tab');
            this.set('temp.expr.html', html);
            this.set('temp.expr.label', options && options.label);
            this.set('temp.expr.template', options && options.template);
            this.set('temp.expr.tab', html ? 'html' : tab === 'ast' || tab === 'text' ? tab : 'text');
            this.set('temp.bottom.tab', 'expr');
            this.link(path, 'expr');
            this.set('temp.expr.str', val);
            this.set('show.bottom', true);
            if (!this.get('show.proppop'))
                this.set('show.props', false);
            const el = document.getElementById(`expr-${html ? 'html' : 'text'}`);
            if (el)
                setTimeout(() => el.focus(), 500);
            const parent = Ractive.joinKeys(...Ractive.splitKeypath(path).slice(0, -1));
            let watch;
            watch = this.observe(`${parent} temp.expr.path`, (v, _o, k) => {
                if (k === 'temp.expr.path')
                    return watch.cancel();
                if (!v || typeof v !== 'object')
                    this.checkLink('expr');
            }, { init: false });
        }
        editParam(ctx) {
            const path = ctx.resolve();
            this.set('show.bottom', true);
            this.set('temp.bottom.param', path);
            this.set('temp.bottom.tab', 'param');
            this.link(path, 'param');
            if (!this.get('show.proppop'))
                this.set('show.props', false);
        }
        editReportSrc(ctx, key) {
            const path = ctx.resolve(key || undefined);
            this.set('show.bottom', true);
            this.set('temp.bottom.source', path);
            this.set('temp.bottom.tab', 'source');
            this.link(path, 'source');
            if (!this.get('show.proppop'))
                this.set('show.props', false);
        }
        moveUp(ctx, path, index, end) {
            const idx = index !== undefined ? index : ctx.get('@index');
            path = path || '../';
            if (!Array.isArray(path))
                path = [path];
            for (const p of path) {
                if (!p)
                    continue;
                if (idx == null || idx <= 0)
                    return;
                const item = ctx.get(joinPath(p, idx));
                ctx.splice(p, end ? 0 : idx - 1, 0, item);
                ctx.splice(p, idx + 1, 1);
            }
        }
        moveDown(ctx, path, index, end) {
            const idx = index !== undefined ? index : ctx.get('@index');
            path = path || '../';
            if (!Array.isArray(path))
                path = [path];
            for (const p of path) {
                if (!p)
                    continue;
                const last = ctx.get('@last');
                if (idx == null || !~idx || idx >= last)
                    return;
                const item = ctx.get(joinPath(p, idx));
                ctx.splice(p, end ? last + 1 : idx + 2, 0, item);
                ctx.splice(p, idx, 1);
            }
        }
        reparent(target) {
            const w = this.get('reparent');
            this.set('reparent', undefined);
            if (!w || !target)
                return;
            let layout;
            if (Array.isArray(w.get('../../layout'))) {
                layout = w.splice('../../layout', w.get('@index'), 1).result[0];
            }
            if (Array.isArray(target.get('.layout'))) {
                target.push('.layout', layout || [0, 0]);
            }
            const obj = w.splice('../', w.get('@index'), 1).result[0];
            target.push('.widgets', obj);
        }
        move(target) {
            const w = this.get('reparent');
            this.set('reparent', undefined);
            if (!w || !target)
                return;
            const idx = target.get('@index');
            const container = target.get('../../');
            if (!container || container.type !== 'container' && container !== this.get('report'))
                return;
            let layout;
            if (Array.isArray(w.get('../../layout'))) {
                layout = w.splice('../../layout', w.get('@index'), 1).result[0];
            }
            if (Array.isArray(target.get('../../layout'))) {
                target.splice('../../layout', idx, 0, layout || [0, 0]);
            }
            const obj = w.splice('../', w.get('@index'), 1).result[0];
            target.splice('../../widgets', idx, 0, obj);
        }
        paste(target) {
            const w = this.get('copy');
            this.set('copy', undefined);
            if (!w || !target)
                return;
            const obj = cloneDeep(w.get());
            target.push('widgets', obj);
            if (Array.isArray(target.get('layout'))) {
                if (Array.isArray(w.get('^^/layout')))
                    target.push('layout', w.get(`^^/layout.${w.get('@index')}`));
                else
                    target.push('layout', [0, 0]);
            }
        }
        pasteBefore(target) {
            const w = this.get('copy');
            this.set('copy', undefined);
            if (!w || !target)
                return;
            const container = target.get('../../');
            if (!container || container.type !== 'container' && container !== this.get('report'))
                return;
            const idx = target.get('@index');
            const obj = cloneDeep(w.get());
            target.splice('../../widgets', idx, 0, obj);
            if (Array.isArray(target.get('../../layout'))) {
                if (Array.isArray(w.get('^^/layout')))
                    target.splice('../../layout', idx, 0, w.get(`^^/layout.${w.get('@index')}`));
                else
                    target.splice('../../layout', idx, 0, [0, 0]);
            }
        }
        clickWidget(target) {
            var _a, _b, _c, _d;
            const keypath = target.get('@keypath');
            const type = target.get('.type');
            if (!((_b = (_a = this.event) === null || _a === void 0 ? void 0 : _a.event) === null || _b === void 0 ? void 0 : _b.shiftKey) && this.get('reparent') && type === 'container' && keypath.indexOf(this.get('reparent').resolve()) === -1)
                this.reparent(target);
            else if (this.get('reparent'))
                this.move(target);
            else if (!((_d = (_c = this.event) === null || _c === void 0 ? void 0 : _c.event) === null || _d === void 0 ? void 0 : _d.shiftKey) && this.get('~/copy') && type === 'container')
                this.paste(target);
            else if (this.get('~/copy'))
                this.pasteBefore(target);
            else
                this.selectWidget(keypath);
            return false;
        }
        fillArray(count) {
            const res = [];
            for (let i = 0; i < count; i++) {
                res[i] = [];
            }
            return res;
        }
        addHeader() {
            this.set('report.headers', (this.get('report.fields') || []).map(() => ''));
        }
        command(name, ui, value) {
            return document.execCommand(name, ui || false, value === undefined ? null : value);
        }
        retypeASTNode(path, type) {
            if (type === 'operator') {
                this.set(path, { op: '+' });
            }
            else if (type === 'reference') {
                this.set(path, { r: '' });
            }
            else if (type === 'string') {
                this.set(path, { v: '' });
            }
            else if (type === 'number') {
                this.set(path, { v: 0 });
            }
            else if (type === 'undefined') {
                this.set(path, { v: undefined });
            }
        }
        autosize(node) {
            if (autosizeTm)
                clearTimeout(autosizeTm);
            autosizeTm = setTimeout(() => {
                autosizeTm = 0;
                const pos = node.parentElement.scrollTop;
                const sh = node.parentElement.scrollHeight;
                const ch = node.parentElement.clientHeight;
                const old = parseInt(node.style.height);
                node.style.height = '';
                node.style.overflow = '';
                setTimeout(() => {
                    const next = node.scrollHeight + 1;
                    node.style.height = `${next}px`;
                    node.style.overflow = 'hidden';
                    node.parentElement.scrollTop = old && pos + ch + (next - old) >= sh ? pos + (next - old) : pos;
                });
            }, 500);
        }
        exprToggle(path) {
            this.toggle('exprExpand.' + Ractive.escapeKey(path));
        }
        async buildRoot(skipSources) {
            const report = this.get('report');
            const res = new Root(cloneDeep(report.context), { parameters: this.get('params') });
            if (report.extraContext)
                evaluate(res, report.extraContext);
            const srcs = await this.buildSources();
            if (!skipSources)
                applySources(res, report.sources || [], srcs);
            return res;
        }
        async loadSourceData(av) {
            const load = this.get('actions.loadSourceData');
            const nocache = this._isplay;
            let d;
            let vv = av;
            if (vv.type === 'fetch' && (vv.fetch || !vv.data)) {
                d = await this.fetchData(vv);
                if (!vv.eval)
                    d = { value: tryParseData(d, vv.header) };
                if (!vv.fetch)
                    vv.data = d;
            }
            else if ('data' in av && av.data && (!vv.cached || !nocache)) {
                if (!vv.eval && typeof av.data === 'string') {
                    d = tryParseData(av.data, av.header);
                    if (!d || typeof d !== 'object' || !('value' in d))
                        d = { value: d };
                }
                else
                    d = av.data;
            }
            else if ('values' in av && typeof av.values === 'function') {
                d = await av.values(this.get('params') || []);
            }
            else if ('input' in av && av.input) {
                d = tryParseData(av.input, av.header);
                if (!d || typeof d !== 'object' || !('value' in d))
                    d = { value: d };
                av.data = d;
            }
            else {
                if (typeof load === 'function') {
                    vv.cached = true;
                    vv.data = d = await load(av);
                }
            }
            return d;
        }
        async buildSources() {
            const report = this.get('report');
            const avs = this.get('sources') || [];
            const res = {};
            for (const src of report.sources || []) {
                const av = avs.find(s => s.name === src.source);
                if (av) {
                    const data = await this.loadSourceData(av);
                    if (data && typeof data === 'object' && 'value' in data)
                        res[av.name] = data;
                    else
                        res[av.name] = { value: data };
                }
            }
            return res;
        }
        async buildLocalContext(path) {
            const root = await this.buildRoot(path && path.slice(0, 'report.sources.'.length) === 'report.sources.');
            root.special.date = new Date();
            root.special.local = {};
            root.special.locals = {};
            root.special.special = {};
            root.special.specials = {};
            let loc = this.get('report');
            let ctx = root;
            if (path) {
                const parts = Ractive.splitKeypath(path);
                if (parts[0] === 'report')
                    parts.shift();
                if (parts[0] === 'fields') {
                    let src = evaluate(ctx, `*${this.get('report.source')}`);
                    if (src && !Array.isArray(src) && typeof src === 'object' && Array.isArray(src.all))
                        src = src.all;
                    if (src && typeof src === 'object' && Array.isArray(src.value))
                        src = src.value;
                    if (src && Array.isArray(src))
                        src = src[0];
                    let context = extend$2(ctx, { value: src });
                    const row = this.get('report.rowContext');
                    if (row) {
                        if (!context.locals)
                            context.locals = {};
                        const v = evaluate(context, row);
                        if (v)
                            context.value = v;
                    }
                    ctx = context;
                }
                else if (parts[0] === 'rowContext') {
                    let src = evaluate(ctx, `*${this.get('report.source')}`);
                    if (src && !Array.isArray(src) && typeof src === 'object' && Array.isArray(src.all))
                        src = src.all;
                    if (src && typeof src === 'object' && Array.isArray(src.value))
                        src = src.value;
                    if (src && Array.isArray(src))
                        src = src[0];
                    ctx = extend$2(ctx, { value: src });
                }
                else if (parts[0] === 'sources') {
                    if (parts[parts.length - 1] === 'base') {
                        const name = this.get(`report.sources.${parts[1]}.source`);
                        const provided = (this.get('sources') || []).find(s => s.name === name);
                        let src = await this.loadSourceData(provided);
                        ctx = extend$2(ctx, { value: ctx.value, special: { source: src } });
                    }
                    else {
                        const name = this.get(`report.sources.${parts[1]}.name`) || this.get(`report.sources.${parts[1]}.source`);
                        const srcs = await this.buildSources();
                        applySources(root, loc.sources || [], srcs);
                        let src = evaluate(ctx, `*${name}`);
                        if (src && !Array.isArray(src) && typeof src === 'object' && Array.isArray(src.all))
                            src = src.all;
                        if (src && typeof src === 'object' && Array.isArray(src.value))
                            src = src.value;
                        if (src && Array.isArray(src))
                            src = src[0];
                        ctx = extend$2(ctx, { value: src });
                    }
                }
                else {
                    while (loc && parts.length) {
                        const part = parts.shift();
                        if (loc.type === 'page' && (part === 'header' || part === 'footer' || part === 'watermark' || part === 'overlay')) {
                            root.special.page = 1;
                            root.special.pages = 10;
                            root.special.size = { x: 30, y: 40 };
                        }
                        if (part === 'height' || part === 'width' || part === 'br' || part === 'margin' || part === 'hide') {
                            root.special.placement = { x: 0, y: 0, availableX: 10, availableY: 10, maxX: 10, maxY: 10, offsetX: 5, offsetY: 5 };
                            root.special.widget = loc;
                        }
                        loc = loc[part];
                        if (loc) {
                            if (loc.context) {
                                if (!ctx.locals)
                                    ctx.locals = {};
                                const value = evaluate(ctx, loc.context);
                                if (value)
                                    ctx = extend$2(ctx, { value });
                            }
                            else if (loc.source && loc.source.source) {
                                const source = filter(root.sources[loc.source.source] || { value: [] }, loc.source.filter, loc.source.sort, loc.source.group, ctx);
                                ctx = extend$2(ctx, { value: source.value, special: { source } });
                            }
                            else if (loc.source) {
                                ctx = extend$2(ctx, { value: evaluate(ctx, loc.source) });
                            }
                        }
                        if (loc && loc.type === 'repeater') {
                            if (loc.group && loc.group.length && ctx.value && ctx.value.value && ctx.value.value[0]) {
                                root.special.grouped = true;
                                root.special.level = ctx.value.value[0].level;
                                root.special.group = ctx.value.value[0].group;
                            }
                            if (parts[0] === 'row') {
                                root.special.source = ctx.value;
                                ctx = extend$2(ctx, { value: evaluate(ctx, '@value.0') || evaluate(ctx, '@value.all.0') });
                                root.special.index = 0;
                            }
                            else if (parts[0] === 'footer') {
                                root.special.values = {};
                            }
                            if (parts[0] === 'row' || parts[0] === 'footer') {
                                root.special.last = 10;
                                root.special.count = 11;
                            }
                        }
                    }
                }
            }
            return ctx;
        }
        async fetchData(data) {
            const set = !data;
            data = data || this.get('data');
            const ctx = new Root({}, { parameters: this.get('params') });
            const url = this.evalExpr(data.url, true, ctx);
            const headers = {};
            if (Array.isArray(data.headers)) {
                for (let i = 0; i < data.headers.length; i++)
                    headers[data.headers[i][0]] = this.evalExpr(data.headers[i][1], true, ctx);
            }
            try {
                const req = { headers, method: data.method };
                if (req.method === 'POST' || req.method === 'PUT')
                    req.body = this.evalExpr(data.body, true, ctx);
                const res = await fetch(url, req);
                const txt = await res.text();
                if (set)
                    this.set('data.data', txt);
                return txt;
            }
            catch (_a) { }
        }
        getSchema(ctx) {
            const base = inspect(ctx.value);
            let last = ctx.value;
            let pl = base;
            pl.fields = pl.fields || [];
            let c = ctx;
            let prefix = '';
            for (const k in ctx.root.sources) {
                const source = ctx.root.sources[k];
                if (!source || !source.value)
                    continue;
                const schema = inspect(source.value);
                pl.fields.push({ name: `*${k}`, type: schema.type, fields: schema.fields });
            }
            let t = inspect(ctx.root.special);
            t.fields.forEach(f => (f.name = `@${f.name}`, pl.fields.push(f)));
            if (ctx.special) {
                t = inspect(ctx.special);
                t.fields.forEach(f => (f.name = `@${f.name}`, pl.fields.push(f)));
            }
            (this.get('report.parameters') || []).forEach((p) => pl.fields.push({ name: `!${p.name}`, type: p.type }));
            const stack = [];
            if (c !== c.root) {
                while (c) {
                    c = c.parent;
                    if (c === c.root)
                        prefix = '~';
                    else
                        prefix += '^';
                    if (last === c.value && c.parent)
                        continue;
                    stack.push(c);
                    t = inspect(c.value, c !== c.root);
                    (t.fields || []).forEach(f => (f.name = `${prefix}${f.name}`, pl.fields.push(f)));
                    last = c.value;
                    if (c.locals) {
                        t = inspect(c.locals);
                        if (t.fields)
                            t.fields.forEach(f => (f.meta = { local: true }, f.name = `${prefix === '~' ? '^' : prefix}${f.name}`, pl.fields.push(f)));
                    }
                    if (c === c.root)
                        break;
                }
            }
            stack.push(ctx);
            const locals = {};
            stack.forEach(c => {
                if (c.locals)
                    for (const k in c.locals)
                        locals[k] = c.locals[k];
            });
            t = inspect(locals);
            t.fields.forEach(f => (f.meta = { local: true }, pl.fields.push(f)));
            return base;
        }
        insertRef(path) {
            const tab = this.get('temp.expr.tab') || 'text';
            const parts = Ractive.splitKeypath(path);
            let ps = [];
            while (parts.length && parts[parts.length - 1] !== 'ctx') {
                ps.unshift(this.get(Ractive.joinKeys.apply(Ractive, parts.concat('name'))));
                parts.pop();
                parts.pop();
            }
            if (ps[0][0] === '*' && ps[1] === 'value' && ps.length > 2)
                ps[1] = '0';
            const prefix = /^[!^@~*]+/.exec(ps[0]);
            if (prefix)
                ps[0] = ps[0].substring(prefix[0].length);
            let ref = stringify({ r: { k: ps } });
            if (prefix)
                ref = `${prefix[0]}${ref}`;
            if (this.get('temp.expr.html') || this.get('temp.expr.template'))
                ref = `{{${ref}}}`;
            if (tab === 'text') {
                const node = getLastFocus();
                if (!node)
                    return;
                const cur = node.value;
                const pos = [node.selectionStart, node.selectionEnd];
                node.value = cur.substring(0, pos[0]) + ref + cur.substr(pos[1]);
                node.selectionStart = node.selectionEnd = pos[0] + ref.length;
                node.dispatchEvent(new InputEvent('input'));
                node.dispatchEvent(new InputEvent('change'));
                node.focus();
            }
            else if (tab === 'html') {
                return this.command('insertText', false, ref);
            }
            else if (tab === 'ast') {
                const active = this.get('temp.expr.partpath') || 'temp.expr.ast';
                this.set(active, { r: ref });
            }
        }
        insertOp(name) {
            const tab = this.get('temp.expr.tab') || 'text';
            if (tab === 'text') {
                const el = getLastFocus();
                if (!el)
                    return;
                const cur = el.value;
                const pos = [el.selectionStart, el.selectionEnd];
                let rep = cur.substring(pos[0], pos[1]);
                let cursor;
                if (binops.includes(name)) {
                    rep = ` ${name} `;
                    cursor = pos[0] + rep.length;
                }
                else if (name[0] === '#') {
                    rep = `${name}`;
                    cursor = pos[0] + rep.length;
                }
                else {
                    rep = `${name}(${rep})`;
                    cursor = pos[0] + rep.length - 1;
                }
                el.value = cur.substring(0, pos[0]) + rep + cur.substr(pos[1]);
                el.selectionStart = el.selectionEnd = cursor;
                el.dispatchEvent(new InputEvent('input'));
                el.dispatchEvent(new InputEvent('change'));
                el.focus();
            }
            else {
                return this.command('insertText', false, `{{${name}}}`);
            }
        }
        resetScrollers() {
            this._scrollers.forEach(fn => fn());
        }
        loadReportString(str) {
            try {
                const report = JSON.parse(str);
                this.set('report', report);
                this.set('params', report.defaultParams || {});
            }
            catch (e) {
                try {
                    const report = evaluate({ PageSizes }, str);
                    this.set('report', report);
                    this.set('params', report.defaultParams || {});
                }
                catch (e) {
                    console.error('Failed to load report', e);
                }
            }
        }
        async download(name, data, type = 'application/json') {
            name = evaluate(extend$2(await this.buildRoot(), { parser: parse$3 }), name);
            const blob = new Blob([data], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.download = name;
            a.href = url;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }
        reportToString(compact, js, strings) {
            const json = this.get('report');
            if (!compact)
                return JSON.stringify(json, null, 2);
            else {
                if (js)
                    return jsonToJS(stripDefaults(json), strings);
                else
                    return JSON.stringify(stripDefaults(json));
            }
        }
        loadReportFile() {
            const input = this.find('#definition-file');
            let load;
            load = () => {
                input.removeEventListener('change', load);
                if (input.files.length) {
                    const file = input.files[0];
                    const reader = new FileReader();
                    reader.onload = txt => this.loadReportString(txt.target.result);
                    reader.readAsText(file);
                }
            };
            input.addEventListener('change', load);
            input.click();
        }
        loadImportFile() {
            const input = this.find('#import-file');
            let load;
            load = () => {
                input.removeEventListener('change', load);
                if (input.files.length) {
                    const file = input.files[0];
                    const reader = new FileReader();
                    reader.onload = txt => {
                        this.tryImport(txt.target.result);
                        this._importText.value = txt.target.result.toString();
                    };
                    reader.readAsText(file);
                }
            };
            input.addEventListener('change', load);
            input.click();
        }
        getImportText() {
            var _a;
            return ((_a = this._importText) === null || _a === void 0 ? void 0 : _a.value) || '';
        }
        tryImport(str) {
            if (!str || !this.readLink('data'))
                return;
            this.set('data.input', str);
            const json = tryParseData(str, this.get('data.header'));
            if (json) {
                if (typeof json === 'object' && 'type' in json && json.type === 'fetch')
                    this.set('data', json);
                else {
                    if (Array.isArray(json) || !Array.isArray(json.value))
                        this.set('data.data', { value: json });
                    else if (Object.keys(json).length === 1 && 'value' in json)
                        this.set('data.data', json.value);
                    else
                        this.set('data.data', json);
                }
            }
            else {
                this.set('data.data', str);
            }
            this.update('sources');
        }
        loadContextFile() {
            const input = this.find('#context-file');
            let load;
            load = () => {
                input.removeEventListener('change', load);
                if (input.files.length) {
                    const file = input.files[0];
                    const reader = new FileReader();
                    reader.onload = txt => this.tryContext(txt.target.result);
                    reader.readAsText(file);
                }
            };
            input.addEventListener('change', load);
            input.click();
        }
        tryContext(str) {
            if (!str)
                return;
            let ctx;
            try {
                ctx = JSON.parse(str);
            }
            catch (_a) {
                try {
                    ctx = evaluate({}, str);
                }
                catch (_b) {
                    ctx = {};
                }
            }
            this.set('report.context', ctx);
        }
        setHTMLFontSize() {
            const size = this.get('temp.fontSize');
            if (size) {
                this.command('fontSize', false, size);
            }
            setTimeout(() => this.set('temp.fontSize', ''));
        }
        inRepeater(path) {
            return /\.row\./.test(path);
        }
        getPartStrings(arr) {
            return arr.map(c => c.text || c).join(' + ');
        }
        nodeForPosition(pos, name) {
            const str = this.get('temp.expr.str');
            const r = (this.get('temp.expr.html') || this.get('temp.expr.template') ? parse$3 : parse$4)(str, { tree: true });
            if ('message' in r)
                return r;
            else
                return nodeForPosition(r, pos, name);
        }
        fmt() {
            this._onChange(this.get('report'));
            const str = this.get('temp.expr.str');
            const settings = this.get('~/settings.format') || {};
            const opts = { listWrap: { base: settings.wrap, array: settings.wrap_array, union: settings.wrap_union, args: settings.wrap_args, keys: settings.wrap_keys } };
            this.set('temp.expr.str', fmt(str, this.get('temp.expr.html'), this.get('tmp.nowrap'), opts));
        }
        fmtAll() {
            const json = this.get('report');
            this._onChange(json);
            const settings = this.get('~/settings.format') || {};
            const opts = { listWrap: { base: settings.wrap, array: settings.wrap_array, union: settings.wrap_union, args: settings.wrap_args, keys: settings.wrap_keys } };
            this.set('report', fmtAll(json, this.get('tmp.nowrap'), opts));
        }
        unparse(value) {
            if (!isValueOrExpr(value))
                value = { v: value };
            const settings = this.get('~/settings.format') || {};
            const opts = { listWrap: { base: settings.wrap, array: settings.wrap_array, union: settings.wrap_union, args: settings.wrap_args, keys: settings.wrap_keys } };
            return stringify(value, opts);
        }
        removeWidget(ctx) {
            const path = ctx.resolve();
            const pathArr = Ractive.splitKeypath(path);
            const key = pathArr.pop();
            const keyup = pathArr.pop();
            let link;
            if (this.get('temp.widget') === path)
                this.set('temp.widget', 'report');
            if ((link = this.readLink('widget')) && link.keypath === path)
                this.unlink('widget');
            this.checkLink('expr', ctx.resolve());
            if (ctx.get('^^/type') === 'repeater' && keyup === 'group') {
                if (ctx.get('^^/groupEnds'))
                    ctx.splice('^^/groupEnds', ctx.get('@index'), 1);
                if (ctx.get('^^/group'))
                    ctx.splice('^^/group', ctx.get('@index'), 1);
                if (ctx.get('^^/group.length') === 0)
                    ctx.set({ '^^/group': undefined, '^^/groupEnds': undefined });
            }
            else if (ctx.get('../type') === 'repeater')
                ctx.set('../' + key, undefined);
            else if (path === 'report.header' || path === 'report.footer' || path === 'report.watermark' || path === 'report.overlay')
                this.set(path, undefined);
            else {
                if (Array.isArray(ctx.get('^^/layout')))
                    ctx.splice('^^/layout', ctx.get('@index'), 1);
                const idx = ctx.get('@index');
                if (Array.isArray(ctx.get('../')))
                    ctx.splice('../', idx, 1);
                if (path.startsWith('report.fields') && ctx.get('../headers'))
                    ctx.splice('../headers', idx, 1);
                else if (path.startsWith('report.headers'))
                    ctx.splice('../fields', idx, 1);
            }
        }
        checkLink(type, path) {
            let link;
            if (type === 'import')
                link = this.readLink('data');
            else if (type === 'param')
                link = this.readLink('param');
            else if (type === 'source')
                link = this.readLink('source');
            if (path === undefined) {
                if (type === 'expr')
                    path = this.get('temp.expr.path');
                if (link)
                    path = link.keypath;
            }
            if (type === 'import' && link && path === link.keypath) {
                this.unlink('data');
                this.set('tab', 'definition');
            }
            else if ((type === 'expr' || type === 'field') && (this.get('temp.expr.path') || '').startsWith(path)) {
                this.unlink('expr');
                this.set('temp.expr', {
                    path: undefined,
                    str: '',
                    html: false,
                    tab: 'text',
                    label: false,
                    template: false,
                }, { deep: true });
            }
            else if (type === 'param' && link && path === link.keypath) {
                this.unlink('param');
                this.set('temp.bottom.param', undefined);
                this.set('temp.bottom.tab', 'expr');
            }
            else if (type === 'source' && link && path === link.keypath) {
                this.unlink('source');
                this.set('temp.bottom.source', undefined);
                this.set('temp.bottom.tab', 'expr');
            }
            if (type !== 'field' && path) {
                if (path.startsWith('report.fields'))
                    this.checkLink('field', path.replace('fields', 'headers'));
                if (path.startsWith('report.headers'))
                    this.checkLink('field', path.replace('headers', 'fields'));
            }
        }
        checkLinks() {
            this.checkLink('expr');
            this.checkLink('import');
            this.checkLink('source');
            this.checkLink('param');
            this.checkLink('field');
        }
        saveProjects() {
            if (this.get('showProjects') === false) {
                this.fire('save', {}, this);
            }
            else {
                const projects = this.get('projects') || [];
                for (const p of projects) {
                    if (!p.sources || !Array.isArray(p.sources))
                        continue;
                    for (const s of p.sources) {
                        if ('type' in s && s.type)
                            delete s.data;
                        else if ('input' in s)
                            delete s.data;
                    }
                }
                window.localStorage.setItem('projects', JSON.stringify(this.get('projects') || []));
                const project = this.get('project');
                if (project)
                    this.set('projectSaved', this.stringifyProject(project));
            }
        }
        loadProjects() {
            this.set('projects', JSON.parse(window.localStorage.getItem('projects') || '[]'));
        }
        resetProject() {
            this.set('project', JSON.parse(this.get('projectSaved')));
        }
        makeProject(clean) {
            const project = clean ?
                { name: 'Project', sources: [], report: { type: 'page', classifyStyles: true, orientation: 'landscape', size: PageSizes.letter } } :
                { name: 'Project', report: this.get('report') || {}, sources: this.get('sources') || [] };
            this.unlink('report');
            this.unlink('sources');
            this.unlink('project');
            this.checkLinks();
            this.push('projects', project);
            this.link('projects.' + (this.get('projects').length - 1), 'project');
            this.link('project.report', 'report');
            this.link('project.sources', 'sources');
            this.set('projectText', '');
        }
        stringifyProject(project) {
            if (!project)
                project = this.get('project');
            const sources = (this.get('project.sources') || this.get('sources') || []).map(s => {
                if ('type' in s && s.type) {
                    return Object.assign({}, s, { data: undefined });
                }
                else {
                    const res = Object.assign({}, s);
                    if ('input' in res)
                        delete res.data;
                    return res;
                }
            });
            return JSON.stringify(Object.assign({}, project, { sources, report: this.get('project.report') || this.get('report') || {} }));
        }
        stringifyProjects() {
            const projects = this.get('projects') || [];
            return JSON.stringify(projects.map(p => {
                const sources = (p.sources || []).map(s => {
                    if ('type' in s && s.type) {
                        return Object.assign({}, s, { data: undefined });
                    }
                    else {
                        const res = Object.assign({}, s);
                        if ('input' in res)
                            delete res.data;
                        return res;
                    }
                });
                return Object.assign({}, p, { sources });
            }));
        }
        removeProject() {
            if (window.confirm('Do you want to delete this project? This cannot be undone.')) {
                const project = this.get('project');
                const projects = this.get('projects') || [];
                projects.splice(projects.indexOf(project), 1);
                this.unlink('report');
                this.unlink('sources');
                this.unlink('project');
                this.set('project', undefined);
                this.checkLinks();
                this.saveProjects();
            }
        }
        importProject(single, str) {
            const cb = (txt) => {
                const res = JSON.parse(txt);
                if (!single && Array.isArray(res) && res.length > 0 && 'name' in res[0]) {
                    const current = (this.get('projects') || []).slice();
                    for (const r of res) {
                        const idx = current.findIndex(p => p.name === r.name);
                        if (~idx)
                            current.splice(idx, 1, r);
                        else
                            current.push(r);
                    }
                    this.set('projects', current);
                    this.checkLinks();
                }
                else if (single && typeof res === 'object' && !Array.isArray(res) && 'name' in res) {
                    const proj = this.get('project');
                    const projects = this.get('projects');
                    this.set('project', res);
                    this.link('project.report', 'report');
                    this.link('project.sources', 'sources');
                    if (~projects.indexOf(proj))
                        projects.splice(projects.indexOf(proj), 1, res);
                    this.checkLinks();
                }
            };
            this.set('projectText', '');
            if (typeof str === 'string') {
                if (str)
                    cb(str);
            }
            else {
                const input = this.find('#project-file');
                if (single)
                    input.accept = '.raport-proj,.json';
                else
                    input.accept = '.json';
                let load;
                load = () => {
                    input.removeEventListener('change', load);
                    if (input.files.length) {
                        const file = input.files[0];
                        const reader = new FileReader();
                        reader.onload = fr => cb(fr.target.result);
                        reader.readAsText(file);
                    }
                };
                input.addEventListener('change', load);
                input.click();
            }
        }
        cloneProject() {
            this.set('projectText', '');
            const project = this.get('project');
            this.unlink('report');
            this.unlink('sources');
            this.unlink('project');
            this.push('projects', JSON.parse(JSON.stringify(project)));
            this.link('projects.' + (this.get('projects').length - 1), 'project');
            this.link('project.report', 'report');
            this.link('project.sources', 'sources');
        }
        linkProject(path) {
            this.set('projectText', '');
            this.unlink('report');
            this.unlink('sources');
            this.unlink('project');
            this.checkLinks();
            this.link(path, 'project');
            this.link('project.report', 'report');
            this.link('project.sources', 'sources');
            this.set('projectSaved', this.stringifyProject(this.get(path)));
            this.resetUndo();
            // check for sample data refs
            const sources = this.get('sources') || [];
            for (let i = 0; i < sources.length; i++) {
                const s = sources[i];
                if (s && s.name === 'sample' && !s.value)
                    this.set(`sources.${i}.values`, this.get('sample'));
            }
        }
        unlinkProject() {
            this.unlink('report');
            this.unlink('sources');
            this.unlink('project');
            this.checkLinks();
            this.resetUndo();
        }
        resetUndo() {
            this._undo = [];
            this._redo = [];
        }
        undo() {
            if (this.event && ~form_els.indexOf(this.event.event.target.nodeName))
                return false;
            this._undoWatch.silence();
            let s = this._undo.shift();
            if (s && JSON.stringify(this.get('report')) === s) {
                this._redo.unshift(s);
                s = this._undo.shift();
            }
            if (s) {
                this._redo.unshift(s);
                this.set('report', JSON.parse(s));
            }
            this._undoWatch.resume();
        }
        redo() {
            if (this.event && ~form_els.indexOf(this.event.event.target))
                return false;
            this._undoWatch.silence();
            let s = this._redo.shift();
            if (s && JSON.stringify(this.get('report')) === s) {
                this._undo.unshift(s);
                s = this._redo.shift();
            }
            if (s) {
                this._undo.unshift(s);
                this.set('report', JSON.parse(s));
            }
            this._undoWatch.resume();
        }
        async initParams() {
            this.set('params', initParameters(this.get('report'), await this.buildSources()));
        }
        _onChange(v) {
            const s = JSON.stringify(v);
            if (s === this._undo[0])
                return;
            this._undo.unshift(JSON.stringify(v));
            if (this.undo.length > 40)
                this._undo = this._undo.slice(0, 40);
            this._redo = [];
        }
        applySettings() {
            var _a, _b;
            const settings = this.get('settings') || {};
            let dark = false;
            if (settings.theme === 'dark')
                dark = true, Ractive.styleSet(darkTheme);
            else if (settings.theme === 'light')
                Ractive.styleSet(lightTheme);
            else {
                const ml = window.matchMedia('(prefers-color-scheme: dark)');
                dark = ml.matches;
                Ractive.styleSet(ml.matches ? darkTheme : lightTheme);
            }
            Ractive.styleSet('theme', dark ? 'dark' : 'light');
            let scale = +settings.scale;
            if (isNaN(scale) || scale < 25 || scale > 300) {
                scale = 100;
                setTimeout(() => this.set('settings.scale', scale), 500);
            }
            if ((_b = (_a = document === null || document === void 0 ? void 0 : document.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.style)
                document.body.parentElement.style.fontSize = `${scale}%`;
            if (settings.outTheme === 'dark')
                Ractive.styleSet('out', darkTheme);
            else if (settings.outTheme === 'light')
                Ractive.styleSet('out', lightTheme);
            else
                Ractive.styleSet('out', dark ? darkTheme : lightTheme);
            this.fire('applySettings', {}, this);
        }
        copyToClipboard(str) {
            copyToClipboard(str);
        }
        getOperatorDoc(op) {
            return docs.operatorText[op] || `<no documentation available> ${op} may be a designer-only, undesirable, or custom operator`;
        }
        showOperatorDoc(op) {
            const doc = this.getOperatorDoc(op);
            if (doc)
                window.alert(doc);
        }
        getNestLevel(path) {
            return `level${Math.floor(path.split('.').length / 2)}`;
        }
        fillBlankDelimitedHeaders() {
            const sets = {};
            const headers = this.get('report.headers') || [];
            const fields = this.get('report.fields') || [];
            for (let i = 0; i < headers.length; i++) {
                if (!headers[i])
                    sets[`report.headers.${i}`] = fields[i];
            }
            this.set(sets);
        }
    }
    const designerOpts = {
        template: template$1, css: css$1, cssId: 'raport-report',
        partials: {
            measured: template$1.p.label,
        },
        data() {
            return {
                pageSizes: PageSizes,
                report: {
                    type: 'page',
                    parameters: [],
                    sources: [],
                    context: {},
                    classifyStyles: true,
                    widgets: [],
                    size: PageSizes.letter,
                    orientation: 'landscape',
                },
                temp: {
                    expr: {
                        tab: 'text',
                    },
                    widget: 'report',
                    name: 'report',
                    tree: {},
                },
                exprExpand: {},
                showProjects: true,
                actions: {
                    provideSource: () => this.push('sources', {}),
                    editProvidedSource: (ctx) => this.editProvidedData(ctx),
                },
            };
        },
        components: { Editor, Viewer },
        helpers: {
            escapeKey: Ractive.escapeKey,
        },
        computed: {
            operators() {
                const map = docs.operators.reduce((a, c) => (Array.isArray(c.op) ? c.op.forEach(o => a.push([o, c])) : a.push([c.op, c]), a), []);
                let ops = evaluate({ map }, `sort(map =>if _.0[0] == '#' then 'zz[_.0]' elif _.0[0] == '|' then ' {_.0}' else _.0)`);
                const search = this.get('opsearch');
                if (search) {
                    const re = new RegExp(search.replace(/([*.\\\/$^()[\]{}+])/g, '\\$1'), 'i');
                    ops = ops.filter(p => re.test(p[0]) || re.test(docs.operatorText[p[0]]));
                }
                return ops;
            },
            inWatermark() {
                return /^report.water/.test(this.get('temp.widget'));
            },
            inOverlay() {
                return /^report.overlay/.test(this.get('temp.widget'));
            },
            pageSize() {
                const type = this.get('report.type');
                if (type === 'flow') {
                    const width = this.get('report.width');
                    if (width)
                        return { width };
                }
                const size = this.get('report.size');
                const orientation = this.get('report.orientation') || 'landscape';
                if (size) {
                    const margin = [((size.margin || [])[0] || 0), ((size.margin || [])[1]) || 0];
                    return {
                        width: orientation === 'landscape' ? size.height : size.width,
                        height: orientation === 'landscape' ? size.width : size.height,
                        margin
                    };
                }
            },
            sourceNames() {
                const sources = this.get('report.sources') || [];
                return sources.map(s => ({ label: s.label || s.name || s.source, value: s.name || s.source }));
            },
            blankDelimitedHeaders() {
                const headers = this.get('report.headers') || [];
                return ~headers.findIndex(h => !h);
            },
        },
        observe: {
            'report.type'(v) {
                if (v === 'delimited') {
                    if (!this.get('report.fields'))
                        this.set('report.fields', []);
                }
                else {
                    if (!this.get('report.widgets'))
                        this.set('report.widgets', []);
                }
            },
            'temp.quote temp.record temp.field'(v, _o, k) {
                if (this.evalLock)
                    return;
                this.evalLock = true;
                try {
                    this.set(k.replace('temp', 'report'), parse$4(`'${v.replace(/'/g, '\\\'')}'`).v);
                }
                catch (_a) { }
                this.evalLock = false;
            },
            'report.quote report.record report.field'(v, _o, k) {
                if (this.evalLock)
                    return;
                this.evalLock = true;
                try {
                    this.set(k.replace('report', 'temp'), JSON.stringify(v).slice(1, -1));
                }
                catch (_a) { }
                this.evalLock = false;
            },
            'temp.expr.str'(v) {
                if (!v) {
                    this.set('temp.expr.error', undefined);
                    this.set('temp.expr.ast', undefined);
                }
                const path = this.get('temp.expr.path');
                const html = this.get('temp.expr.html') || this.get('temp.expr.template');
                if (path)
                    this.set(path, v);
                if (!this.evalLock) {
                    if (typeof v === 'string' && v.trim()) {
                        this.evalLock = true;
                        try {
                            const arr = Array.isArray(v) ? v : [v];
                            for (let i = 0; i < arr.length; i++) {
                                const v = typeof arr[i] === 'string' ? arr[i] : 'text' in arr[i] && typeof arr[i].text === 'string' ? arr[i].text : arr[i];
                                const parsed = (html ? parse$3 : parse$4)(v, { detailed: true, contextLines: 3, consumeAll: true });
                                const msg = ('marked' in parsed ?
                                    `${'latest' in parsed ? `${parsed.latest.message || '(no message)'} on line ${parsed.latest.line} at column ${parsed.latest.column}\n\n${parsed.latest.marked}\n\n` : ''}${parsed.message || '(no message)'} on line ${parsed.line} at column ${parsed.column}\n\n${parsed.marked}\n\n` : '') + JSON.stringify(parsed, null, '  ');
                                this.set('temp.expr.parsed', msg);
                                if ('message' in parsed) {
                                    this.set('temp.expr.error', parsed);
                                    this.set('temp.expr.errormsg', msg);
                                    this.set('temp.expr.ast', undefined);
                                }
                                else {
                                    this.set('temp.expr.ast', parsed);
                                    this.set('temp.expr.errormsg', undefined);
                                    this.set('temp.expr.error', undefined);
                                }
                                if (html)
                                    this.set('temp.expr.htmlstr', v);
                                else
                                    this.set('temp.expr.htmlstr', '');
                                if ('message' in parsed)
                                    break;
                            }
                        }
                        catch (_a) { }
                        this.evalLock = false;
                    }
                    else {
                        this.set('temp.expr.parsed', undefined);
                    }
                }
            },
            'temp.expr.ast'(v, o) {
                if (!this.evalLock) {
                    this.evalLock = true;
                    if (o === undefined && v)
                        this.set('temp.expr.error', undefined);
                    try {
                        const str = v === undefined ? '' : stringify(v, { template: this.get('temp.expr.html') });
                        this.set('temp.expr.str', str);
                        if ('v' in v && (str[0] === '`' || str[0] === `'`)) {
                            this.set('temp.expr.htmlstr', str.substr(1, -1));
                        }
                        else {
                            this.set('temp.expr.htmlstr', '');
                        }
                    }
                    catch (_a) { }
                    this.evalLock = false;
                }
            },
            'temp.expr.htmlstr'(v) {
                if (!this.evalLock) {
                    this.set('temp.expr.str', v);
                }
            },
            'temp.widget'() {
                if (this.get(this.get('temp.expr.path')) == null) {
                    this.unlink('expr');
                    this.set('temp.expr.path', undefined);
                    this.set('temp.expr.str', '');
                    this.set('temp.expr.ctx', false);
                }
            },
            async 'temp.expr.path report.parameters report.sources sources'() {
                if (sourceTm) {
                    clearTimeout(sourceTm);
                }
                sourceTm = setTimeout(async () => {
                    sourceTm = 0;
                    let v = this.get('temp.expr.path');
                    if (v) {
                        if (v.startsWith('widget.'))
                            v = v.replace('widget', this.get('temp.widget'));
                        this.set('temp.expr.ctx', this.getSchema(await this.buildLocalContext(v)));
                    }
                    else {
                        this.set('temp.expr.ctx', this.getSchema(await this.buildLocalContext()));
                    }
                }, 1000);
            },
            'report.defaultParams'(v) {
                this.set('params', Object.assign({}, v));
            },
            'report.parameters': {
                async handler(v) {
                    if (v)
                        this.initParams();
                },
                init: false,
                strict: true,
            },
            settings(v) {
                if (!this._inited)
                    return;
                this.applySettings();
                window.localStorage.setItem('settings', JSON.stringify(v));
            },
            'project projectSaved': {
                handler: debounce(function () {
                    const project = this.get('project');
                    const saved = this.get('projectSaved');
                    if (!project)
                        this.set('projectChanged', false);
                    else if (this.stringifyProject(project) !== saved)
                        this.set('projectChanged', true);
                    else
                        this.set('projectChanged', false);
                }, 1000),
            },
            'report.context'(v) {
                if (!this._contextText)
                    return;
                const target = JSON.stringify(v || {}, null, 2);
                let str = this._contextText.value;
                try {
                    str = JSON.stringify(JSON.parse(str), null, 2);
                }
                catch (_a) { }
                if (str !== target) {
                    this._contextText.value = target;
                    this.autosize(this._contextText);
                }
            },
            report: {
                handler() {
                    this.set('temp.tree', {});
                },
                strict: true
            },
            'show.props'(v) {
                if (v)
                    setTimeout(() => this.set('show.shrinkleft', true), 200);
                else
                    this.set('show.shrinkleft', false);
            },
            'show.bottom'(v) {
                setTimeout(() => this.resetScrollers());
                if (v)
                    setTimeout(() => this.set('show.shrinkbottom', true), 200);
                else
                    this.set('show.shrinkbottom', false);
            },
            'settings.leftwidth'(v) {
                Ractive.styleSet('leftwidth', v);
            },
            'settings.bottomheight'(v) {
                Ractive.styleSet('bottomheight', v);
            },
            'settings.scale'() {
                if (this.checkResize)
                    setTimeout(() => this.checkResize());
            },
            'settings.leftwidth windowWidthInRem'(v) {
                const left = this.get('settings.leftwidth') || 28;
                const wnd = this.get('windowWidthInRem');
                const bigEnough = v && left && wnd > 2.5 * (left + 2);
                this.set('show.props', bigEnough);
                this.set('show.proppop', bigEnough);
            },
        },
        on: {
            init() {
                const getSize = () => {
                    if (!this.rendered)
                        return 0;
                    const el = document.createElement('div');
                    el.style.position = 'absolute';
                    el.style.width = '1rem';
                    document.body.appendChild(el);
                    const rem = el.clientWidth;
                    el.remove();
                    const wrapper = this.find('.raport-wrapper');
                    if (wrapper)
                        return wrapper.clientWidth / rem;
                    return 0;
                };
                const resize = () => {
                    this.set('windowWidthInRem', getSize());
                };
                this.checkResize = resize;
                this.resetUndo();
                this.command('styleWithCSS', false, 'true');
                this._undoWatch = this.observe('report', debounce(this._onChange, 2000), { defer: true, init: true });
                const settings = JSON.parse(window.localStorage.getItem('settings') || '{}');
                this.set('settings', settings);
                window.addEventListener('beforeunload', () => {
                    if (this.get('settings.autosave')) {
                        window.localStorage.setItem('autosave', JSON.stringify({
                            report: this.get('report'),
                            show: this.get('show'),
                            tmp: this.get('tmp'),
                            tab: this.get('tab'),
                            'temp.expr.tab': this.get('temp.expr.tab'),
                            'temp.bottom.tab': this.get('temp.bottom.tab'),
                            projectName: this.get('project.name'),
                        }));
                    }
                    else {
                        if (!window.confirm(`Leaving this page will lose any unsaved changes. Are you sure you want to leave?`)) {
                            return false;
                        }
                    }
                });
                window.addEventListener('keydown', ev => {
                    if (ev.ctrlKey) {
                        if (ev.key === 's') {
                            this.saveProjects();
                            ev.stopPropagation();
                            ev.preventDefault();
                        }
                        else if (ev.shiftKey && ev.key === 'Enter') {
                            this.run();
                            this.set('tab', 'result');
                            ev.stopPropagation();
                            ev.preventDefault();
                        }
                        else if (ev.key === 'Enter' && document.activeElement.tagName !== 'TEXTAREA') {
                            this.set({
                                'temp.expr.tab': 'text',
                                'show.bottom': true,
                            });
                            const el = document.getElementById('expr-text');
                            if (el)
                                el.focus();
                            ev.stopPropagation();
                            ev.preventDefault();
                        }
                    }
                    else if (ev.key === 'Escape' && this.get('reparent')) {
                        this.set('reparent', undefined);
                    }
                    else if (ev.key === 'Escape' && this.get('copy')) {
                        this.set('copy', undefined);
                    }
                }, { capture: true });
                window.addEventListener('message', ev => {
                    if (ev.data === 'run') {
                        this.run();
                        this.set('tab', 'result');
                    }
                });
                this.loadProjects();
                if (settings.autosave) {
                    let save = window.localStorage.getItem('autosave');
                    if (save)
                        save = JSON.parse(save);
                    const name = save && save.projectName;
                    if (name) {
                        const projects = this.get('projects');
                        const idx = projects.findIndex((p) => p.name === name);
                        if (~idx)
                            this.linkProject(`projects.${idx}`);
                    }
                    this.set('', save, { deep: true });
                }
                this._inited = true;
                this.applySettings();
            },
            expr(ctx, path) {
                const p = path || ctx.resolve();
                this.link(p, 'expr');
                this.set('temp.expr.path', p);
            },
            teardown() {
                this._undoWatch.cancel();
            },
            render() {
                setTimeout(() => {
                    this._onChange(this.get('report'));
                    this.applySettings();
                    this.checkResize();
                    window.addEventListener('resize', this.checkResize);
                    this.once('unrender', () => {
                        window.removeEventListener('resize', this.checkResize);
                    });
                }, 100);
            }
        },
        decorators: {
            expr(node, header) {
                const ctx = this.getContext(node);
                function change(v) {
                    if (!v)
                        v = '';
                    if (header)
                        v = v.replace(/\.fields\./, '.headers.');
                    if (v === ctx.resolve('.')) {
                        node.classList.add('hover-expr');
                    }
                    else {
                        node.classList.remove('hover-expr');
                    }
                }
                const observer = ctx.observe('~/temp.expr.hover', change);
                const listeners = [
                    ctx.listen('click', () => this.fire('expr', ctx)),
                    ctx.listen('mouseover', () => {
                        let p = ctx.resolve();
                        if (header)
                            p = p.replace(/\.headers\./, '.fields.');
                        ctx.set('~/temp.expr.hover', p);
                    }),
                    ctx.listen('mouseout', () => ctx.set('~/temp.expr.hover', '')),
                ];
                return {
                    teardown() {
                        observer.cancel();
                        listeners.forEach(l => l.cancel());
                        node.classList.remove('active-expr');
                    }
                };
            },
            widget(node, type) {
                const ctx = this.getContext(node);
                node.classList.add(type);
                node.classList.add('widget');
                function select(v) {
                    if (v === ctx.resolve()) {
                        node.classList.add('active-widget');
                    }
                    else {
                        node.classList.remove('active-widget');
                    }
                }
                function hover(v) {
                    if (v === ctx.resolve()) {
                        node.classList.add('hover-widget');
                    }
                    else {
                        node.classList.remove('hover-widget');
                    }
                }
                const selectObserver = ctx.observe('~/temp.widget', select);
                const hoverObserver = ctx.observe('~/temp.hover', hover);
                return {
                    teardown() {
                        selectObserver.cancel();
                        hoverObserver.cancel();
                        node.classList.remove(type);
                        node.classList.remove('widget');
                    }
                };
            },
            scrolled(node) {
                const ctx = this.getContext(node);
                const owner = ctx.ractive;
                if (!owner._scrollers)
                    owner._scrollers = [];
                node.classList.add('scrolled');
                let tm = setTimeout(() => {
                    scroll();
                }, 100);
                node.classList.add('scroll-top', 'scroll-bottom');
                function scroll() {
                    tm = null;
                    if (node.scrollHeight > node.offsetHeight) {
                        if (node.scrollTop > 0)
                            node.classList.remove('scroll-top');
                        else
                            node.classList.add('scroll-top');
                        if (node.scrollTop + node.offsetHeight < node.scrollHeight)
                            node.classList.remove('scroll-bottom');
                        else
                            node.classList.add('scroll-bottom');
                    }
                    else {
                        node.classList.add('scroll-top', 'scroll-bottom');
                    }
                }
                const scrollb = function () {
                    if (tm)
                        return;
                    tm = setTimeout(scroll, 250);
                };
                const listener = ctx.listen('scroll', scrollb);
                owner._scrollers.push(scroll);
                return {
                    invalidate() {
                        scrollb();
                        return '';
                    },
                    teardown() {
                        node.classList.remove('scrolled', 'scroll-top', 'scroll-bottom');
                        listener.cancel();
                        owner._scrollers.splice(owner._scrollers.indexOf(scroll), 1);
                    }
                };
            },
            moveable(node) {
                const ctx = this.getContext(node);
                const idx = ctx.get('@index');
                let x, y, sx, sy, cx, cy, sz;
                const listener = ctx.listen('mousedown', (ev) => {
                    sx = ctx.get(`^^/layout.${idx}.0`) || 0;
                    sy = ctx.get(`^^/layout.${idx}.1`) || 0;
                    cx = cy = 0;
                    x = ev.clientX;
                    y = ev.clientY;
                    const sizer = document.getElementById('sizer');
                    sz = sizer ? sizer.offsetHeight : 12;
                    document.body.addEventListener('mousemove', move);
                    document.body.addEventListener('mouseup', up);
                    document.body.addEventListener('keydown', esc);
                });
                function move(ev) {
                    cx = ev.clientX - x;
                    cy = ev.clientY - y;
                    if (!ev.ctrlKey && !ev.shiftKey) {
                        ctx.set({ [`^^/layout.${idx}.0`]: Math.round(sx + (cx / sz)), [`^^/layout.${idx}.1`]: Math.round(sy + (cy / sz)) });
                    }
                    else {
                        ctx.set({ [`^^/layout.${idx}.0`]: sx + (cx / sz), [`^^/layout.${idx}.1`]: sy + (cy / sz) });
                    }
                }
                function up() {
                    document.body.removeEventListener('mousemove', move);
                    document.body.removeEventListener('mouseup', up);
                    document.body.removeEventListener('keydown', esc);
                }
                function esc(ev) {
                    if (ev.key === 'Escape') {
                        up();
                        ctx.set({ [`^^/layout.${idx}.0`]: sx, [`^^/layout.${idx}.1`]: sy });
                    }
                }
                return {
                    teardown() {
                        listener.cancel();
                    }
                };
            },
            invalidated(node) {
                const ctx = this.getContext(node);
                return {
                    teardown() { },
                    invalidate() {
                        if (ctx.hasListener('invalidate'))
                            ctx.raise('invalidate', {});
                    }
                };
            },
            autosize,
            trackfocus,
            tracked(node, name) {
                this[name] = node;
                return {
                    teardown() {
                        if (this[name] === node)
                            this[name] = undefined;
                    },
                };
            },
        },
        events: {
            keys: function KeyEvent(_node, fire) {
                const options = Object.assign({}, arguments[arguments.length - 1]);
                if (arguments.length > 2) {
                    options.keys = [];
                    for (let i = 2; i < arguments.length; i++) {
                        if (typeof arguments[i] === 'string')
                            options.keys.push(arguments[i]);
                    }
                }
                const mods = ['ctrl', 'shift', 'alt', 'meta'];
                const listener = (ev) => {
                    for (const mod of mods) {
                        if (options[mod] && !ev[`${mod}Key`] || !options[mod] && ev[`${mod}Key`])
                            return;
                    }
                    if (~options.keys.indexOf(ev.key))
                        fire({ event: ev });
                };
                window.addEventListener('keydown', listener, { capture: true, passive: true });
                return {
                    teardown() {
                        window.removeEventListener('keydown', listener, { capture: true });
                    }
                };
            },
        },
    };
    Ractive.extendWith(Designer, designerOpts);
    function nameForWidget(type, path) {
        if (path === 'report')
            return 'report ';
        else if (path === 'report.header')
            return 'Page Header ';
        else if (path === 'report.footer')
            return 'Page Footer ';
        else if (path === 'report.watermark')
            return 'Watermark ';
        else if (path === 'report.overlay')
            return 'Overlay ';
        if (type === 'container') {
            const p = Ractive.splitKeypath(path);
            const prop = p.pop();
            if (prop === 'header')
                return 'Repeater Header ';
            else if (prop === 'footer')
                return 'Repeater Footer ';
            else if (prop === 'alternate')
                return 'Repeater Alternate ';
            else if (prop === 'row')
                return 'Repeater Row ';
            else if (!isNaN(+prop) && p.pop() === 'group')
                return `Repeater Group ${+prop + 1} `;
        }
        return `${type} `;
    }
    function tryParseData(str, header) {
        if (!str)
            return;
        try {
            return JSON.parse(str);
        }
        catch (_a) {
            if (str.trim()[0] === '<') {
                const data = parse$1(str);
                if (data)
                    return data;
            }
            const brace = /[\{\[]/.exec(str);
            if (brace && brace.index >= 0 && brace.index <= 20) {
                const res = evaluate(str);
                if (typeof res === 'string') {
                    try {
                        return JSON.parse(res);
                    }
                    catch (_b) {
                        const csv = evaluate({ res, header }, `parse(str, { csv:1 detect:1 header:header })`);
                        if (csv.length)
                            return csv;
                        else
                            return str;
                    }
                }
                else if (res)
                    return res;
            }
            const csv = evaluate({ str, header }, `parse(str, { csv:1 detect:1 header:header })`);
            if (!csv.length && str.length) {
                const res = evaluate(str);
                if (typeof res === 'string') {
                    try {
                        return JSON.parse(res);
                    }
                    catch (_c) {
                        const csv = evaluate({ res, header }, `parse(str, { csv:1 detect:1 header:header })`);
                        if (csv.length)
                            return csv;
                        else
                            return str;
                    }
                }
                else if (res)
                    return res;
            }
            else
                return csv;
        }
    }
    function cloneDeep(v) {
        try {
            return JSON.parse(JSON.stringify(v));
        }
        catch (_a) {
            return {};
        }
    }
    const fontKeys = ['family', 'size', 'weight', 'color', 'align', 'line', 'right', 'pre', 'clamp'];
    function stripDefaults(json) {
        if (typeof json !== 'object')
            return json;
        if (Array.isArray(json))
            return json.map(stripDefaults);
        const res = {};
        for (const k in json) {
            const v = json[k];
            if (v === false && k !== 'classifyStyles' && k !== 'headerPerPage')
                continue;
            else if ((k === 'hide' || k === 'br') && !v)
                continue;
            else if (k === 'height' && v === 'auto' && (json.type === 'container' || json.type === 'repeater'))
                continue;
            else if (Array.isArray(v)) {
                const a = [];
                v.forEach(v => a.push(stripDefaults(v)));
                res[k] = a;
            }
            else if (typeof v === 'object') {
                if (k === 'font') {
                    if (Object.values(v).find(v => v != null && v !== '' && v !== false) !== undefined) {
                        const font = {};
                        fontKeys.forEach(f => v[f] != null && v[f] !== '' && v[f] !== false && (font[f] = v[f]));
                        if (typeof font.weight === 'string')
                            font.weight = +font.weight;
                        if (json.type === 'html' && Object.keys(font).length === 1 && font.line === 0)
                            continue;
                        res.font = font;
                    }
                    else
                        continue;
                }
                else if (!Object.keys(v).length)
                    continue;
                else if (Object.keys(v).length === 1 && 'x' in v && !v.x)
                    continue;
                else if (k === 'format' && !v.name)
                    continue;
                else {
                    const r = stripDefaults(v);
                    if (r !== '')
                        res[k] = r;
                }
            }
            else if (v === '')
                continue;
            else
                res[k] = v;
        }
        if (res.type === 'page' || res.type === 'flow' || res.type === 'delimited') {
            if (res.context && !Object.keys(res.context).length)
                delete res.context;
            if (!res.extraContext)
                delete res.extraContext;
            if (res.defaultParams && !Object.keys(res.defaultParams).length)
                delete res.defaultParams;
            if (res.sources && !res.sources.length)
                delete res.sources;
            if (res.parameters && !res.parameters.length)
                delete res.parameters;
            if (!res.orientation || res.orientation === 'landscape')
                delete res.orientation;
            if (!res.name)
                delete res.name;
            if (!res.header || !Object.keys(res.header).length || !Array.isArray(res.header.widgets) || !res.header.widgets.length)
                delete res.header;
            if (!res.footer || !Object.keys(res.footer).length || !Array.isArray(res.footer.widgets) || !res.footer.widgets.length)
                delete res.footer;
            if (!res.width)
                delete res.width;
            if (!res.margin || (Array.isArray(res.margin)) && !res.margin.length)
                delete res.margin;
            if (!res.source)
                delete res.source;
            if (!res.headers || !res.headers.length)
                delete res.headers;
            if (!res.record)
                delete res.record;
            if (!res.field)
                delete res.field;
            if (!res.quote)
                delete res.quote;
        }
        if (res.type === 'delimited') {
            delete res.size;
            delete res.widgets;
        }
        if (res.type === 'repeater') {
            if (!res.header || res.headerPerPage)
                delete res.headerPerPage;
            if (!res.header || !res.group || !res.group.length)
                delete res.groupHeaders;
            if (!res.footer || !res.group || !res.group.length)
                delete res.groupEnds;
        }
        if (res.source) {
            if (!res.filter)
                delete res.filter;
            if (!res.sort)
                delete res.sort;
            if (!res.base)
                delete res.base;
            if (!res.parameters || Object.keys(res.parameters).length === 0)
                delete res.parameters;
        }
        if (res.classifyStyles || res.classifyStyles == null)
            delete res.classifyStyles;
        return res;
    }
    const fmtOpts = { throw: true, consumeAll: true };
    function fmt(str, template, compact, stringifyOpts) {
        if (typeof str !== 'string' && typeof str !== 'object')
            return str;
        const parser = template ? parse$3 : parse$4;
        const opts = Object.assign(fmtOpts, { template });
        const listWrap = compact ? 0 : 40;
        const noIndent = compact;
        const fopts = Object.assign({ listWrap, noIndent }, stringifyOpts, { template });
        if (typeof str === 'string') {
            try {
                return stringify(parser(str, opts), fopts);
            }
            catch (_a) {
                return str;
            }
        }
        else if (Array.isArray(str)) {
            return str.map(e => {
                if (typeof e === 'string') {
                    try {
                        return stringify(parser(e, opts), fopts);
                    }
                    catch (_a) {
                        return e;
                    }
                }
                else if ('text' in e && typeof e.text === 'string') {
                    try {
                        return Object.assign({}, e, { text: stringify(parser(e.text, opts), fopts) });
                    }
                    catch (_b) {
                        return e;
                    }
                }
                else if (isValueOrExpr(e)) {
                    return stringify(e, fopts);
                }
                else {
                    return e;
                }
            });
        }
        else if ('x' in str && typeof str.x === 'string') {
            try {
                return { x: stringify(parser(str.x, opts), fopts) };
            }
            catch (_b) {
                return str;
            }
        }
        else if (isValueOrExpr(str)) {
            return stringify(str, fopts);
        }
        return str;
    }
    function fmtAll(json, compact, fopts) {
        if (typeof json !== 'object')
            return json;
        if (Array.isArray(json))
            return json.map(j => fmtAll(j, compact, fopts));
        const res = {};
        for (const k in json) {
            const v = json[k];
            if (k === 'text' || k === 'width' || k === 'height' || k === 'hide' || k === 'br')
                res[k] = fmt(v, false, compact, fopts);
            else if (k === 'name' || k === 'html')
                res[k] = fmt(v, true, compact, fopts);
            else
                res[k] = fmtAll(v, compact, fopts);
        }
        return res;
    }
    const plainKeys = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
    function jsonToJS(json, strings) {
        if (typeof json === 'number')
            return `${json}`;
        else if (typeof json === 'boolean')
            return json ? 'true' : 'false';
        else if (json === null)
            return 'null';
        else if (json === undefined)
            return 'null';
        else if (typeof json === 'string')
            return strings === 'json' ? JSON.stringify(json) : `\`${json.replace(/(`|${|\\)/g, '\\$1')}\``;
        else if (Array.isArray(json))
            return `[${json.map(v => jsonToJS(v, strings)).join(',')}]`;
        else if (typeof json === 'object')
            return `{${Object.entries(json).map(([k, v]) => v === undefined ? v : `${plainKeys.test(k) ? k : `'${k}'`}:${jsonToJS(v, strings)}`).filter(v => !!v).join(',')}}`;
    }
    function joinPath(one, two) {
        if (/\/$/.test(one))
            return `${one}${two}`;
        else
            return `${one}.${two}`;
    }
    registerOperator({
        type: 'value',
        names: ['log'],
        apply(_name, args) {
            console.log.apply(console, args);
        }
    });
    let clipEl;
    function copyToClipboard(text) {
        if (!clipEl) {
            clipEl = document.createElement('textarea');
            clipEl.id = 'clipEl';
            clipEl.style.position = 'absolute';
            clipEl.style.width = '1em';
            clipEl.style.height = '1em';
            clipEl.tabIndex = -1;
            clipEl.style.left = '-10000px';
            document.body.appendChild(clipEl);
        }
        try {
            clipEl.value = text;
            clipEl.select();
            document.execCommand('copy');
            return Promise.resolve(true);
        }
        catch (_a) {
            return Promise.resolve(false);
        }
    }

    const data = () => ({"Categories":{"1":{"CategoryID":1,"CategoryName":"Beverages","Description":"Soft drinks, coffees, teas, beers, and ales"},"2":{"CategoryID":2,"CategoryName":"Condiments","Description":"Sweet and savory sauces, relishes, spreads, and seasonings"},"3":{"CategoryID":3,"CategoryName":"Confections","Description":"Desserts, candies, and sweet breads"},"4":{"CategoryID":4,"CategoryName":"Dairy Products","Description":"Cheeses"},"5":{"CategoryID":5,"CategoryName":"Grains/Cereals","Description":"Breads, crackers, pasta, and cereal"},"6":{"CategoryID":6,"CategoryName":"Meat/Poultry","Description":"Prepared meats"},"7":{"CategoryID":7,"CategoryName":"Produce","Description":"Dried fruit and bean curd"},"8":{"CategoryID":8,"CategoryName":"Seafood","Description":"Seaweed and fish"}},"Customers":{"1":{"CustomerID":1,"CustomerName":"Alfreds Futterkiste","ContactName":"Maria Anders","Address":"Obere Str. 57","City":"Berlin","PostalCode":"12209","Country":"Germany"},"2":{"CustomerID":2,"CustomerName":"Ana Trujillo Emparedados y helados","ContactName":"Ana Trujillo","Address":"Avda. de la Constitución 2222","City":"México D.F.","PostalCode":"5021","Country":"Mexico"},"3":{"CustomerID":3,"CustomerName":"Antonio Moreno Taquería","ContactName":"Antonio Moreno","Address":"Mataderos 2312","City":"México D.F.","PostalCode":"5023","Country":"Mexico"},"4":{"CustomerID":4,"CustomerName":"Around the Horn","ContactName":"Thomas Hardy","Address":"120 Hanover Sq.","City":"London","PostalCode":"WA1 1DP","Country":"UK"},"5":{"CustomerID":5,"CustomerName":"Berglunds snabbköp","ContactName":"Christina Berglund","Address":"Berguvsvägen 8","City":"Luleå","PostalCode":"S-958 22","Country":"Sweden"},"6":{"CustomerID":6,"CustomerName":"Blauer See Delikatessen","ContactName":"Hanna Moos","Address":"Forsterstr. 57","City":"Mannheim","PostalCode":"68306","Country":"Germany"},"7":{"CustomerID":7,"CustomerName":"Blondel père et fils","ContactName":"Frédérique Citeaux","Address":"24, place Kléber","City":"Strasbourg","PostalCode":"67000","Country":"France"},"8":{"CustomerID":8,"CustomerName":"Bólido Comidas preparadas","ContactName":"Martín Sommer","Address":"C/ Araquil, 67","City":"Madrid","PostalCode":"28023","Country":"Spain"},"9":{"CustomerID":9,"CustomerName":"Bon app''","ContactName":"Laurence Lebihans","Address":"12, rue des Bouchers","City":"Marseille","PostalCode":"13008","Country":"France"},"10":{"CustomerID":10,"CustomerName":"Bottom-Dollar Marketse","ContactName":"Elizabeth Lincoln","Address":"23 Tsawassen Blvd.","City":"Tsawassen","PostalCode":"T2F 8M4","Country":"Canada"},"11":{"CustomerID":11,"CustomerName":"B''s Beverages","ContactName":"Victoria Ashworth","Address":"Fauntleroy Circus","City":"London","PostalCode":"EC2 5NT","Country":"UK"},"12":{"CustomerID":12,"CustomerName":"Cactus Comidas para llevar","ContactName":"Patricio Simpson","Address":"Cerrito 333","City":"Buenos Aires","PostalCode":"1010","Country":"Argentina"},"13":{"CustomerID":13,"CustomerName":"Centro comercial Moctezuma","ContactName":"Francisco Chang","Address":"Sierras de Granada 9993","City":"México D.F.","PostalCode":"5022","Country":"Mexico"},"14":{"CustomerID":14,"CustomerName":"Chop-suey Chinese","ContactName":"Yang Wang","Address":"Hauptstr. 29","City":"Bern","PostalCode":"3012","Country":"Switzerland"},"15":{"CustomerID":15,"CustomerName":"Comércio Mineiro","ContactName":"Pedro Afonso","Address":"Av. dos Lusíadas, 23","City":"São Paulo","PostalCode":"05432-043","Country":"Brazil"},"16":{"CustomerID":16,"CustomerName":"Consolidated Holdings","ContactName":"Elizabeth Brown","Address":"Berkeley Gardens 12 Brewery","City":"London","PostalCode":"WX1 6LT","Country":"UK"},"17":{"CustomerID":17,"CustomerName":"Drachenblut Delikatessend","ContactName":"Sven Ottlieb","Address":"Walserweg 21","City":"Aachen","PostalCode":"52066","Country":"Germany"},"18":{"CustomerID":18,"CustomerName":"Du monde entier","ContactName":"Janine Labrune","Address":"67, rue des Cinquante Otages","City":"Nantes","PostalCode":"44000","Country":"France"},"19":{"CustomerID":19,"CustomerName":"Eastern Connection","ContactName":"Ann Devon","Address":"35 King George","City":"London","PostalCode":"WX3 6FW","Country":"UK"},"20":{"CustomerID":20,"CustomerName":"Ernst Handel","ContactName":"Roland Mendel","Address":"Kirchgasse 6","City":"Graz","PostalCode":"8010","Country":"Austria"},"21":{"CustomerID":21,"CustomerName":"Familia Arquibaldo","ContactName":"Aria Cruz","Address":"Rua Orós, 92","City":"São Paulo","PostalCode":"05442-030","Country":"Brazil"},"22":{"CustomerID":22,"CustomerName":"FISSA Fabrica Inter. Salchichas S.A.","ContactName":"Diego Roel","Address":"C/ Moralzarzal, 86","City":"Madrid","PostalCode":"28034","Country":"Spain"},"23":{"CustomerID":23,"CustomerName":"Folies gourmandes","ContactName":"Martine Rancé","Address":"184, chaussée de Tournai","City":"Lille","PostalCode":"59000","Country":"France"},"24":{"CustomerID":24,"CustomerName":"Folk och fä HB","ContactName":"Maria Larsson","Address":"Åkergatan 24","City":"Bräcke","PostalCode":"S-844 67","Country":"Sweden"},"25":{"CustomerID":25,"CustomerName":"Frankenversand","ContactName":"Peter Franken","Address":"Berliner Platz 43","City":"München","PostalCode":"80805","Country":"Germany"},"26":{"CustomerID":26,"CustomerName":"France restauration","ContactName":"Carine Schmitt","Address":"54, rue Royale","City":"Nantes","PostalCode":"44000","Country":"France"},"27":{"CustomerID":27,"CustomerName":"Franchi S.p.A.","ContactName":"Paolo Accorti","Address":"Via Monte Bianco 34","City":"Torino","PostalCode":"10100","Country":"Italy"},"28":{"CustomerID":28,"CustomerName":"Furia Bacalhau e Frutos do Mar","ContactName":"Lino Rodriguez","Address":"Jardim das rosas n. 32","City":"Lisboa","PostalCode":"1675","Country":"Portugal"},"29":{"CustomerID":29,"CustomerName":"Galería del gastrónomo","ContactName":"Eduardo Saavedra","Address":"Rambla de Cataluña, 23","City":"Barcelona","PostalCode":"8022","Country":"Spain"},"30":{"CustomerID":30,"CustomerName":"Godos Cocina Típica","ContactName":"José Pedro Freyre","Address":"C/ Romero, 33","City":"Sevilla","PostalCode":"41101","Country":"Spain"},"31":{"CustomerID":31,"CustomerName":"Gourmet Lanchonetes","ContactName":"André Fonseca","Address":"Av. Brasil, 442","City":"Campinas","PostalCode":"04876-786","Country":"Brazil"},"32":{"CustomerID":32,"CustomerName":"Great Lakes Food Market","ContactName":"Howard Snyder","Address":"2732 Baker Blvd.","City":"Eugene","PostalCode":"97403","Country":"USA"},"33":{"CustomerID":33,"CustomerName":"GROSELLA-Restaurante","ContactName":"Manuel Pereira","Address":"5ª Ave. Los Palos Grandes","City":"Caracas","PostalCode":"1081","Country":"Venezuela"},"34":{"CustomerID":34,"CustomerName":"Hanari Carnes","ContactName":"Mario Pontes","Address":"Rua do Paço, 67","City":"Rio de Janeiro","PostalCode":"05454-876","Country":"Brazil"},"35":{"CustomerID":35,"CustomerName":"HILARIÓN-Abastos","ContactName":"Carlos Hernández","Address":"Carrera 22 con Ave. Carlos Soublette #8-35","City":"San Cristóbal","PostalCode":"5022","Country":"Venezuela"},"36":{"CustomerID":36,"CustomerName":"Hungry Coyote Import Store","ContactName":"Yoshi Latimer","Address":"City Center Plaza 516 Main St.","City":"Elgin","PostalCode":"97827","Country":"USA"},"37":{"CustomerID":37,"CustomerName":"Hungry Owl All-Night Grocers","ContactName":"Patricia McKenna","Address":"8 Johnstown Road","City":"Cork","PostalCode":"","Country":"Ireland"},"38":{"CustomerID":38,"CustomerName":"Island Trading","ContactName":"Helen Bennett","Address":"Garden House Crowther Way","City":"Cowes","PostalCode":"PO31 7PJ","Country":"UK"},"39":{"CustomerID":39,"CustomerName":"Königlich Essen","ContactName":"Philip Cramer","Address":"Maubelstr. 90","City":"Brandenburg","PostalCode":"14776","Country":"Germany"},"40":{"CustomerID":40,"CustomerName":"La corne d''abondance","ContactName":"Daniel Tonini","Address":"67, avenue de l''Europe","City":"Versailles","PostalCode":"78000","Country":"France"},"41":{"CustomerID":41,"CustomerName":"La maison d''Asie","ContactName":"Annette Roulet","Address":"1 rue Alsace-Lorraine","City":"Toulouse","PostalCode":"31000","Country":"France"},"42":{"CustomerID":42,"CustomerName":"Laughing Bacchus Wine Cellars","ContactName":"Yoshi Tannamuri","Address":"1900 Oak St.","City":"Vancouver","PostalCode":"V3F 2K1","Country":"Canada"},"43":{"CustomerID":43,"CustomerName":"Lazy K Kountry Store","ContactName":"John Steel","Address":"12 Orchestra Terrace","City":"Walla Walla","PostalCode":"99362","Country":"USA"},"44":{"CustomerID":44,"CustomerName":"Lehmanns Marktstand","ContactName":"Renate Messner","Address":"Magazinweg 7","City":"Frankfurt a.M.","PostalCode":"60528","Country":"Germany"},"45":{"CustomerID":45,"CustomerName":"Let''s Stop N Shop","ContactName":"Jaime Yorres","Address":"87 Polk St. Suite 5","City":"San Francisco","PostalCode":"94117","Country":"USA"},"46":{"CustomerID":46,"CustomerName":"LILA-Supermercado","ContactName":"Carlos González","Address":"Carrera 52 con Ave. Bolívar #65-98 Llano Largo","City":"Barquisimeto","PostalCode":"3508","Country":"Venezuela"},"47":{"CustomerID":47,"CustomerName":"LINO-Delicateses","ContactName":"Felipe Izquierdo","Address":"Ave. 5 de Mayo Porlamar","City":"I. de Margarita","PostalCode":"4980","Country":"Venezuela"},"48":{"CustomerID":48,"CustomerName":"Lonesome Pine Restaurant","ContactName":"Fran Wilson","Address":"89 Chiaroscuro Rd.","City":"Portland","PostalCode":"97219","Country":"USA"},"49":{"CustomerID":49,"CustomerName":"Magazzini Alimentari Riuniti","ContactName":"Giovanni Rovelli","Address":"Via Ludovico il Moro 22","City":"Bergamo","PostalCode":"24100","Country":"Italy"},"50":{"CustomerID":50,"CustomerName":"Maison Dewey","ContactName":"Catherine Dewey","Address":"Rue Joseph-Bens 532","City":"Bruxelles","PostalCode":"B-1180","Country":"Belgium"},"51":{"CustomerID":51,"CustomerName":"Mère Paillarde","ContactName":"Jean Fresnière","Address":"43 rue St. Laurent","City":"Montréal","PostalCode":"H1J 1C3","Country":"Canada"},"52":{"CustomerID":52,"CustomerName":"Morgenstern Gesundkost","ContactName":"Alexander Feuer","Address":"Heerstr. 22","City":"Leipzig","PostalCode":"4179","Country":"Germany"},"53":{"CustomerID":53,"CustomerName":"North/South","ContactName":"Simon Crowther","Address":"South House 300 Queensbridge","City":"London","PostalCode":"SW7 1RZ","Country":"UK"},"54":{"CustomerID":54,"CustomerName":"Océano Atlántico Ltda.","ContactName":"Yvonne Moncada","Address":"Ing. Gustavo Moncada 8585 Piso 20-A","City":"Buenos Aires","PostalCode":"1010","Country":"Argentina"},"55":{"CustomerID":55,"CustomerName":"Old World Delicatessen","ContactName":"Rene Phillips","Address":"2743 Bering St.","City":"Anchorage","PostalCode":"99508","Country":"USA"},"56":{"CustomerID":56,"CustomerName":"Ottilies Käseladen","ContactName":"Henriette Pfalzheim","Address":"Mehrheimerstr. 369","City":"Köln","PostalCode":"50739","Country":"Germany"},"57":{"CustomerID":57,"CustomerName":"Paris spécialités","ContactName":"Marie Bertrand","Address":"265, boulevard Charonne","City":"Paris","PostalCode":"75012","Country":"France"},"58":{"CustomerID":58,"CustomerName":"Pericles Comidas clásicas","ContactName":"Guillermo Fernández","Address":"Calle Dr. Jorge Cash 321","City":"México D.F.","PostalCode":"5033","Country":"Mexico"},"59":{"CustomerID":59,"CustomerName":"Piccolo und mehr","ContactName":"Georg Pipps","Address":"Geislweg 14","City":"Salzburg","PostalCode":"5020","Country":"Austria"},"60":{"CustomerID":60,"CustomerName":"Princesa Isabel Vinhoss","ContactName":"Isabel de Castro","Address":"Estrada da saúde n. 58","City":"Lisboa","PostalCode":"1756","Country":"Portugal"},"61":{"CustomerID":61,"CustomerName":"Que Delícia","ContactName":"Bernardo Batista","Address":"Rua da Panificadora, 12","City":"Rio de Janeiro","PostalCode":"02389-673","Country":"Brazil"},"62":{"CustomerID":62,"CustomerName":"Queen Cozinha","ContactName":"Lúcia Carvalho","Address":"Alameda dos Canàrios, 891","City":"São Paulo","PostalCode":"05487-020","Country":"Brazil"},"63":{"CustomerID":63,"CustomerName":"QUICK-Stop","ContactName":"Horst Kloss","Address":"Taucherstraße 10","City":"Cunewalde","PostalCode":"1307","Country":"Germany"},"64":{"CustomerID":64,"CustomerName":"Rancho grande","ContactName":"Sergio Gutiérrez","Address":"Av. del Libertador 900","City":"Buenos Aires","PostalCode":"1010","Country":"Argentina"},"65":{"CustomerID":65,"CustomerName":"Rattlesnake Canyon Grocery","ContactName":"Paula Wilson","Address":"2817 Milton Dr.","City":"Albuquerque","PostalCode":"87110","Country":"USA"},"66":{"CustomerID":66,"CustomerName":"Reggiani Caseifici","ContactName":"Maurizio Moroni","Address":"Strada Provinciale 124","City":"Reggio Emilia","PostalCode":"42100","Country":"Italy"},"67":{"CustomerID":67,"CustomerName":"Ricardo Adocicados","ContactName":"Janete Limeira","Address":"Av. Copacabana, 267","City":"Rio de Janeiro","PostalCode":"02389-890","Country":"Brazil"},"68":{"CustomerID":68,"CustomerName":"Richter Supermarkt","ContactName":"Michael Holz","Address":"Grenzacherweg 237","City":"Genève","PostalCode":"1203","Country":"Switzerland"},"69":{"CustomerID":69,"CustomerName":"Romero y tomillo","ContactName":"Alejandra Camino","Address":"Gran Vía, 1","City":"Madrid","PostalCode":"28001","Country":"Spain"},"70":{"CustomerID":70,"CustomerName":"Santé Gourmet","ContactName":"Jonas Bergulfsen","Address":"Erling Skakkes gate 78","City":"Stavern","PostalCode":"4110","Country":"Norway"},"71":{"CustomerID":71,"CustomerName":"Save-a-lot Markets","ContactName":"Jose Pavarotti","Address":"187 Suffolk Ln.","City":"Boise","PostalCode":"83720","Country":"USA"},"72":{"CustomerID":72,"CustomerName":"Seven Seas Imports","ContactName":"Hari Kumar","Address":"90 Wadhurst Rd.","City":"London","PostalCode":"OX15 4NB","Country":"UK"},"73":{"CustomerID":73,"CustomerName":"Simons bistro","ContactName":"Jytte Petersen","Address":"Vinbæltet 34","City":"København","PostalCode":"1734","Country":"Denmark"},"74":{"CustomerID":74,"CustomerName":"Spécialités du monde","ContactName":"Dominique Perrier","Address":"25, rue Lauriston","City":"Paris","PostalCode":"75016","Country":"France"},"75":{"CustomerID":75,"CustomerName":"Split Rail Beer & Ale","ContactName":"Art Braunschweiger","Address":"P.O. Box 555","City":"Lander","PostalCode":"82520","Country":"USA"},"76":{"CustomerID":76,"CustomerName":"Suprêmes délices","ContactName":"Pascale Cartrain","Address":"Boulevard Tirou, 255","City":"Charleroi","PostalCode":"B-6000","Country":"Belgium"},"77":{"CustomerID":77,"CustomerName":"The Big Cheese","ContactName":"Liz Nixon","Address":"89 Jefferson Way Suite 2","City":"Portland","PostalCode":"97201","Country":"USA"},"78":{"CustomerID":78,"CustomerName":"The Cracker Box","ContactName":"Liu Wong","Address":"55 Grizzly Peak Rd.","City":"Butte","PostalCode":"59801","Country":"USA"},"79":{"CustomerID":79,"CustomerName":"Toms Spezialitäten","ContactName":"Karin Josephs","Address":"Luisenstr. 48","City":"Münster","PostalCode":"44087","Country":"Germany"},"80":{"CustomerID":80,"CustomerName":"Tortuga Restaurante","ContactName":"Miguel Angel Paolino","Address":"Avda. Azteca 123","City":"México D.F.","PostalCode":"5033","Country":"Mexico"},"81":{"CustomerID":81,"CustomerName":"Tradição Hipermercados","ContactName":"Anabela Domingues","Address":"Av. Inês de Castro, 414","City":"São Paulo","PostalCode":"05634-030","Country":"Brazil"},"82":{"CustomerID":82,"CustomerName":"Trail''s Head Gourmet Provisioners","ContactName":"Helvetius Nagy","Address":"722 DaVinci Blvd.","City":"Kirkland","PostalCode":"98034","Country":"USA"},"83":{"CustomerID":83,"CustomerName":"Vaffeljernet","ContactName":"Palle Ibsen","Address":"Smagsløget 45","City":"Århus","PostalCode":"8200","Country":"Denmark"},"84":{"CustomerID":84,"CustomerName":"Victuailles en stock","ContactName":"Mary Saveley","Address":"2, rue du Commerce","City":"Lyon","PostalCode":"69004","Country":"France"},"85":{"CustomerID":85,"CustomerName":"Vins et alcools Chevalier","ContactName":"Paul Henriot","Address":"59 rue de l''Abbaye","City":"Reims","PostalCode":"51100","Country":"France"},"86":{"CustomerID":86,"CustomerName":"Die Wandernde Kuh","ContactName":"Rita Müller","Address":"Adenauerallee 900","City":"Stuttgart","PostalCode":"70563","Country":"Germany"},"87":{"CustomerID":87,"CustomerName":"Wartian Herkku","ContactName":"Pirkko Koskitalo","Address":"Torikatu 38","City":"Oulu","PostalCode":"90110","Country":"Finland"},"88":{"CustomerID":88,"CustomerName":"Wellington Importadora","ContactName":"Paula Parente","Address":"Rua do Mercado, 12","City":"Resende","PostalCode":"08737-363","Country":"Brazil"},"89":{"CustomerID":89,"CustomerName":"White Clover Markets","ContactName":"Karl Jablonski","Address":"305 - 14th Ave. S. Suite 3B","City":"Seattle","PostalCode":"98128","Country":"USA"},"90":{"CustomerID":90,"CustomerName":"Wilman Kala","ContactName":"Matti Karttunen","Address":"Keskuskatu 45","City":"Helsinki","PostalCode":"21240","Country":"Finland"},"91":{"CustomerID":91,"CustomerName":"Wolski","ContactName":"Zbyszek","Address":"ul. Filtrowa 68","City":"Walla","PostalCode":"01-012","Country":"Poland"}},"Employees":{"1":{"EmployeeID":1,"LastName":"Davolio","FirstName":"Nancy","BirthDate":"1968-12-08","Photo":"EmpID1.pic","Notes":"Education includes a BA in psychology from Colorado State University. She also completed (The Art of the Cold Call). Nancy is a member of 'Toastmasters International'."},"2":{"EmployeeID":2,"LastName":"Fuller","FirstName":"Andrew","BirthDate":"1952-02-19","Photo":"EmpID2.pic","Notes":"Andrew received his BTS commercial and a Ph.D. in international marketing from the University of Dallas. He is fluent in French and Italian and reads German. He joined the company as a sales representative, was promoted to sales manager and was then named vice president of sales. Andrew is a member of the Sales Management Roundtable, the Seattle Chamber of Commerce, and the Pacific Rim Importers Association."},"3":{"EmployeeID":3,"LastName":"Leverling","FirstName":"Janet","BirthDate":"1963-08-30","Photo":"EmpID3.pic","Notes":"Janet has a BS degree in chemistry from Boston College). She has also completed a certificate program in food retailing management. Janet was hired as a sales associate and was promoted to sales representative."},"4":{"EmployeeID":4,"LastName":"Peacock","FirstName":"Margaret","BirthDate":"1958-09-19","Photo":"EmpID4.pic","Notes":"Margaret holds a BA in English literature from Concordia College and an MA from the American Institute of Culinary Arts. She was temporarily assigned to the London office before returning to her permanent post in Seattle."},"5":{"EmployeeID":5,"LastName":"Buchanan","FirstName":"Steven","BirthDate":"1955-03-04","Photo":"EmpID5.pic","Notes":"Steven Buchanan graduated from St. Andrews University, Scotland, with a BSC degree. Upon joining the company as a sales representative, he spent 6 months in an orientation program at the Seattle office and then returned to his permanent post in London, where he was promoted to sales manager. Mr. Buchanan has completed the courses 'Successful Telemarketing' and 'International Sales Management'. He is fluent in French."},"6":{"EmployeeID":6,"LastName":"Suyama","FirstName":"Michael","BirthDate":"1963-07-02","Photo":"EmpID6.pic","Notes":"Michael is a graduate of Sussex University (MA, economics) and the University of California at Los Angeles (MBA, marketing). He has also taken the courses 'Multi-Cultural Selling' and 'Time Management for the Sales Professional'. He is fluent in Japanese and can read and write French, Portuguese, and Spanish."},"7":{"EmployeeID":7,"LastName":"King","FirstName":"Robert","BirthDate":"1960-05-29","Photo":"EmpID7.pic","Notes":"Robert King served in the Peace Corps and traveled extensively before completing his degree in English at the University of Michigan and then joining the company. After completing a course entitled 'Selling in Europe', he was transferred to the London office."},"8":{"EmployeeID":8,"LastName":"Callahan","FirstName":"Laura","BirthDate":"1958-01-09","Photo":"EmpID8.pic","Notes":"Laura received a BA in psychology from the University of Washington. She has also completed a course in business French. She reads and writes French."},"9":{"EmployeeID":9,"LastName":"Dodsworth","FirstName":"Anne","BirthDate":"1969-07-02","Photo":"EmpID9.pic","Notes":"Anne has a BA degree in English from St. Lawrence College. She is fluent in French and German."},"10":{"EmployeeID":10,"LastName":"West","FirstName":"Adam","BirthDate":"1928-09-19","Photo":"EmpID10.pic","Notes":"An old chum."}},"Shippers":{"1":{"ShipperID":1,"ShipperName":"Speedy Express","Phone":"(503) 555-9831"},"2":{"ShipperID":2,"ShipperName":"United Package","Phone":"(503) 555-3199"},"3":{"ShipperID":3,"ShipperName":"Federal Shipping","Phone":"(503) 555-9931"}},"Suppliers":{"1":{"SupplierID":1,"SupplierName":"Exotic Liquid","ContactName":"Charlotte Cooper","Address":"49 Gilbert St.","City":"Londona","PostalCode":"EC1 4SD","Country":"UK","Phone":"(171) 555-2222"},"2":{"SupplierID":2,"SupplierName":"New Orleans Cajun Delights","ContactName":"Shelley Burke","Address":"P.O. Box 78934","City":"New Orleans","PostalCode":"70117","Country":"USA","Phone":"(100) 555-4822"},"3":{"SupplierID":3,"SupplierName":"Grandma Kelly's Homestead","ContactName":"Regina Murphy","Address":"707 Oxford Rd.","City":"Ann Arbor","PostalCode":"48104","Country":"USA","Phone":"(313) 555-5735"},"4":{"SupplierID":4,"SupplierName":"Tokyo Traders","ContactName":"Yoshi Nagase","Address":"9-8 Sekimai Musashino-shi","City":"Tokyo","PostalCode":"100","Country":"Japan","Phone":"(03) 3555-5011"},"5":{"SupplierID":5,"SupplierName":"Cooperativa de Quesos 'Las Cabras'","ContactName":"Antonio del Valle Saavedra","Address":"Calle del Rosal 4","City":"Oviedo","PostalCode":"33007","Country":"Spain","Phone":"(98) 598 76 54"},"6":{"SupplierID":6,"SupplierName":"Mayumi's","ContactName":"Mayumi Ohno","Address":"92 Setsuko Chuo-ku","City":"Osaka","PostalCode":"545","Country":"Japan","Phone":"(06) 431-7877"},"7":{"SupplierID":7,"SupplierName":"Pavlova, Ltd.","ContactName":"Ian Devling","Address":"74 Rose St. Moonie Ponds","City":"Melbourne","PostalCode":"3058","Country":"Australia","Phone":"(03) 444-2343"},"8":{"SupplierID":8,"SupplierName":"Specialty Biscuits, Ltd.","ContactName":"Peter Wilson","Address":"29 King's Way","City":"Manchester","PostalCode":"M14 GSD","Country":"UK","Phone":"(161) 555-4448"},"9":{"SupplierID":9,"SupplierName":"PB Knäckebröd AB","ContactName":"Lars Peterson","Address":"Kaloadagatan 13","City":"Göteborg","PostalCode":"S-345 67","Country":"Sweden","Phone":"031-987 65 43"},"10":{"SupplierID":10,"SupplierName":"Refrescos Americanas LTDA","ContactName":"Carlos Diaz","Address":"Av. das Americanas 12.890","City":"São Paulo","PostalCode":"5442","Country":"Brazil","Phone":"(11) 555 4640"},"11":{"SupplierID":11,"SupplierName":"Heli Süßwaren GmbH & Co. KG","ContactName":"Petra Winkler","Address":"Tiergartenstraße 5","City":"Berlin","PostalCode":"10785","Country":"Germany","Phone":"(010) 9984510"},"12":{"SupplierID":12,"SupplierName":"Plutzer Lebensmittelgroßmärkte AG","ContactName":"Martin Bein","Address":"Bogenallee 51","City":"Frankfurt","PostalCode":"60439","Country":"Germany","Phone":"(069) 992755"},"13":{"SupplierID":13,"SupplierName":"Nord-Ost-Fisch Handelsgesellschaft mbH","ContactName":"Sven Petersen","Address":"Frahmredder 112a","City":"Cuxhaven","PostalCode":"27478","Country":"Germany","Phone":"(04721) 8713"},"14":{"SupplierID":14,"SupplierName":"Formaggi Fortini s.r.l.","ContactName":"Elio Rossi","Address":"Viale Dante, 75","City":"Ravenna","PostalCode":"48100","Country":"Italy","Phone":"(0544) 60323"},"15":{"SupplierID":15,"SupplierName":"Norske Meierier","ContactName":"Beate Vileid","Address":"Hatlevegen 5","City":"Sandvika","PostalCode":"1320","Country":"Norway","Phone":"(0)2-953010"},"16":{"SupplierID":16,"SupplierName":"Bigfoot Breweries","ContactName":"Cheryl Saylor","Address":"3400 - 8th Avenue Suite 210","City":"Bend","PostalCode":"97101","Country":"USA","Phone":"(503) 555-9931"},"17":{"SupplierID":17,"SupplierName":"Svensk Sjöföda AB","ContactName":"Michael Björn","Address":"Brovallavägen 231","City":"Stockholm","PostalCode":"S-123 45","Country":"Sweden","Phone":"08-123 45 67"},"18":{"SupplierID":18,"SupplierName":"Aux joyeux ecclésiastiques","ContactName":"Guylène Nodier","Address":"203, Rue des Francs-Bourgeois","City":"Paris","PostalCode":"75004","Country":"France","Phone":"(1) 03.83.00.68"},"19":{"SupplierID":19,"SupplierName":"New England Seafood Cannery","ContactName":"Robb Merchant","Address":"Order Processing Dept. 2100 Paul Revere Blvd.","City":"Boston","PostalCode":"2134","Country":"USA","Phone":"(617) 555-3267"},"20":{"SupplierID":20,"SupplierName":"Leka Trading","ContactName":"Chandra Leka","Address":"471 Serangoon Loop, Suite #402","City":"Singapore","PostalCode":"512","Country":"Singapore","Phone":"555-8787"},"21":{"SupplierID":21,"SupplierName":"Lyngbysild","ContactName":"Niels Petersen","Address":"Lyngbysild Fiskebakken 10","City":"Lyngby","PostalCode":"2800","Country":"Denmark","Phone":"43844108"},"22":{"SupplierID":22,"SupplierName":"Zaanse Snoepfabriek","ContactName":"Dirk Luchte","Address":"Verkoop Rijnweg 22","City":"Zaandam","PostalCode":"9999 ZZ","Country":"Netherlands","Phone":"(12345) 1212"},"23":{"SupplierID":23,"SupplierName":"Karkki Oy","ContactName":"Anne Heikkonen","Address":"Valtakatu 12","City":"Lappeenranta","PostalCode":"53120","Country":"Finland","Phone":"(953) 10956"},"24":{"SupplierID":24,"SupplierName":"G'day, Mate","ContactName":"Wendy Mackenzie","Address":"170 Prince Edward Parade Hunter's Hill","City":"Sydney","PostalCode":"2042","Country":"Australia","Phone":"(02) 555-5914"},"25":{"SupplierID":25,"SupplierName":"Ma Maison","ContactName":"Jean-Guy Lauzon","Address":"2960 Rue St. Laurent","City":"Montréal","PostalCode":"H1J 1C3","Country":"Canada","Phone":"(514) 555-9022"},"26":{"SupplierID":26,"SupplierName":"Pasta Buttini s.r.l.","ContactName":"Giovanni Giudici","Address":"Via dei Gelsomini, 153","City":"Salerno","PostalCode":"84100","Country":"Italy","Phone":"(089) 6547665"},"27":{"SupplierID":27,"SupplierName":"Escargots Nouveaux","ContactName":"Marie Delamare","Address":"22, rue H. Voiron","City":"Montceau","PostalCode":"71300","Country":"France","Phone":"85.57.00.07"},"28":{"SupplierID":28,"SupplierName":"Gai pâturage","ContactName":"Eliane Noz","Address":"Bat. B 3, rue des Alpes","City":"Annecy","PostalCode":"74000","Country":"France","Phone":"38.76.98.06"},"29":{"SupplierID":29,"SupplierName":"Forêts d'érables","ContactName":"Chantal Goulet","Address":"148 rue Chasseur","City":"Ste-Hyacinthe","PostalCode":"J2S 7S8","Country":"Canada","Phone":"(514) 555-2955"}},"Products":{"1":{"ProductID":1,"ProductName":"Chais","SupplierID":1,"CategoryID":1,"Unit":"10 boxes x 20 bags","Price":18},"2":{"ProductID":2,"ProductName":"Chang","SupplierID":1,"CategoryID":1,"Unit":"24 - 12 oz bottles","Price":19},"3":{"ProductID":3,"ProductName":"Aniseed Syrup","SupplierID":1,"CategoryID":2,"Unit":"12 - 550 ml bottles","Price":10},"4":{"ProductID":4,"ProductName":"Chef Anton's Cajun Seasoning","SupplierID":2,"CategoryID":2,"Unit":"48 - 6 oz jars","Price":22},"5":{"ProductID":5,"ProductName":"Chef Anton's Gumbo Mix","SupplierID":2,"CategoryID":2,"Unit":"36 boxes","Price":21.35},"6":{"ProductID":6,"ProductName":"Grandma's Boysenberry Spread","SupplierID":3,"CategoryID":2,"Unit":"12 - 8 oz jars","Price":25},"7":{"ProductID":7,"ProductName":"Uncle Bob's Organic Dried Pears","SupplierID":3,"CategoryID":7,"Unit":"12 - 1 lb pkgs.","Price":30},"8":{"ProductID":8,"ProductName":"Northwoods Cranberry Sauce","SupplierID":3,"CategoryID":2,"Unit":"12 - 12 oz jars","Price":40},"9":{"ProductID":9,"ProductName":"Mishi Kobe Niku","SupplierID":4,"CategoryID":6,"Unit":"18 - 500 g pkgs.","Price":97},"10":{"ProductID":10,"ProductName":"Ikura","SupplierID":4,"CategoryID":8,"Unit":"12 - 200 ml jars","Price":31},"11":{"ProductID":11,"ProductName":"Queso Cabrales","SupplierID":5,"CategoryID":4,"Unit":"1 kg pkg.","Price":21},"12":{"ProductID":12,"ProductName":"Queso Manchego La Pastora","SupplierID":5,"CategoryID":4,"Unit":"10 - 500 g pkgs.","Price":38},"13":{"ProductID":13,"ProductName":"Konbu","SupplierID":6,"CategoryID":8,"Unit":"2 kg box","Price":6},"14":{"ProductID":14,"ProductName":"Tofu","SupplierID":6,"CategoryID":7,"Unit":"40 - 100 g pkgs.","Price":23.25},"15":{"ProductID":15,"ProductName":"Genen Shouyu","SupplierID":6,"CategoryID":2,"Unit":"24 - 250 ml bottles","Price":15.5},"16":{"ProductID":16,"ProductName":"Pavlova","SupplierID":7,"CategoryID":3,"Unit":"32 - 500 g boxes","Price":17.45},"17":{"ProductID":17,"ProductName":"Alice Mutton","SupplierID":7,"CategoryID":6,"Unit":"20 - 1 kg tins","Price":39},"18":{"ProductID":18,"ProductName":"Carnarvon Tigers","SupplierID":7,"CategoryID":8,"Unit":"16 kg pkg.","Price":62.5},"19":{"ProductID":19,"ProductName":"Teatime Chocolate Biscuits","SupplierID":8,"CategoryID":3,"Unit":"10 boxes x 12 pieces","Price":9.2},"20":{"ProductID":20,"ProductName":"Sir Rodney's Marmalade","SupplierID":8,"CategoryID":3,"Unit":"30 gift boxes","Price":81},"21":{"ProductID":21,"ProductName":"Sir Rodney's Scones","SupplierID":8,"CategoryID":3,"Unit":"24 pkgs. x 4 pieces","Price":10},"22":{"ProductID":22,"ProductName":"Gustaf's Knäckebröd","SupplierID":9,"CategoryID":5,"Unit":"24 - 500 g pkgs.","Price":21},"23":{"ProductID":23,"ProductName":"Tunnbröd","SupplierID":9,"CategoryID":5,"Unit":"12 - 250 g pkgs.","Price":9},"24":{"ProductID":24,"ProductName":"Guaraná Fantástica","SupplierID":10,"CategoryID":1,"Unit":"12 - 355 ml cans","Price":4.5},"25":{"ProductID":25,"ProductName":"NuNuCa Nuß-Nougat-Creme","SupplierID":11,"CategoryID":3,"Unit":"20 - 450 g glasses","Price":14},"26":{"ProductID":26,"ProductName":"Gumbär Gummibärchen","SupplierID":11,"CategoryID":3,"Unit":"100 - 250 g bags","Price":31.23},"27":{"ProductID":27,"ProductName":"Schoggi Schokolade","SupplierID":11,"CategoryID":3,"Unit":"100 - 100 g pieces","Price":43.9},"28":{"ProductID":28,"ProductName":"Rössle Sauerkraut","SupplierID":12,"CategoryID":7,"Unit":"25 - 825 g cans","Price":45.6},"29":{"ProductID":29,"ProductName":"Thüringer Rostbratwurst","SupplierID":12,"CategoryID":6,"Unit":"50 bags x 30 sausgs.","Price":123.79},"30":{"ProductID":30,"ProductName":"Nord-Ost Matjeshering","SupplierID":13,"CategoryID":8,"Unit":"10 - 200 g glasses","Price":25.89},"31":{"ProductID":31,"ProductName":"Gorgonzola Telino","SupplierID":14,"CategoryID":4,"Unit":"12 - 100 g pkgs","Price":12.5},"32":{"ProductID":32,"ProductName":"Mascarpone Fabioli","SupplierID":14,"CategoryID":4,"Unit":"24 - 200 g pkgs.","Price":32},"33":{"ProductID":33,"ProductName":"Geitost","SupplierID":15,"CategoryID":4,"Unit":"500 g","Price":2.5},"34":{"ProductID":34,"ProductName":"Sasquatch Ale","SupplierID":16,"CategoryID":1,"Unit":"24 - 12 oz bottles","Price":14},"35":{"ProductID":35,"ProductName":"Steeleye Stout","SupplierID":16,"CategoryID":1,"Unit":"24 - 12 oz bottles","Price":18},"36":{"ProductID":36,"ProductName":"Inlagd Sill","SupplierID":17,"CategoryID":8,"Unit":"24 - 250 g jars","Price":19},"37":{"ProductID":37,"ProductName":"Gravad lax","SupplierID":17,"CategoryID":8,"Unit":"12 - 500 g pkgs.","Price":26},"38":{"ProductID":38,"ProductName":"Côte de Blaye","SupplierID":18,"CategoryID":1,"Unit":"12 - 75 cl bottles","Price":263.5},"39":{"ProductID":39,"ProductName":"Chartreuse verte","SupplierID":18,"CategoryID":1,"Unit":"750 cc per bottle","Price":18},"40":{"ProductID":40,"ProductName":"Boston Crab Meat","SupplierID":19,"CategoryID":8,"Unit":"24 - 4 oz tins","Price":18.4},"41":{"ProductID":41,"ProductName":"Jack's New England Clam Chowder","SupplierID":19,"CategoryID":8,"Unit":"12 - 12 oz cans","Price":9.65},"42":{"ProductID":42,"ProductName":"Singaporean Hokkien Fried Mee","SupplierID":20,"CategoryID":5,"Unit":"32 - 1 kg pkgs.","Price":14},"43":{"ProductID":43,"ProductName":"Ipoh Coffee","SupplierID":20,"CategoryID":1,"Unit":"16 - 500 g tins","Price":46},"44":{"ProductID":44,"ProductName":"Gula Malacca","SupplierID":20,"CategoryID":2,"Unit":"20 - 2 kg bags","Price":19.45},"45":{"ProductID":45,"ProductName":"Røgede sild","SupplierID":21,"CategoryID":8,"Unit":"1k pkg.","Price":9.5},"46":{"ProductID":46,"ProductName":"Spegesild","SupplierID":21,"CategoryID":8,"Unit":"4 - 450 g glasses","Price":12},"47":{"ProductID":47,"ProductName":"Zaanse koeken","SupplierID":22,"CategoryID":3,"Unit":"10 - 4 oz boxes","Price":9.5},"48":{"ProductID":48,"ProductName":"Chocolade","SupplierID":22,"CategoryID":3,"Unit":"10 pkgs.","Price":12.75},"49":{"ProductID":49,"ProductName":"Maxilaku","SupplierID":23,"CategoryID":3,"Unit":"24 - 50 g pkgs.","Price":20},"50":{"ProductID":50,"ProductName":"Valkoinen suklaa","SupplierID":23,"CategoryID":3,"Unit":"12 - 100 g bars","Price":16.25},"51":{"ProductID":51,"ProductName":"Manjimup Dried Apples","SupplierID":24,"CategoryID":7,"Unit":"50 - 300 g pkgs.","Price":53},"52":{"ProductID":52,"ProductName":"Filo Mix","SupplierID":24,"CategoryID":5,"Unit":"16 - 2 kg boxes","Price":7},"53":{"ProductID":53,"ProductName":"Perth Pasties","SupplierID":24,"CategoryID":6,"Unit":"48 pieces","Price":32.8},"54":{"ProductID":54,"ProductName":"Tourtière","SupplierID":25,"CategoryID":6,"Unit":"16 pies","Price":7.45},"55":{"ProductID":55,"ProductName":"Pâté chinois","SupplierID":25,"CategoryID":6,"Unit":"24 boxes x 2 pies","Price":24},"56":{"ProductID":56,"ProductName":"Gnocchi di nonna Alice","SupplierID":26,"CategoryID":5,"Unit":"24 - 250 g pkgs.","Price":38},"57":{"ProductID":57,"ProductName":"Ravioli Angelo","SupplierID":26,"CategoryID":5,"Unit":"24 - 250 g pkgs.","Price":19.5},"58":{"ProductID":58,"ProductName":"Escargots de Bourgogne","SupplierID":27,"CategoryID":8,"Unit":"24 pieces","Price":13.25},"59":{"ProductID":59,"ProductName":"Raclette Courdavault","SupplierID":28,"CategoryID":4,"Unit":"5 kg pkg.","Price":55},"60":{"ProductID":60,"ProductName":"Camembert Pierrot","SupplierID":28,"CategoryID":4,"Unit":"15 - 300 g rounds","Price":34},"61":{"ProductID":61,"ProductName":"Sirop d'érable","SupplierID":29,"CategoryID":2,"Unit":"24 - 500 ml bottles","Price":28.5},"62":{"ProductID":62,"ProductName":"Tarte au sucre","SupplierID":29,"CategoryID":3,"Unit":"48 pies","Price":49.3},"63":{"ProductID":63,"ProductName":"Vegie-spread","SupplierID":7,"CategoryID":2,"Unit":"15 - 625 g jars","Price":43.9},"64":{"ProductID":64,"ProductName":"Wimmers gute Semmelknödel","SupplierID":12,"CategoryID":5,"Unit":"20 bags x 4 pieces","Price":33.25},"65":{"ProductID":65,"ProductName":"Louisiana Fiery Hot Pepper Sauce","SupplierID":2,"CategoryID":2,"Unit":"32 - 8 oz bottles","Price":21.05},"66":{"ProductID":66,"ProductName":"Louisiana Hot Spiced Okra","SupplierID":2,"CategoryID":2,"Unit":"24 - 8 oz jars","Price":17},"67":{"ProductID":67,"ProductName":"Laughing Lumberjack Lager","SupplierID":16,"CategoryID":1,"Unit":"24 - 12 oz bottles","Price":14},"68":{"ProductID":68,"ProductName":"Scottish Longbreads","SupplierID":8,"CategoryID":3,"Unit":"10 boxes x 8 pieces","Price":12.5},"69":{"ProductID":69,"ProductName":"Gudbrandsdalsost","SupplierID":15,"CategoryID":4,"Unit":"10 kg pkg.","Price":36},"70":{"ProductID":70,"ProductName":"Outback Lager","SupplierID":7,"CategoryID":1,"Unit":"24 - 355 ml bottles","Price":15},"71":{"ProductID":71,"ProductName":"Fløtemysost","SupplierID":15,"CategoryID":4,"Unit":"10 - 500 g pkgs.","Price":21.5},"72":{"ProductID":72,"ProductName":"Mozzarella di Giovanni","SupplierID":14,"CategoryID":4,"Unit":"24 - 200 g pkgs.","Price":34.8},"73":{"ProductID":73,"ProductName":"Röd Kaviar","SupplierID":17,"CategoryID":8,"Unit":"24 - 150 g jars","Price":15},"74":{"ProductID":74,"ProductName":"Longlife Tofu","SupplierID":4,"CategoryID":7,"Unit":"5 kg pkg.","Price":10},"75":{"ProductID":75,"ProductName":"Rhönbräu Klosterbier","SupplierID":12,"CategoryID":1,"Unit":"24 - 0.5 l bottles","Price":7.75},"76":{"ProductID":76,"ProductName":"Lakkalikööri","SupplierID":23,"CategoryID":1,"Unit":"500 ml","Price":18},"77":{"ProductID":77,"ProductName":"Original Frankfurter grüne Soße","SupplierID":12,"CategoryID":2,"Unit":"12 boxes","Price":13}},"Orders":{"10248":{"OrderID":10248,"CustomerID":90,"EmployeeID":5,"OrderDate":"1996-07-04","ShipperID":3},"10249":{"OrderID":10249,"CustomerID":81,"EmployeeID":6,"OrderDate":"1996-07-05","ShipperID":1},"10250":{"OrderID":10250,"CustomerID":34,"EmployeeID":4,"OrderDate":"1996-07-08","ShipperID":2},"10251":{"OrderID":10251,"CustomerID":84,"EmployeeID":3,"OrderDate":"1996-07-08","ShipperID":1},"10252":{"OrderID":10252,"CustomerID":76,"EmployeeID":4,"OrderDate":"1996-07-09","ShipperID":2},"10253":{"OrderID":10253,"CustomerID":34,"EmployeeID":3,"OrderDate":"1996-07-10","ShipperID":2},"10254":{"OrderID":10254,"CustomerID":14,"EmployeeID":5,"OrderDate":"1996-07-11","ShipperID":2},"10255":{"OrderID":10255,"CustomerID":68,"EmployeeID":9,"OrderDate":"1996-07-12","ShipperID":3},"10256":{"OrderID":10256,"CustomerID":88,"EmployeeID":3,"OrderDate":"1996-07-15","ShipperID":2},"10257":{"OrderID":10257,"CustomerID":35,"EmployeeID":4,"OrderDate":"1996-07-16","ShipperID":3},"10258":{"OrderID":10258,"CustomerID":20,"EmployeeID":1,"OrderDate":"1996-07-17","ShipperID":1},"10259":{"OrderID":10259,"CustomerID":13,"EmployeeID":4,"OrderDate":"1996-07-18","ShipperID":3},"10260":{"OrderID":10260,"CustomerID":55,"EmployeeID":4,"OrderDate":"1996-07-19","ShipperID":1},"10261":{"OrderID":10261,"CustomerID":61,"EmployeeID":4,"OrderDate":"1996-07-19","ShipperID":2},"10262":{"OrderID":10262,"CustomerID":65,"EmployeeID":8,"OrderDate":"1996-07-22","ShipperID":3},"10263":{"OrderID":10263,"CustomerID":20,"EmployeeID":9,"OrderDate":"1996-07-23","ShipperID":3},"10264":{"OrderID":10264,"CustomerID":24,"EmployeeID":6,"OrderDate":"1996-07-24","ShipperID":3},"10265":{"OrderID":10265,"CustomerID":7,"EmployeeID":2,"OrderDate":"1996-07-25","ShipperID":1},"10266":{"OrderID":10266,"CustomerID":87,"EmployeeID":3,"OrderDate":"1996-07-26","ShipperID":3},"10267":{"OrderID":10267,"CustomerID":25,"EmployeeID":4,"OrderDate":"1996-07-29","ShipperID":1},"10268":{"OrderID":10268,"CustomerID":33,"EmployeeID":8,"OrderDate":"1996-07-30","ShipperID":3},"10269":{"OrderID":10269,"CustomerID":89,"EmployeeID":5,"OrderDate":"1996-07-31","ShipperID":1},"10270":{"OrderID":10270,"CustomerID":87,"EmployeeID":1,"OrderDate":"1996-08-01","ShipperID":1},"10271":{"OrderID":10271,"CustomerID":75,"EmployeeID":6,"OrderDate":"1996-08-01","ShipperID":2},"10272":{"OrderID":10272,"CustomerID":65,"EmployeeID":6,"OrderDate":"1996-08-02","ShipperID":2},"10273":{"OrderID":10273,"CustomerID":63,"EmployeeID":3,"OrderDate":"1996-08-05","ShipperID":3},"10274":{"OrderID":10274,"CustomerID":85,"EmployeeID":6,"OrderDate":"1996-08-06","ShipperID":1},"10275":{"OrderID":10275,"CustomerID":49,"EmployeeID":1,"OrderDate":"1996-08-07","ShipperID":1},"10276":{"OrderID":10276,"CustomerID":80,"EmployeeID":8,"OrderDate":"1996-08-08","ShipperID":3},"10277":{"OrderID":10277,"CustomerID":52,"EmployeeID":2,"OrderDate":"1996-08-09","ShipperID":3},"10278":{"OrderID":10278,"CustomerID":5,"EmployeeID":8,"OrderDate":"1996-08-12","ShipperID":2},"10279":{"OrderID":10279,"CustomerID":44,"EmployeeID":8,"OrderDate":"1996-08-13","ShipperID":2},"10280":{"OrderID":10280,"CustomerID":5,"EmployeeID":2,"OrderDate":"1996-08-14","ShipperID":1},"10281":{"OrderID":10281,"CustomerID":69,"EmployeeID":4,"OrderDate":"1996-08-14","ShipperID":1},"10282":{"OrderID":10282,"CustomerID":69,"EmployeeID":4,"OrderDate":"1996-08-15","ShipperID":1},"10283":{"OrderID":10283,"CustomerID":46,"EmployeeID":3,"OrderDate":"1996-08-16","ShipperID":3},"10284":{"OrderID":10284,"CustomerID":44,"EmployeeID":4,"OrderDate":"1996-08-19","ShipperID":1},"10285":{"OrderID":10285,"CustomerID":63,"EmployeeID":1,"OrderDate":"1996-08-20","ShipperID":2},"10286":{"OrderID":10286,"CustomerID":63,"EmployeeID":8,"OrderDate":"1996-08-21","ShipperID":3},"10287":{"OrderID":10287,"CustomerID":67,"EmployeeID":8,"OrderDate":"1996-08-22","ShipperID":3},"10288":{"OrderID":10288,"CustomerID":66,"EmployeeID":4,"OrderDate":"1996-08-23","ShipperID":1},"10289":{"OrderID":10289,"CustomerID":11,"EmployeeID":7,"OrderDate":"1996-08-26","ShipperID":3},"10290":{"OrderID":10290,"CustomerID":15,"EmployeeID":8,"OrderDate":"1996-08-27","ShipperID":1},"10291":{"OrderID":10291,"CustomerID":61,"EmployeeID":6,"OrderDate":"1996-08-27","ShipperID":2},"10292":{"OrderID":10292,"CustomerID":81,"EmployeeID":1,"OrderDate":"1996-08-28","ShipperID":2},"10293":{"OrderID":10293,"CustomerID":80,"EmployeeID":1,"OrderDate":"1996-08-29","ShipperID":3},"10294":{"OrderID":10294,"CustomerID":65,"EmployeeID":4,"OrderDate":"1996-08-30","ShipperID":2},"10295":{"OrderID":10295,"CustomerID":85,"EmployeeID":2,"OrderDate":"1996-09-02","ShipperID":2},"10296":{"OrderID":10296,"CustomerID":46,"EmployeeID":6,"OrderDate":"1996-09-03","ShipperID":1},"10297":{"OrderID":10297,"CustomerID":7,"EmployeeID":5,"OrderDate":"1996-09-04","ShipperID":2},"10298":{"OrderID":10298,"CustomerID":37,"EmployeeID":6,"OrderDate":"1996-09-05","ShipperID":2},"10299":{"OrderID":10299,"CustomerID":67,"EmployeeID":4,"OrderDate":"1996-09-06","ShipperID":2},"10300":{"OrderID":10300,"CustomerID":49,"EmployeeID":2,"OrderDate":"1996-09-09","ShipperID":2},"10301":{"OrderID":10301,"CustomerID":86,"EmployeeID":8,"OrderDate":"1996-09-09","ShipperID":2},"10302":{"OrderID":10302,"CustomerID":76,"EmployeeID":4,"OrderDate":"1996-09-10","ShipperID":2},"10303":{"OrderID":10303,"CustomerID":30,"EmployeeID":7,"OrderDate":"1996-09-11","ShipperID":2},"10304":{"OrderID":10304,"CustomerID":80,"EmployeeID":1,"OrderDate":"1996-09-12","ShipperID":2},"10305":{"OrderID":10305,"CustomerID":55,"EmployeeID":8,"OrderDate":"1996-09-13","ShipperID":3},"10306":{"OrderID":10306,"CustomerID":69,"EmployeeID":1,"OrderDate":"1996-09-16","ShipperID":3},"10307":{"OrderID":10307,"CustomerID":48,"EmployeeID":2,"OrderDate":"1996-09-17","ShipperID":2},"10308":{"OrderID":10308,"CustomerID":2,"EmployeeID":7,"OrderDate":"1996-09-18","ShipperID":3},"10309":{"OrderID":10309,"CustomerID":37,"EmployeeID":3,"OrderDate":"1996-09-19","ShipperID":1},"10310":{"OrderID":10310,"CustomerID":77,"EmployeeID":8,"OrderDate":"1996-09-20","ShipperID":2},"10311":{"OrderID":10311,"CustomerID":18,"EmployeeID":1,"OrderDate":"1996-09-20","ShipperID":3},"10312":{"OrderID":10312,"CustomerID":86,"EmployeeID":2,"OrderDate":"1996-09-23","ShipperID":2},"10313":{"OrderID":10313,"CustomerID":63,"EmployeeID":2,"OrderDate":"1996-09-24","ShipperID":2},"10314":{"OrderID":10314,"CustomerID":65,"EmployeeID":1,"OrderDate":"1996-09-25","ShipperID":2},"10315":{"OrderID":10315,"CustomerID":38,"EmployeeID":4,"OrderDate":"1996-09-26","ShipperID":2},"10316":{"OrderID":10316,"CustomerID":65,"EmployeeID":1,"OrderDate":"1996-09-27","ShipperID":3},"10317":{"OrderID":10317,"CustomerID":48,"EmployeeID":6,"OrderDate":"1996-09-30","ShipperID":1},"10318":{"OrderID":10318,"CustomerID":38,"EmployeeID":8,"OrderDate":"1996-10-01","ShipperID":2},"10319":{"OrderID":10319,"CustomerID":80,"EmployeeID":7,"OrderDate":"1996-10-02","ShipperID":3},"10320":{"OrderID":10320,"CustomerID":87,"EmployeeID":5,"OrderDate":"1996-10-03","ShipperID":3},"10321":{"OrderID":10321,"CustomerID":38,"EmployeeID":3,"OrderDate":"1996-10-03","ShipperID":2},"10322":{"OrderID":10322,"CustomerID":58,"EmployeeID":7,"OrderDate":"1996-10-04","ShipperID":3},"10323":{"OrderID":10323,"CustomerID":39,"EmployeeID":4,"OrderDate":"1996-10-07","ShipperID":1},"10324":{"OrderID":10324,"CustomerID":71,"EmployeeID":9,"OrderDate":"1996-10-08","ShipperID":1},"10325":{"OrderID":10325,"CustomerID":39,"EmployeeID":1,"OrderDate":"1996-10-09","ShipperID":3},"10326":{"OrderID":10326,"CustomerID":8,"EmployeeID":4,"OrderDate":"1996-10-10","ShipperID":2},"10327":{"OrderID":10327,"CustomerID":24,"EmployeeID":2,"OrderDate":"1996-10-11","ShipperID":1},"10328":{"OrderID":10328,"CustomerID":28,"EmployeeID":4,"OrderDate":"1996-10-14","ShipperID":3},"10329":{"OrderID":10329,"CustomerID":75,"EmployeeID":4,"OrderDate":"1996-10-15","ShipperID":2},"10330":{"OrderID":10330,"CustomerID":46,"EmployeeID":3,"OrderDate":"1996-10-16","ShipperID":1},"10331":{"OrderID":10331,"CustomerID":9,"EmployeeID":9,"OrderDate":"1996-10-16","ShipperID":1},"10332":{"OrderID":10332,"CustomerID":51,"EmployeeID":3,"OrderDate":"1996-10-17","ShipperID":2},"10333":{"OrderID":10333,"CustomerID":87,"EmployeeID":5,"OrderDate":"1996-10-18","ShipperID":3},"10334":{"OrderID":10334,"CustomerID":84,"EmployeeID":8,"OrderDate":"1996-10-21","ShipperID":2},"10335":{"OrderID":10335,"CustomerID":37,"EmployeeID":7,"OrderDate":"1996-10-22","ShipperID":2},"10336":{"OrderID":10336,"CustomerID":60,"EmployeeID":7,"OrderDate":"1996-10-23","ShipperID":2},"10337":{"OrderID":10337,"CustomerID":25,"EmployeeID":4,"OrderDate":"1996-10-24","ShipperID":3},"10338":{"OrderID":10338,"CustomerID":55,"EmployeeID":4,"OrderDate":"1996-10-25","ShipperID":3},"10339":{"OrderID":10339,"CustomerID":51,"EmployeeID":2,"OrderDate":"1996-10-28","ShipperID":2},"10340":{"OrderID":10340,"CustomerID":9,"EmployeeID":1,"OrderDate":"1996-10-29","ShipperID":3},"10341":{"OrderID":10341,"CustomerID":73,"EmployeeID":7,"OrderDate":"1996-10-29","ShipperID":3},"10342":{"OrderID":10342,"CustomerID":25,"EmployeeID":4,"OrderDate":"1996-10-30","ShipperID":2},"10343":{"OrderID":10343,"CustomerID":44,"EmployeeID":4,"OrderDate":"1996-10-31","ShipperID":1},"10344":{"OrderID":10344,"CustomerID":89,"EmployeeID":4,"OrderDate":"1996-11-01","ShipperID":2},"10345":{"OrderID":10345,"CustomerID":63,"EmployeeID":2,"OrderDate":"1996-11-04","ShipperID":2},"10346":{"OrderID":10346,"CustomerID":65,"EmployeeID":3,"OrderDate":"1996-11-05","ShipperID":3},"10347":{"OrderID":10347,"CustomerID":21,"EmployeeID":4,"OrderDate":"1996-11-06","ShipperID":3},"10348":{"OrderID":10348,"CustomerID":86,"EmployeeID":4,"OrderDate":"1996-11-07","ShipperID":2},"10349":{"OrderID":10349,"CustomerID":75,"EmployeeID":7,"OrderDate":"1996-11-08","ShipperID":1},"10350":{"OrderID":10350,"CustomerID":41,"EmployeeID":6,"OrderDate":"1996-11-11","ShipperID":2},"10351":{"OrderID":10351,"CustomerID":20,"EmployeeID":1,"OrderDate":"1996-11-11","ShipperID":1},"10352":{"OrderID":10352,"CustomerID":28,"EmployeeID":3,"OrderDate":"1996-11-12","ShipperID":3},"10353":{"OrderID":10353,"CustomerID":59,"EmployeeID":7,"OrderDate":"1996-11-13","ShipperID":3},"10354":{"OrderID":10354,"CustomerID":58,"EmployeeID":8,"OrderDate":"1996-11-14","ShipperID":3},"10355":{"OrderID":10355,"CustomerID":4,"EmployeeID":6,"OrderDate":"1996-11-15","ShipperID":1},"10356":{"OrderID":10356,"CustomerID":86,"EmployeeID":6,"OrderDate":"1996-11-18","ShipperID":2},"10357":{"OrderID":10357,"CustomerID":46,"EmployeeID":1,"OrderDate":"1996-11-19","ShipperID":3},"10358":{"OrderID":10358,"CustomerID":41,"EmployeeID":5,"OrderDate":"1996-11-20","ShipperID":1},"10359":{"OrderID":10359,"CustomerID":72,"EmployeeID":5,"OrderDate":"1996-11-21","ShipperID":3},"10360":{"OrderID":10360,"CustomerID":7,"EmployeeID":4,"OrderDate":"1996-11-22","ShipperID":3},"10361":{"OrderID":10361,"CustomerID":63,"EmployeeID":1,"OrderDate":"1996-11-22","ShipperID":2},"10362":{"OrderID":10362,"CustomerID":9,"EmployeeID":3,"OrderDate":"1996-11-25","ShipperID":1},"10363":{"OrderID":10363,"CustomerID":17,"EmployeeID":4,"OrderDate":"1996-11-26","ShipperID":3},"10364":{"OrderID":10364,"CustomerID":19,"EmployeeID":1,"OrderDate":"1996-11-26","ShipperID":1},"10365":{"OrderID":10365,"CustomerID":3,"EmployeeID":3,"OrderDate":"1996-11-27","ShipperID":2},"10366":{"OrderID":10366,"CustomerID":29,"EmployeeID":8,"OrderDate":"1996-11-28","ShipperID":2},"10367":{"OrderID":10367,"CustomerID":83,"EmployeeID":7,"OrderDate":"1996-11-28","ShipperID":3},"10368":{"OrderID":10368,"CustomerID":20,"EmployeeID":2,"OrderDate":"1996-11-29","ShipperID":2},"10369":{"OrderID":10369,"CustomerID":75,"EmployeeID":8,"OrderDate":"1996-12-02","ShipperID":2},"10370":{"OrderID":10370,"CustomerID":14,"EmployeeID":6,"OrderDate":"1996-12-03","ShipperID":2},"10371":{"OrderID":10371,"CustomerID":41,"EmployeeID":1,"OrderDate":"1996-12-03","ShipperID":1},"10372":{"OrderID":10372,"CustomerID":62,"EmployeeID":5,"OrderDate":"1996-12-04","ShipperID":2},"10373":{"OrderID":10373,"CustomerID":37,"EmployeeID":4,"OrderDate":"1996-12-05","ShipperID":3},"10374":{"OrderID":10374,"CustomerID":91,"EmployeeID":1,"OrderDate":"1996-12-05","ShipperID":3},"10375":{"OrderID":10375,"CustomerID":36,"EmployeeID":3,"OrderDate":"1996-12-06","ShipperID":2},"10376":{"OrderID":10376,"CustomerID":51,"EmployeeID":1,"OrderDate":"1996-12-09","ShipperID":2},"10377":{"OrderID":10377,"CustomerID":72,"EmployeeID":1,"OrderDate":"1996-12-09","ShipperID":3},"10378":{"OrderID":10378,"CustomerID":24,"EmployeeID":5,"OrderDate":"1996-12-10","ShipperID":3},"10379":{"OrderID":10379,"CustomerID":61,"EmployeeID":2,"OrderDate":"1996-12-11","ShipperID":1},"10380":{"OrderID":10380,"CustomerID":37,"EmployeeID":8,"OrderDate":"1996-12-12","ShipperID":3},"10381":{"OrderID":10381,"CustomerID":46,"EmployeeID":3,"OrderDate":"1996-12-12","ShipperID":3},"10382":{"OrderID":10382,"CustomerID":20,"EmployeeID":4,"OrderDate":"1996-12-13","ShipperID":1},"10383":{"OrderID":10383,"CustomerID":4,"EmployeeID":8,"OrderDate":"1996-12-16","ShipperID":3},"10384":{"OrderID":10384,"CustomerID":5,"EmployeeID":3,"OrderDate":"1996-12-16","ShipperID":3},"10385":{"OrderID":10385,"CustomerID":75,"EmployeeID":1,"OrderDate":"1996-12-17","ShipperID":2},"10386":{"OrderID":10386,"CustomerID":21,"EmployeeID":9,"OrderDate":"1996-12-18","ShipperID":3},"10387":{"OrderID":10387,"CustomerID":70,"EmployeeID":1,"OrderDate":"1996-12-18","ShipperID":2},"10388":{"OrderID":10388,"CustomerID":72,"EmployeeID":2,"OrderDate":"1996-12-19","ShipperID":1},"10389":{"OrderID":10389,"CustomerID":10,"EmployeeID":4,"OrderDate":"1996-12-20","ShipperID":2},"10390":{"OrderID":10390,"CustomerID":20,"EmployeeID":6,"OrderDate":"1996-12-23","ShipperID":1},"10391":{"OrderID":10391,"CustomerID":17,"EmployeeID":3,"OrderDate":"1996-12-23","ShipperID":3},"10392":{"OrderID":10392,"CustomerID":59,"EmployeeID":2,"OrderDate":"1996-12-24","ShipperID":3},"10393":{"OrderID":10393,"CustomerID":71,"EmployeeID":1,"OrderDate":"1996-12-25","ShipperID":3},"10394":{"OrderID":10394,"CustomerID":36,"EmployeeID":1,"OrderDate":"1996-12-25","ShipperID":3},"10395":{"OrderID":10395,"CustomerID":35,"EmployeeID":6,"OrderDate":"1996-12-26","ShipperID":1},"10396":{"OrderID":10396,"CustomerID":25,"EmployeeID":1,"OrderDate":"1996-12-27","ShipperID":3},"10397":{"OrderID":10397,"CustomerID":60,"EmployeeID":5,"OrderDate":"1996-12-27","ShipperID":1},"10398":{"OrderID":10398,"CustomerID":71,"EmployeeID":2,"OrderDate":"1996-12-30","ShipperID":3},"10399":{"OrderID":10399,"CustomerID":83,"EmployeeID":8,"OrderDate":"1996-12-31","ShipperID":3},"10400":{"OrderID":10400,"CustomerID":19,"EmployeeID":1,"OrderDate":"1997-01-01","ShipperID":3},"10401":{"OrderID":10401,"CustomerID":65,"EmployeeID":1,"OrderDate":"1997-01-01","ShipperID":1},"10402":{"OrderID":10402,"CustomerID":20,"EmployeeID":8,"OrderDate":"1997-01-02","ShipperID":2},"10403":{"OrderID":10403,"CustomerID":20,"EmployeeID":4,"OrderDate":"1997-01-03","ShipperID":3},"10404":{"OrderID":10404,"CustomerID":49,"EmployeeID":2,"OrderDate":"1997-01-03","ShipperID":1},"10405":{"OrderID":10405,"CustomerID":47,"EmployeeID":1,"OrderDate":"1997-01-06","ShipperID":1},"10406":{"OrderID":10406,"CustomerID":62,"EmployeeID":7,"OrderDate":"1997-01-07","ShipperID":1},"10407":{"OrderID":10407,"CustomerID":56,"EmployeeID":2,"OrderDate":"1997-01-07","ShipperID":2},"10408":{"OrderID":10408,"CustomerID":23,"EmployeeID":8,"OrderDate":"1997-01-08","ShipperID":1},"10409":{"OrderID":10409,"CustomerID":54,"EmployeeID":3,"OrderDate":"1997-01-09","ShipperID":1},"10410":{"OrderID":10410,"CustomerID":10,"EmployeeID":3,"OrderDate":"1997-01-10","ShipperID":3},"10411":{"OrderID":10411,"CustomerID":10,"EmployeeID":9,"OrderDate":"1997-01-10","ShipperID":3},"10412":{"OrderID":10412,"CustomerID":87,"EmployeeID":8,"OrderDate":"1997-01-13","ShipperID":2},"10413":{"OrderID":10413,"CustomerID":41,"EmployeeID":3,"OrderDate":"1997-01-14","ShipperID":2},"10414":{"OrderID":10414,"CustomerID":21,"EmployeeID":2,"OrderDate":"1997-01-14","ShipperID":3},"10415":{"OrderID":10415,"CustomerID":36,"EmployeeID":3,"OrderDate":"1997-01-15","ShipperID":1},"10416":{"OrderID":10416,"CustomerID":87,"EmployeeID":8,"OrderDate":"1997-01-16","ShipperID":3},"10417":{"OrderID":10417,"CustomerID":73,"EmployeeID":4,"OrderDate":"1997-01-16","ShipperID":3},"10418":{"OrderID":10418,"CustomerID":63,"EmployeeID":4,"OrderDate":"1997-01-17","ShipperID":1},"10419":{"OrderID":10419,"CustomerID":68,"EmployeeID":4,"OrderDate":"1997-01-20","ShipperID":2},"10420":{"OrderID":10420,"CustomerID":88,"EmployeeID":3,"OrderDate":"1997-01-21","ShipperID":1},"10421":{"OrderID":10421,"CustomerID":61,"EmployeeID":8,"OrderDate":"1997-01-21","ShipperID":1},"10422":{"OrderID":10422,"CustomerID":27,"EmployeeID":2,"OrderDate":"1997-01-22","ShipperID":1},"10423":{"OrderID":10423,"CustomerID":31,"EmployeeID":6,"OrderDate":"1997-01-23","ShipperID":3},"10424":{"OrderID":10424,"CustomerID":51,"EmployeeID":7,"OrderDate":"1997-01-23","ShipperID":2},"10425":{"OrderID":10425,"CustomerID":41,"EmployeeID":6,"OrderDate":"1997-01-24","ShipperID":2},"10426":{"OrderID":10426,"CustomerID":29,"EmployeeID":4,"OrderDate":"1997-01-27","ShipperID":1},"10427":{"OrderID":10427,"CustomerID":59,"EmployeeID":4,"OrderDate":"1997-01-27","ShipperID":2},"10428":{"OrderID":10428,"CustomerID":66,"EmployeeID":7,"OrderDate":"1997-01-28","ShipperID":1},"10429":{"OrderID":10429,"CustomerID":37,"EmployeeID":3,"OrderDate":"1997-01-29","ShipperID":2},"10430":{"OrderID":10430,"CustomerID":20,"EmployeeID":4,"OrderDate":"1997-01-30","ShipperID":1},"10431":{"OrderID":10431,"CustomerID":10,"EmployeeID":4,"OrderDate":"1997-01-30","ShipperID":2},"10432":{"OrderID":10432,"CustomerID":75,"EmployeeID":3,"OrderDate":"1997-01-31","ShipperID":2},"10433":{"OrderID":10433,"CustomerID":60,"EmployeeID":3,"OrderDate":"1997-02-03","ShipperID":3},"10434":{"OrderID":10434,"CustomerID":24,"EmployeeID":3,"OrderDate":"1997-02-03","ShipperID":2},"10435":{"OrderID":10435,"CustomerID":16,"EmployeeID":8,"OrderDate":"1997-02-04","ShipperID":2},"10436":{"OrderID":10436,"CustomerID":7,"EmployeeID":3,"OrderDate":"1997-02-05","ShipperID":2},"10437":{"OrderID":10437,"CustomerID":87,"EmployeeID":8,"OrderDate":"1997-02-05","ShipperID":1},"10438":{"OrderID":10438,"CustomerID":79,"EmployeeID":3,"OrderDate":"1997-02-06","ShipperID":2},"10439":{"OrderID":10439,"CustomerID":51,"EmployeeID":6,"OrderDate":"1997-02-07","ShipperID":3},"10440":{"OrderID":10440,"CustomerID":71,"EmployeeID":4,"OrderDate":"1997-02-10","ShipperID":2},"10441":{"OrderID":10441,"CustomerID":55,"EmployeeID":3,"OrderDate":"1997-02-10","ShipperID":2},"10442":{"OrderID":10442,"CustomerID":20,"EmployeeID":3,"OrderDate":"1997-02-11","ShipperID":2},"10443":{"OrderID":10443,"CustomerID":66,"EmployeeID":8,"OrderDate":"1997-02-12","ShipperID":1}},"OrderDetails":{"1":{"OrderDetailID":1,"OrderID":10248,"ProductID":11,"Quantity":12},"2":{"OrderDetailID":2,"OrderID":10248,"ProductID":42,"Quantity":10},"3":{"OrderDetailID":3,"OrderID":10248,"ProductID":72,"Quantity":5},"4":{"OrderDetailID":4,"OrderID":10249,"ProductID":14,"Quantity":9},"5":{"OrderDetailID":5,"OrderID":10249,"ProductID":51,"Quantity":40},"6":{"OrderDetailID":6,"OrderID":10250,"ProductID":41,"Quantity":10},"7":{"OrderDetailID":7,"OrderID":10250,"ProductID":51,"Quantity":35},"8":{"OrderDetailID":8,"OrderID":10250,"ProductID":65,"Quantity":15},"9":{"OrderDetailID":9,"OrderID":10251,"ProductID":22,"Quantity":6},"10":{"OrderDetailID":10,"OrderID":10251,"ProductID":57,"Quantity":15},"11":{"OrderDetailID":11,"OrderID":10251,"ProductID":65,"Quantity":20},"12":{"OrderDetailID":12,"OrderID":10252,"ProductID":20,"Quantity":40},"13":{"OrderDetailID":13,"OrderID":10252,"ProductID":33,"Quantity":25},"14":{"OrderDetailID":14,"OrderID":10252,"ProductID":60,"Quantity":40},"15":{"OrderDetailID":15,"OrderID":10253,"ProductID":31,"Quantity":20},"16":{"OrderDetailID":16,"OrderID":10253,"ProductID":39,"Quantity":42},"17":{"OrderDetailID":17,"OrderID":10253,"ProductID":49,"Quantity":40},"18":{"OrderDetailID":18,"OrderID":10254,"ProductID":24,"Quantity":15},"19":{"OrderDetailID":19,"OrderID":10254,"ProductID":55,"Quantity":21},"20":{"OrderDetailID":20,"OrderID":10254,"ProductID":74,"Quantity":21},"21":{"OrderDetailID":21,"OrderID":10255,"ProductID":2,"Quantity":20},"22":{"OrderDetailID":22,"OrderID":10255,"ProductID":16,"Quantity":35},"23":{"OrderDetailID":23,"OrderID":10255,"ProductID":36,"Quantity":25},"24":{"OrderDetailID":24,"OrderID":10255,"ProductID":59,"Quantity":30},"25":{"OrderDetailID":25,"OrderID":10256,"ProductID":53,"Quantity":15},"26":{"OrderDetailID":26,"OrderID":10256,"ProductID":77,"Quantity":12},"27":{"OrderDetailID":27,"OrderID":10257,"ProductID":27,"Quantity":25},"28":{"OrderDetailID":28,"OrderID":10257,"ProductID":39,"Quantity":6},"29":{"OrderDetailID":29,"OrderID":10257,"ProductID":77,"Quantity":15},"30":{"OrderDetailID":30,"OrderID":10258,"ProductID":2,"Quantity":50},"31":{"OrderDetailID":31,"OrderID":10258,"ProductID":5,"Quantity":65},"32":{"OrderDetailID":32,"OrderID":10258,"ProductID":32,"Quantity":6},"33":{"OrderDetailID":33,"OrderID":10259,"ProductID":21,"Quantity":10},"34":{"OrderDetailID":34,"OrderID":10259,"ProductID":37,"Quantity":1},"35":{"OrderDetailID":35,"OrderID":10260,"ProductID":41,"Quantity":16},"36":{"OrderDetailID":36,"OrderID":10260,"ProductID":57,"Quantity":50},"37":{"OrderDetailID":37,"OrderID":10260,"ProductID":62,"Quantity":15},"38":{"OrderDetailID":38,"OrderID":10260,"ProductID":70,"Quantity":21},"39":{"OrderDetailID":39,"OrderID":10261,"ProductID":21,"Quantity":20},"40":{"OrderDetailID":40,"OrderID":10261,"ProductID":35,"Quantity":20},"41":{"OrderDetailID":41,"OrderID":10262,"ProductID":5,"Quantity":12},"42":{"OrderDetailID":42,"OrderID":10262,"ProductID":7,"Quantity":15},"43":{"OrderDetailID":43,"OrderID":10262,"ProductID":56,"Quantity":2},"44":{"OrderDetailID":44,"OrderID":10263,"ProductID":16,"Quantity":60},"45":{"OrderDetailID":45,"OrderID":10263,"ProductID":24,"Quantity":28},"46":{"OrderDetailID":46,"OrderID":10263,"ProductID":30,"Quantity":60},"47":{"OrderDetailID":47,"OrderID":10263,"ProductID":74,"Quantity":36},"48":{"OrderDetailID":48,"OrderID":10264,"ProductID":2,"Quantity":35},"49":{"OrderDetailID":49,"OrderID":10264,"ProductID":41,"Quantity":25},"50":{"OrderDetailID":50,"OrderID":10265,"ProductID":17,"Quantity":30},"51":{"OrderDetailID":51,"OrderID":10265,"ProductID":70,"Quantity":20},"52":{"OrderDetailID":52,"OrderID":10266,"ProductID":12,"Quantity":12},"53":{"OrderDetailID":53,"OrderID":10267,"ProductID":40,"Quantity":50},"54":{"OrderDetailID":54,"OrderID":10267,"ProductID":59,"Quantity":70},"55":{"OrderDetailID":55,"OrderID":10267,"ProductID":76,"Quantity":15},"56":{"OrderDetailID":56,"OrderID":10268,"ProductID":29,"Quantity":10},"57":{"OrderDetailID":57,"OrderID":10268,"ProductID":72,"Quantity":4},"58":{"OrderDetailID":58,"OrderID":10269,"ProductID":33,"Quantity":60},"59":{"OrderDetailID":59,"OrderID":10269,"ProductID":72,"Quantity":20},"60":{"OrderDetailID":60,"OrderID":10270,"ProductID":36,"Quantity":30},"61":{"OrderDetailID":61,"OrderID":10270,"ProductID":43,"Quantity":25},"62":{"OrderDetailID":62,"OrderID":10271,"ProductID":33,"Quantity":24},"63":{"OrderDetailID":63,"OrderID":10272,"ProductID":20,"Quantity":6},"64":{"OrderDetailID":64,"OrderID":10272,"ProductID":31,"Quantity":40},"65":{"OrderDetailID":65,"OrderID":10272,"ProductID":72,"Quantity":24},"66":{"OrderDetailID":66,"OrderID":10273,"ProductID":10,"Quantity":24},"67":{"OrderDetailID":67,"OrderID":10273,"ProductID":31,"Quantity":15},"68":{"OrderDetailID":68,"OrderID":10273,"ProductID":33,"Quantity":20},"69":{"OrderDetailID":69,"OrderID":10273,"ProductID":40,"Quantity":60},"70":{"OrderDetailID":70,"OrderID":10273,"ProductID":76,"Quantity":33},"71":{"OrderDetailID":71,"OrderID":10274,"ProductID":71,"Quantity":20},"72":{"OrderDetailID":72,"OrderID":10274,"ProductID":72,"Quantity":7},"73":{"OrderDetailID":73,"OrderID":10275,"ProductID":24,"Quantity":12},"74":{"OrderDetailID":74,"OrderID":10275,"ProductID":59,"Quantity":6},"75":{"OrderDetailID":75,"OrderID":10276,"ProductID":10,"Quantity":15},"76":{"OrderDetailID":76,"OrderID":10276,"ProductID":13,"Quantity":10},"77":{"OrderDetailID":77,"OrderID":10277,"ProductID":28,"Quantity":20},"78":{"OrderDetailID":78,"OrderID":10277,"ProductID":62,"Quantity":12},"79":{"OrderDetailID":79,"OrderID":10278,"ProductID":44,"Quantity":16},"80":{"OrderDetailID":80,"OrderID":10278,"ProductID":59,"Quantity":15},"81":{"OrderDetailID":81,"OrderID":10278,"ProductID":63,"Quantity":8},"82":{"OrderDetailID":82,"OrderID":10278,"ProductID":73,"Quantity":25},"83":{"OrderDetailID":83,"OrderID":10279,"ProductID":17,"Quantity":15},"84":{"OrderDetailID":84,"OrderID":10280,"ProductID":24,"Quantity":12},"85":{"OrderDetailID":85,"OrderID":10280,"ProductID":55,"Quantity":20},"86":{"OrderDetailID":86,"OrderID":10280,"ProductID":75,"Quantity":30},"87":{"OrderDetailID":87,"OrderID":10281,"ProductID":19,"Quantity":1},"88":{"OrderDetailID":88,"OrderID":10281,"ProductID":24,"Quantity":6},"89":{"OrderDetailID":89,"OrderID":10281,"ProductID":35,"Quantity":4},"90":{"OrderDetailID":90,"OrderID":10282,"ProductID":30,"Quantity":6},"91":{"OrderDetailID":91,"OrderID":10282,"ProductID":57,"Quantity":2},"92":{"OrderDetailID":92,"OrderID":10283,"ProductID":15,"Quantity":20},"93":{"OrderDetailID":93,"OrderID":10283,"ProductID":19,"Quantity":18},"94":{"OrderDetailID":94,"OrderID":10283,"ProductID":60,"Quantity":35},"95":{"OrderDetailID":95,"OrderID":10283,"ProductID":72,"Quantity":3},"96":{"OrderDetailID":96,"OrderID":10284,"ProductID":27,"Quantity":15},"97":{"OrderDetailID":97,"OrderID":10284,"ProductID":44,"Quantity":21},"98":{"OrderDetailID":98,"OrderID":10284,"ProductID":60,"Quantity":20},"99":{"OrderDetailID":99,"OrderID":10284,"ProductID":67,"Quantity":5},"100":{"OrderDetailID":100,"OrderID":10285,"ProductID":1,"Quantity":45},"101":{"OrderDetailID":101,"OrderID":10285,"ProductID":40,"Quantity":40},"102":{"OrderDetailID":102,"OrderID":10285,"ProductID":53,"Quantity":36},"103":{"OrderDetailID":103,"OrderID":10286,"ProductID":35,"Quantity":100},"104":{"OrderDetailID":104,"OrderID":10286,"ProductID":62,"Quantity":40},"105":{"OrderDetailID":105,"OrderID":10287,"ProductID":16,"Quantity":40},"106":{"OrderDetailID":106,"OrderID":10287,"ProductID":34,"Quantity":20},"107":{"OrderDetailID":107,"OrderID":10287,"ProductID":46,"Quantity":15},"108":{"OrderDetailID":108,"OrderID":10288,"ProductID":54,"Quantity":10},"109":{"OrderDetailID":109,"OrderID":10288,"ProductID":68,"Quantity":3},"110":{"OrderDetailID":110,"OrderID":10289,"ProductID":3,"Quantity":30},"111":{"OrderDetailID":111,"OrderID":10289,"ProductID":64,"Quantity":9},"112":{"OrderDetailID":112,"OrderID":10290,"ProductID":5,"Quantity":20},"113":{"OrderDetailID":113,"OrderID":10290,"ProductID":29,"Quantity":15},"114":{"OrderDetailID":114,"OrderID":10290,"ProductID":49,"Quantity":15},"115":{"OrderDetailID":115,"OrderID":10290,"ProductID":77,"Quantity":10},"116":{"OrderDetailID":116,"OrderID":10291,"ProductID":13,"Quantity":20},"117":{"OrderDetailID":117,"OrderID":10291,"ProductID":44,"Quantity":24},"118":{"OrderDetailID":118,"OrderID":10291,"ProductID":51,"Quantity":2},"119":{"OrderDetailID":119,"OrderID":10292,"ProductID":20,"Quantity":20},"120":{"OrderDetailID":120,"OrderID":10293,"ProductID":18,"Quantity":12},"121":{"OrderDetailID":121,"OrderID":10293,"ProductID":24,"Quantity":10},"122":{"OrderDetailID":122,"OrderID":10293,"ProductID":63,"Quantity":5},"123":{"OrderDetailID":123,"OrderID":10293,"ProductID":75,"Quantity":6},"124":{"OrderDetailID":124,"OrderID":10294,"ProductID":1,"Quantity":18},"125":{"OrderDetailID":125,"OrderID":10294,"ProductID":17,"Quantity":15},"126":{"OrderDetailID":126,"OrderID":10294,"ProductID":43,"Quantity":15},"127":{"OrderDetailID":127,"OrderID":10294,"ProductID":60,"Quantity":21},"128":{"OrderDetailID":128,"OrderID":10294,"ProductID":75,"Quantity":6},"129":{"OrderDetailID":129,"OrderID":10295,"ProductID":56,"Quantity":4},"130":{"OrderDetailID":130,"OrderID":10296,"ProductID":11,"Quantity":12},"131":{"OrderDetailID":131,"OrderID":10296,"ProductID":16,"Quantity":30},"132":{"OrderDetailID":132,"OrderID":10296,"ProductID":69,"Quantity":15},"133":{"OrderDetailID":133,"OrderID":10297,"ProductID":39,"Quantity":60},"134":{"OrderDetailID":134,"OrderID":10297,"ProductID":72,"Quantity":20},"135":{"OrderDetailID":135,"OrderID":10298,"ProductID":2,"Quantity":40},"136":{"OrderDetailID":136,"OrderID":10298,"ProductID":36,"Quantity":40},"137":{"OrderDetailID":137,"OrderID":10298,"ProductID":59,"Quantity":30},"138":{"OrderDetailID":138,"OrderID":10298,"ProductID":62,"Quantity":15},"139":{"OrderDetailID":139,"OrderID":10299,"ProductID":19,"Quantity":15},"140":{"OrderDetailID":140,"OrderID":10299,"ProductID":70,"Quantity":20},"141":{"OrderDetailID":141,"OrderID":10300,"ProductID":66,"Quantity":30},"142":{"OrderDetailID":142,"OrderID":10300,"ProductID":68,"Quantity":20},"143":{"OrderDetailID":143,"OrderID":10301,"ProductID":40,"Quantity":10},"144":{"OrderDetailID":144,"OrderID":10301,"ProductID":56,"Quantity":20},"145":{"OrderDetailID":145,"OrderID":10302,"ProductID":17,"Quantity":40},"146":{"OrderDetailID":146,"OrderID":10302,"ProductID":28,"Quantity":28},"147":{"OrderDetailID":147,"OrderID":10302,"ProductID":43,"Quantity":12},"148":{"OrderDetailID":148,"OrderID":10303,"ProductID":40,"Quantity":40},"149":{"OrderDetailID":149,"OrderID":10303,"ProductID":65,"Quantity":30},"150":{"OrderDetailID":150,"OrderID":10303,"ProductID":68,"Quantity":15},"151":{"OrderDetailID":151,"OrderID":10304,"ProductID":49,"Quantity":30},"152":{"OrderDetailID":152,"OrderID":10304,"ProductID":59,"Quantity":10},"153":{"OrderDetailID":153,"OrderID":10304,"ProductID":71,"Quantity":2},"154":{"OrderDetailID":154,"OrderID":10305,"ProductID":18,"Quantity":25},"155":{"OrderDetailID":155,"OrderID":10305,"ProductID":29,"Quantity":25},"156":{"OrderDetailID":156,"OrderID":10305,"ProductID":39,"Quantity":30},"157":{"OrderDetailID":157,"OrderID":10306,"ProductID":30,"Quantity":10},"158":{"OrderDetailID":158,"OrderID":10306,"ProductID":53,"Quantity":10},"159":{"OrderDetailID":159,"OrderID":10306,"ProductID":54,"Quantity":5},"160":{"OrderDetailID":160,"OrderID":10307,"ProductID":62,"Quantity":10},"161":{"OrderDetailID":161,"OrderID":10307,"ProductID":68,"Quantity":3},"162":{"OrderDetailID":162,"OrderID":10308,"ProductID":69,"Quantity":1},"163":{"OrderDetailID":163,"OrderID":10308,"ProductID":70,"Quantity":5},"164":{"OrderDetailID":164,"OrderID":10309,"ProductID":4,"Quantity":20},"165":{"OrderDetailID":165,"OrderID":10309,"ProductID":6,"Quantity":30},"166":{"OrderDetailID":166,"OrderID":10309,"ProductID":42,"Quantity":2},"167":{"OrderDetailID":167,"OrderID":10309,"ProductID":43,"Quantity":20},"168":{"OrderDetailID":168,"OrderID":10309,"ProductID":71,"Quantity":3},"169":{"OrderDetailID":169,"OrderID":10310,"ProductID":16,"Quantity":10},"170":{"OrderDetailID":170,"OrderID":10310,"ProductID":62,"Quantity":5},"171":{"OrderDetailID":171,"OrderID":10311,"ProductID":42,"Quantity":6},"172":{"OrderDetailID":172,"OrderID":10311,"ProductID":69,"Quantity":7},"173":{"OrderDetailID":173,"OrderID":10312,"ProductID":28,"Quantity":4},"174":{"OrderDetailID":174,"OrderID":10312,"ProductID":43,"Quantity":24},"175":{"OrderDetailID":175,"OrderID":10312,"ProductID":53,"Quantity":20},"176":{"OrderDetailID":176,"OrderID":10312,"ProductID":75,"Quantity":10},"177":{"OrderDetailID":177,"OrderID":10313,"ProductID":36,"Quantity":12},"178":{"OrderDetailID":178,"OrderID":10314,"ProductID":32,"Quantity":40},"179":{"OrderDetailID":179,"OrderID":10314,"ProductID":58,"Quantity":30},"180":{"OrderDetailID":180,"OrderID":10314,"ProductID":62,"Quantity":25},"181":{"OrderDetailID":181,"OrderID":10315,"ProductID":34,"Quantity":14},"182":{"OrderDetailID":182,"OrderID":10315,"ProductID":70,"Quantity":30},"183":{"OrderDetailID":183,"OrderID":10316,"ProductID":41,"Quantity":10},"184":{"OrderDetailID":184,"OrderID":10316,"ProductID":62,"Quantity":70},"185":{"OrderDetailID":185,"OrderID":10317,"ProductID":1,"Quantity":20},"186":{"OrderDetailID":186,"OrderID":10318,"ProductID":41,"Quantity":20},"187":{"OrderDetailID":187,"OrderID":10318,"ProductID":76,"Quantity":6},"188":{"OrderDetailID":188,"OrderID":10319,"ProductID":17,"Quantity":8},"189":{"OrderDetailID":189,"OrderID":10319,"ProductID":28,"Quantity":14},"190":{"OrderDetailID":190,"OrderID":10319,"ProductID":76,"Quantity":30},"191":{"OrderDetailID":191,"OrderID":10320,"ProductID":71,"Quantity":30},"192":{"OrderDetailID":192,"OrderID":10321,"ProductID":35,"Quantity":10},"193":{"OrderDetailID":193,"OrderID":10322,"ProductID":52,"Quantity":20},"194":{"OrderDetailID":194,"OrderID":10323,"ProductID":15,"Quantity":5},"195":{"OrderDetailID":195,"OrderID":10323,"ProductID":25,"Quantity":4},"196":{"OrderDetailID":196,"OrderID":10323,"ProductID":39,"Quantity":4},"197":{"OrderDetailID":197,"OrderID":10324,"ProductID":16,"Quantity":21},"198":{"OrderDetailID":198,"OrderID":10324,"ProductID":35,"Quantity":70},"199":{"OrderDetailID":199,"OrderID":10324,"ProductID":46,"Quantity":30},"200":{"OrderDetailID":200,"OrderID":10324,"ProductID":59,"Quantity":40},"201":{"OrderDetailID":201,"OrderID":10324,"ProductID":63,"Quantity":80},"202":{"OrderDetailID":202,"OrderID":10325,"ProductID":6,"Quantity":6},"203":{"OrderDetailID":203,"OrderID":10325,"ProductID":13,"Quantity":12},"204":{"OrderDetailID":204,"OrderID":10325,"ProductID":14,"Quantity":9},"205":{"OrderDetailID":205,"OrderID":10325,"ProductID":31,"Quantity":4},"206":{"OrderDetailID":206,"OrderID":10325,"ProductID":72,"Quantity":40},"207":{"OrderDetailID":207,"OrderID":10326,"ProductID":4,"Quantity":24},"208":{"OrderDetailID":208,"OrderID":10326,"ProductID":57,"Quantity":16},"209":{"OrderDetailID":209,"OrderID":10326,"ProductID":75,"Quantity":50},"210":{"OrderDetailID":210,"OrderID":10327,"ProductID":2,"Quantity":25},"211":{"OrderDetailID":211,"OrderID":10327,"ProductID":11,"Quantity":50},"212":{"OrderDetailID":212,"OrderID":10327,"ProductID":30,"Quantity":35},"213":{"OrderDetailID":213,"OrderID":10327,"ProductID":58,"Quantity":30},"214":{"OrderDetailID":214,"OrderID":10328,"ProductID":59,"Quantity":9},"215":{"OrderDetailID":215,"OrderID":10328,"ProductID":65,"Quantity":40},"216":{"OrderDetailID":216,"OrderID":10328,"ProductID":68,"Quantity":10},"217":{"OrderDetailID":217,"OrderID":10329,"ProductID":19,"Quantity":10},"218":{"OrderDetailID":218,"OrderID":10329,"ProductID":30,"Quantity":8},"219":{"OrderDetailID":219,"OrderID":10329,"ProductID":38,"Quantity":20},"220":{"OrderDetailID":220,"OrderID":10329,"ProductID":56,"Quantity":12},"221":{"OrderDetailID":221,"OrderID":10330,"ProductID":26,"Quantity":50},"222":{"OrderDetailID":222,"OrderID":10330,"ProductID":72,"Quantity":25},"223":{"OrderDetailID":223,"OrderID":10331,"ProductID":54,"Quantity":15},"224":{"OrderDetailID":224,"OrderID":10332,"ProductID":18,"Quantity":40},"225":{"OrderDetailID":225,"OrderID":10332,"ProductID":42,"Quantity":10},"226":{"OrderDetailID":226,"OrderID":10332,"ProductID":47,"Quantity":16},"227":{"OrderDetailID":227,"OrderID":10333,"ProductID":14,"Quantity":10},"228":{"OrderDetailID":228,"OrderID":10333,"ProductID":21,"Quantity":10},"229":{"OrderDetailID":229,"OrderID":10333,"ProductID":71,"Quantity":40},"230":{"OrderDetailID":230,"OrderID":10334,"ProductID":52,"Quantity":8},"231":{"OrderDetailID":231,"OrderID":10334,"ProductID":68,"Quantity":10},"232":{"OrderDetailID":232,"OrderID":10335,"ProductID":2,"Quantity":7},"233":{"OrderDetailID":233,"OrderID":10335,"ProductID":31,"Quantity":25},"234":{"OrderDetailID":234,"OrderID":10335,"ProductID":32,"Quantity":6},"235":{"OrderDetailID":235,"OrderID":10335,"ProductID":51,"Quantity":48},"236":{"OrderDetailID":236,"OrderID":10336,"ProductID":4,"Quantity":18},"237":{"OrderDetailID":237,"OrderID":10337,"ProductID":23,"Quantity":40},"238":{"OrderDetailID":238,"OrderID":10337,"ProductID":26,"Quantity":24},"239":{"OrderDetailID":239,"OrderID":10337,"ProductID":36,"Quantity":20},"240":{"OrderDetailID":240,"OrderID":10337,"ProductID":37,"Quantity":28},"241":{"OrderDetailID":241,"OrderID":10337,"ProductID":72,"Quantity":25},"242":{"OrderDetailID":242,"OrderID":10338,"ProductID":17,"Quantity":20},"243":{"OrderDetailID":243,"OrderID":10338,"ProductID":30,"Quantity":15},"244":{"OrderDetailID":244,"OrderID":10339,"ProductID":4,"Quantity":10},"245":{"OrderDetailID":245,"OrderID":10339,"ProductID":17,"Quantity":70},"246":{"OrderDetailID":246,"OrderID":10339,"ProductID":62,"Quantity":28},"247":{"OrderDetailID":247,"OrderID":10340,"ProductID":18,"Quantity":20},"248":{"OrderDetailID":248,"OrderID":10340,"ProductID":41,"Quantity":12},"249":{"OrderDetailID":249,"OrderID":10340,"ProductID":43,"Quantity":40},"250":{"OrderDetailID":250,"OrderID":10341,"ProductID":33,"Quantity":8},"251":{"OrderDetailID":251,"OrderID":10341,"ProductID":59,"Quantity":9},"252":{"OrderDetailID":252,"OrderID":10342,"ProductID":2,"Quantity":24},"253":{"OrderDetailID":253,"OrderID":10342,"ProductID":31,"Quantity":56},"254":{"OrderDetailID":254,"OrderID":10342,"ProductID":36,"Quantity":40},"255":{"OrderDetailID":255,"OrderID":10342,"ProductID":55,"Quantity":40},"256":{"OrderDetailID":256,"OrderID":10343,"ProductID":64,"Quantity":50},"257":{"OrderDetailID":257,"OrderID":10343,"ProductID":68,"Quantity":4},"258":{"OrderDetailID":258,"OrderID":10343,"ProductID":76,"Quantity":15},"259":{"OrderDetailID":259,"OrderID":10344,"ProductID":4,"Quantity":35},"260":{"OrderDetailID":260,"OrderID":10344,"ProductID":8,"Quantity":70},"261":{"OrderDetailID":261,"OrderID":10345,"ProductID":8,"Quantity":70},"262":{"OrderDetailID":262,"OrderID":10345,"ProductID":19,"Quantity":80},"263":{"OrderDetailID":263,"OrderID":10345,"ProductID":42,"Quantity":9},"264":{"OrderDetailID":264,"OrderID":10346,"ProductID":17,"Quantity":36},"265":{"OrderDetailID":265,"OrderID":10346,"ProductID":56,"Quantity":20},"266":{"OrderDetailID":266,"OrderID":10347,"ProductID":25,"Quantity":10},"267":{"OrderDetailID":267,"OrderID":10347,"ProductID":39,"Quantity":50},"268":{"OrderDetailID":268,"OrderID":10347,"ProductID":40,"Quantity":4},"269":{"OrderDetailID":269,"OrderID":10347,"ProductID":75,"Quantity":6},"270":{"OrderDetailID":270,"OrderID":10348,"ProductID":1,"Quantity":15},"271":{"OrderDetailID":271,"OrderID":10348,"ProductID":23,"Quantity":25},"272":{"OrderDetailID":272,"OrderID":10349,"ProductID":54,"Quantity":24},"273":{"OrderDetailID":273,"OrderID":10350,"ProductID":50,"Quantity":15},"274":{"OrderDetailID":274,"OrderID":10350,"ProductID":69,"Quantity":18},"275":{"OrderDetailID":275,"OrderID":10351,"ProductID":38,"Quantity":20},"276":{"OrderDetailID":276,"OrderID":10351,"ProductID":41,"Quantity":13},"277":{"OrderDetailID":277,"OrderID":10351,"ProductID":44,"Quantity":77},"278":{"OrderDetailID":278,"OrderID":10351,"ProductID":65,"Quantity":10},"279":{"OrderDetailID":279,"OrderID":10352,"ProductID":24,"Quantity":10},"280":{"OrderDetailID":280,"OrderID":10352,"ProductID":54,"Quantity":20},"281":{"OrderDetailID":281,"OrderID":10353,"ProductID":11,"Quantity":12},"282":{"OrderDetailID":282,"OrderID":10353,"ProductID":38,"Quantity":50},"283":{"OrderDetailID":283,"OrderID":10354,"ProductID":1,"Quantity":12},"284":{"OrderDetailID":284,"OrderID":10354,"ProductID":29,"Quantity":4},"285":{"OrderDetailID":285,"OrderID":10355,"ProductID":24,"Quantity":25},"286":{"OrderDetailID":286,"OrderID":10355,"ProductID":57,"Quantity":25},"287":{"OrderDetailID":287,"OrderID":10356,"ProductID":31,"Quantity":30},"288":{"OrderDetailID":288,"OrderID":10356,"ProductID":55,"Quantity":12},"289":{"OrderDetailID":289,"OrderID":10356,"ProductID":69,"Quantity":20},"290":{"OrderDetailID":290,"OrderID":10357,"ProductID":10,"Quantity":30},"291":{"OrderDetailID":291,"OrderID":10357,"ProductID":26,"Quantity":16},"292":{"OrderDetailID":292,"OrderID":10357,"ProductID":60,"Quantity":8},"293":{"OrderDetailID":293,"OrderID":10358,"ProductID":24,"Quantity":10},"294":{"OrderDetailID":294,"OrderID":10358,"ProductID":34,"Quantity":10},"295":{"OrderDetailID":295,"OrderID":10358,"ProductID":36,"Quantity":20},"296":{"OrderDetailID":296,"OrderID":10359,"ProductID":16,"Quantity":56},"297":{"OrderDetailID":297,"OrderID":10359,"ProductID":31,"Quantity":70},"298":{"OrderDetailID":298,"OrderID":10359,"ProductID":60,"Quantity":80},"299":{"OrderDetailID":299,"OrderID":10360,"ProductID":28,"Quantity":30},"300":{"OrderDetailID":300,"OrderID":10360,"ProductID":29,"Quantity":35},"301":{"OrderDetailID":301,"OrderID":10360,"ProductID":38,"Quantity":10},"302":{"OrderDetailID":302,"OrderID":10360,"ProductID":49,"Quantity":35},"303":{"OrderDetailID":303,"OrderID":10360,"ProductID":54,"Quantity":28},"304":{"OrderDetailID":304,"OrderID":10361,"ProductID":39,"Quantity":54},"305":{"OrderDetailID":305,"OrderID":10361,"ProductID":60,"Quantity":55},"306":{"OrderDetailID":306,"OrderID":10362,"ProductID":25,"Quantity":50},"307":{"OrderDetailID":307,"OrderID":10362,"ProductID":51,"Quantity":20},"308":{"OrderDetailID":308,"OrderID":10362,"ProductID":54,"Quantity":24},"309":{"OrderDetailID":309,"OrderID":10363,"ProductID":31,"Quantity":20},"310":{"OrderDetailID":310,"OrderID":10363,"ProductID":75,"Quantity":12},"311":{"OrderDetailID":311,"OrderID":10363,"ProductID":76,"Quantity":12},"312":{"OrderDetailID":312,"OrderID":10364,"ProductID":69,"Quantity":30},"313":{"OrderDetailID":313,"OrderID":10364,"ProductID":71,"Quantity":5},"314":{"OrderDetailID":314,"OrderID":10365,"ProductID":11,"Quantity":24},"315":{"OrderDetailID":315,"OrderID":10366,"ProductID":65,"Quantity":5},"316":{"OrderDetailID":316,"OrderID":10366,"ProductID":77,"Quantity":5},"317":{"OrderDetailID":317,"OrderID":10367,"ProductID":34,"Quantity":36},"318":{"OrderDetailID":318,"OrderID":10367,"ProductID":54,"Quantity":18},"319":{"OrderDetailID":319,"OrderID":10367,"ProductID":65,"Quantity":15},"320":{"OrderDetailID":320,"OrderID":10367,"ProductID":77,"Quantity":7},"321":{"OrderDetailID":321,"OrderID":10368,"ProductID":21,"Quantity":5},"322":{"OrderDetailID":322,"OrderID":10368,"ProductID":28,"Quantity":13},"323":{"OrderDetailID":323,"OrderID":10368,"ProductID":57,"Quantity":25},"324":{"OrderDetailID":324,"OrderID":10368,"ProductID":64,"Quantity":35},"325":{"OrderDetailID":325,"OrderID":10369,"ProductID":29,"Quantity":20},"326":{"OrderDetailID":326,"OrderID":10369,"ProductID":56,"Quantity":18},"327":{"OrderDetailID":327,"OrderID":10370,"ProductID":1,"Quantity":15},"328":{"OrderDetailID":328,"OrderID":10370,"ProductID":64,"Quantity":30},"329":{"OrderDetailID":329,"OrderID":10370,"ProductID":74,"Quantity":20},"330":{"OrderDetailID":330,"OrderID":10371,"ProductID":36,"Quantity":6},"331":{"OrderDetailID":331,"OrderID":10372,"ProductID":20,"Quantity":12},"332":{"OrderDetailID":332,"OrderID":10372,"ProductID":38,"Quantity":40},"333":{"OrderDetailID":333,"OrderID":10372,"ProductID":60,"Quantity":70},"334":{"OrderDetailID":334,"OrderID":10372,"ProductID":72,"Quantity":42},"335":{"OrderDetailID":335,"OrderID":10373,"ProductID":58,"Quantity":80},"336":{"OrderDetailID":336,"OrderID":10373,"ProductID":71,"Quantity":50},"337":{"OrderDetailID":337,"OrderID":10374,"ProductID":31,"Quantity":30},"338":{"OrderDetailID":338,"OrderID":10374,"ProductID":58,"Quantity":15},"339":{"OrderDetailID":339,"OrderID":10375,"ProductID":14,"Quantity":15},"340":{"OrderDetailID":340,"OrderID":10375,"ProductID":54,"Quantity":10},"341":{"OrderDetailID":341,"OrderID":10376,"ProductID":31,"Quantity":42},"342":{"OrderDetailID":342,"OrderID":10377,"ProductID":28,"Quantity":20},"343":{"OrderDetailID":343,"OrderID":10377,"ProductID":39,"Quantity":20},"344":{"OrderDetailID":344,"OrderID":10378,"ProductID":71,"Quantity":6},"345":{"OrderDetailID":345,"OrderID":10379,"ProductID":41,"Quantity":8},"346":{"OrderDetailID":346,"OrderID":10379,"ProductID":63,"Quantity":16},"347":{"OrderDetailID":347,"OrderID":10379,"ProductID":65,"Quantity":20},"348":{"OrderDetailID":348,"OrderID":10380,"ProductID":30,"Quantity":18},"349":{"OrderDetailID":349,"OrderID":10380,"ProductID":53,"Quantity":20},"350":{"OrderDetailID":350,"OrderID":10380,"ProductID":60,"Quantity":6},"351":{"OrderDetailID":351,"OrderID":10380,"ProductID":70,"Quantity":30},"352":{"OrderDetailID":352,"OrderID":10381,"ProductID":74,"Quantity":14},"353":{"OrderDetailID":353,"OrderID":10382,"ProductID":5,"Quantity":32},"354":{"OrderDetailID":354,"OrderID":10382,"ProductID":18,"Quantity":9},"355":{"OrderDetailID":355,"OrderID":10382,"ProductID":29,"Quantity":14},"356":{"OrderDetailID":356,"OrderID":10382,"ProductID":33,"Quantity":60},"357":{"OrderDetailID":357,"OrderID":10382,"ProductID":74,"Quantity":50},"358":{"OrderDetailID":358,"OrderID":10383,"ProductID":13,"Quantity":20},"359":{"OrderDetailID":359,"OrderID":10383,"ProductID":50,"Quantity":15},"360":{"OrderDetailID":360,"OrderID":10383,"ProductID":56,"Quantity":20},"361":{"OrderDetailID":361,"OrderID":10384,"ProductID":20,"Quantity":28},"362":{"OrderDetailID":362,"OrderID":10384,"ProductID":60,"Quantity":15},"363":{"OrderDetailID":363,"OrderID":10385,"ProductID":7,"Quantity":10},"364":{"OrderDetailID":364,"OrderID":10385,"ProductID":60,"Quantity":20},"365":{"OrderDetailID":365,"OrderID":10385,"ProductID":68,"Quantity":8},"366":{"OrderDetailID":366,"OrderID":10386,"ProductID":24,"Quantity":15},"367":{"OrderDetailID":367,"OrderID":10386,"ProductID":34,"Quantity":10},"368":{"OrderDetailID":368,"OrderID":10387,"ProductID":24,"Quantity":15},"369":{"OrderDetailID":369,"OrderID":10387,"ProductID":28,"Quantity":6},"370":{"OrderDetailID":370,"OrderID":10387,"ProductID":59,"Quantity":12},"371":{"OrderDetailID":371,"OrderID":10387,"ProductID":71,"Quantity":15},"372":{"OrderDetailID":372,"OrderID":10388,"ProductID":45,"Quantity":15},"373":{"OrderDetailID":373,"OrderID":10388,"ProductID":52,"Quantity":20},"374":{"OrderDetailID":374,"OrderID":10388,"ProductID":53,"Quantity":40},"375":{"OrderDetailID":375,"OrderID":10389,"ProductID":10,"Quantity":16},"376":{"OrderDetailID":376,"OrderID":10389,"ProductID":55,"Quantity":15},"377":{"OrderDetailID":377,"OrderID":10389,"ProductID":62,"Quantity":20},"378":{"OrderDetailID":378,"OrderID":10389,"ProductID":70,"Quantity":30},"379":{"OrderDetailID":379,"OrderID":10390,"ProductID":31,"Quantity":60},"380":{"OrderDetailID":380,"OrderID":10390,"ProductID":35,"Quantity":40},"381":{"OrderDetailID":381,"OrderID":10390,"ProductID":46,"Quantity":45},"382":{"OrderDetailID":382,"OrderID":10390,"ProductID":72,"Quantity":24},"383":{"OrderDetailID":383,"OrderID":10391,"ProductID":13,"Quantity":18},"384":{"OrderDetailID":384,"OrderID":10392,"ProductID":69,"Quantity":50},"385":{"OrderDetailID":385,"OrderID":10393,"ProductID":2,"Quantity":25},"386":{"OrderDetailID":386,"OrderID":10393,"ProductID":14,"Quantity":42},"387":{"OrderDetailID":387,"OrderID":10393,"ProductID":25,"Quantity":7},"388":{"OrderDetailID":388,"OrderID":10393,"ProductID":26,"Quantity":70},"389":{"OrderDetailID":389,"OrderID":10393,"ProductID":31,"Quantity":32},"390":{"OrderDetailID":390,"OrderID":10394,"ProductID":13,"Quantity":10},"391":{"OrderDetailID":391,"OrderID":10394,"ProductID":62,"Quantity":10},"392":{"OrderDetailID":392,"OrderID":10395,"ProductID":46,"Quantity":28},"393":{"OrderDetailID":393,"OrderID":10395,"ProductID":53,"Quantity":70},"394":{"OrderDetailID":394,"OrderID":10395,"ProductID":69,"Quantity":8},"395":{"OrderDetailID":395,"OrderID":10396,"ProductID":23,"Quantity":40},"396":{"OrderDetailID":396,"OrderID":10396,"ProductID":71,"Quantity":60},"397":{"OrderDetailID":397,"OrderID":10396,"ProductID":72,"Quantity":21},"398":{"OrderDetailID":398,"OrderID":10397,"ProductID":21,"Quantity":10},"399":{"OrderDetailID":399,"OrderID":10397,"ProductID":51,"Quantity":18},"400":{"OrderDetailID":400,"OrderID":10398,"ProductID":35,"Quantity":30},"401":{"OrderDetailID":401,"OrderID":10398,"ProductID":55,"Quantity":120},"402":{"OrderDetailID":402,"OrderID":10399,"ProductID":68,"Quantity":60},"403":{"OrderDetailID":403,"OrderID":10399,"ProductID":71,"Quantity":30},"404":{"OrderDetailID":404,"OrderID":10399,"ProductID":76,"Quantity":35},"405":{"OrderDetailID":405,"OrderID":10399,"ProductID":77,"Quantity":14},"406":{"OrderDetailID":406,"OrderID":10400,"ProductID":29,"Quantity":21},"407":{"OrderDetailID":407,"OrderID":10400,"ProductID":35,"Quantity":35},"408":{"OrderDetailID":408,"OrderID":10400,"ProductID":49,"Quantity":30},"409":{"OrderDetailID":409,"OrderID":10401,"ProductID":30,"Quantity":18},"410":{"OrderDetailID":410,"OrderID":10401,"ProductID":56,"Quantity":70},"411":{"OrderDetailID":411,"OrderID":10401,"ProductID":65,"Quantity":20},"412":{"OrderDetailID":412,"OrderID":10401,"ProductID":71,"Quantity":60},"413":{"OrderDetailID":413,"OrderID":10402,"ProductID":23,"Quantity":60},"414":{"OrderDetailID":414,"OrderID":10402,"ProductID":63,"Quantity":65},"415":{"OrderDetailID":415,"OrderID":10403,"ProductID":16,"Quantity":21},"416":{"OrderDetailID":416,"OrderID":10403,"ProductID":48,"Quantity":70},"417":{"OrderDetailID":417,"OrderID":10404,"ProductID":26,"Quantity":30},"418":{"OrderDetailID":418,"OrderID":10404,"ProductID":42,"Quantity":40},"419":{"OrderDetailID":419,"OrderID":10404,"ProductID":49,"Quantity":30},"420":{"OrderDetailID":420,"OrderID":10405,"ProductID":3,"Quantity":50},"421":{"OrderDetailID":421,"OrderID":10406,"ProductID":1,"Quantity":10},"422":{"OrderDetailID":422,"OrderID":10406,"ProductID":21,"Quantity":30},"423":{"OrderDetailID":423,"OrderID":10406,"ProductID":28,"Quantity":42},"424":{"OrderDetailID":424,"OrderID":10406,"ProductID":36,"Quantity":5},"425":{"OrderDetailID":425,"OrderID":10406,"ProductID":40,"Quantity":2},"426":{"OrderDetailID":426,"OrderID":10407,"ProductID":11,"Quantity":30},"427":{"OrderDetailID":427,"OrderID":10407,"ProductID":69,"Quantity":15},"428":{"OrderDetailID":428,"OrderID":10407,"ProductID":71,"Quantity":15},"429":{"OrderDetailID":429,"OrderID":10408,"ProductID":37,"Quantity":10},"430":{"OrderDetailID":430,"OrderID":10408,"ProductID":54,"Quantity":6},"431":{"OrderDetailID":431,"OrderID":10408,"ProductID":62,"Quantity":35},"432":{"OrderDetailID":432,"OrderID":10409,"ProductID":14,"Quantity":12},"433":{"OrderDetailID":433,"OrderID":10409,"ProductID":21,"Quantity":12},"434":{"OrderDetailID":434,"OrderID":10410,"ProductID":33,"Quantity":49},"435":{"OrderDetailID":435,"OrderID":10410,"ProductID":59,"Quantity":16},"436":{"OrderDetailID":436,"OrderID":10411,"ProductID":41,"Quantity":25},"437":{"OrderDetailID":437,"OrderID":10411,"ProductID":44,"Quantity":40},"438":{"OrderDetailID":438,"OrderID":10411,"ProductID":59,"Quantity":9},"439":{"OrderDetailID":439,"OrderID":10412,"ProductID":14,"Quantity":20},"440":{"OrderDetailID":440,"OrderID":10413,"ProductID":1,"Quantity":24},"441":{"OrderDetailID":441,"OrderID":10413,"ProductID":62,"Quantity":40},"442":{"OrderDetailID":442,"OrderID":10413,"ProductID":76,"Quantity":14},"443":{"OrderDetailID":443,"OrderID":10414,"ProductID":19,"Quantity":18},"444":{"OrderDetailID":444,"OrderID":10414,"ProductID":33,"Quantity":50},"445":{"OrderDetailID":445,"OrderID":10415,"ProductID":17,"Quantity":2},"446":{"OrderDetailID":446,"OrderID":10415,"ProductID":33,"Quantity":20},"447":{"OrderDetailID":447,"OrderID":10416,"ProductID":19,"Quantity":20},"448":{"OrderDetailID":448,"OrderID":10416,"ProductID":53,"Quantity":10},"449":{"OrderDetailID":449,"OrderID":10416,"ProductID":57,"Quantity":20},"450":{"OrderDetailID":450,"OrderID":10417,"ProductID":38,"Quantity":50},"451":{"OrderDetailID":451,"OrderID":10417,"ProductID":46,"Quantity":2},"452":{"OrderDetailID":452,"OrderID":10417,"ProductID":68,"Quantity":36},"453":{"OrderDetailID":453,"OrderID":10417,"ProductID":77,"Quantity":35},"454":{"OrderDetailID":454,"OrderID":10418,"ProductID":2,"Quantity":60},"455":{"OrderDetailID":455,"OrderID":10418,"ProductID":47,"Quantity":55},"456":{"OrderDetailID":456,"OrderID":10418,"ProductID":61,"Quantity":16},"457":{"OrderDetailID":457,"OrderID":10418,"ProductID":74,"Quantity":15},"458":{"OrderDetailID":458,"OrderID":10419,"ProductID":60,"Quantity":60},"459":{"OrderDetailID":459,"OrderID":10419,"ProductID":69,"Quantity":20},"460":{"OrderDetailID":460,"OrderID":10420,"ProductID":9,"Quantity":20},"461":{"OrderDetailID":461,"OrderID":10420,"ProductID":13,"Quantity":2},"462":{"OrderDetailID":462,"OrderID":10420,"ProductID":70,"Quantity":8},"463":{"OrderDetailID":463,"OrderID":10420,"ProductID":73,"Quantity":20},"464":{"OrderDetailID":464,"OrderID":10421,"ProductID":19,"Quantity":4},"465":{"OrderDetailID":465,"OrderID":10421,"ProductID":26,"Quantity":30},"466":{"OrderDetailID":466,"OrderID":10421,"ProductID":53,"Quantity":15},"467":{"OrderDetailID":467,"OrderID":10421,"ProductID":77,"Quantity":10},"468":{"OrderDetailID":468,"OrderID":10422,"ProductID":26,"Quantity":2},"469":{"OrderDetailID":469,"OrderID":10423,"ProductID":31,"Quantity":14},"470":{"OrderDetailID":470,"OrderID":10423,"ProductID":59,"Quantity":20},"471":{"OrderDetailID":471,"OrderID":10424,"ProductID":35,"Quantity":60},"472":{"OrderDetailID":472,"OrderID":10424,"ProductID":38,"Quantity":49},"473":{"OrderDetailID":473,"OrderID":10424,"ProductID":68,"Quantity":30},"474":{"OrderDetailID":474,"OrderID":10425,"ProductID":55,"Quantity":10},"475":{"OrderDetailID":475,"OrderID":10425,"ProductID":76,"Quantity":20},"476":{"OrderDetailID":476,"OrderID":10426,"ProductID":56,"Quantity":5},"477":{"OrderDetailID":477,"OrderID":10426,"ProductID":64,"Quantity":7},"478":{"OrderDetailID":478,"OrderID":10427,"ProductID":14,"Quantity":35},"479":{"OrderDetailID":479,"OrderID":10428,"ProductID":46,"Quantity":20},"480":{"OrderDetailID":480,"OrderID":10429,"ProductID":50,"Quantity":40},"481":{"OrderDetailID":481,"OrderID":10429,"ProductID":63,"Quantity":35},"482":{"OrderDetailID":482,"OrderID":10430,"ProductID":17,"Quantity":45},"483":{"OrderDetailID":483,"OrderID":10430,"ProductID":21,"Quantity":50},"484":{"OrderDetailID":484,"OrderID":10430,"ProductID":56,"Quantity":30},"485":{"OrderDetailID":485,"OrderID":10430,"ProductID":59,"Quantity":70},"486":{"OrderDetailID":486,"OrderID":10431,"ProductID":17,"Quantity":50},"487":{"OrderDetailID":487,"OrderID":10431,"ProductID":40,"Quantity":50},"488":{"OrderDetailID":488,"OrderID":10431,"ProductID":47,"Quantity":30},"489":{"OrderDetailID":489,"OrderID":10432,"ProductID":26,"Quantity":10},"490":{"OrderDetailID":490,"OrderID":10432,"ProductID":54,"Quantity":40},"491":{"OrderDetailID":491,"OrderID":10433,"ProductID":56,"Quantity":28},"492":{"OrderDetailID":492,"OrderID":10434,"ProductID":11,"Quantity":6},"493":{"OrderDetailID":493,"OrderID":10434,"ProductID":76,"Quantity":18},"494":{"OrderDetailID":494,"OrderID":10435,"ProductID":2,"Quantity":10},"495":{"OrderDetailID":495,"OrderID":10435,"ProductID":22,"Quantity":12},"496":{"OrderDetailID":496,"OrderID":10435,"ProductID":72,"Quantity":10},"497":{"OrderDetailID":497,"OrderID":10436,"ProductID":46,"Quantity":5},"498":{"OrderDetailID":498,"OrderID":10436,"ProductID":56,"Quantity":40},"499":{"OrderDetailID":499,"OrderID":10436,"ProductID":64,"Quantity":30},"500":{"OrderDetailID":500,"OrderID":10436,"ProductID":75,"Quantity":24},"501":{"OrderDetailID":501,"OrderID":10437,"ProductID":53,"Quantity":15},"502":{"OrderDetailID":502,"OrderID":10438,"ProductID":19,"Quantity":15},"503":{"OrderDetailID":503,"OrderID":10438,"ProductID":34,"Quantity":20},"504":{"OrderDetailID":504,"OrderID":10438,"ProductID":57,"Quantity":15},"505":{"OrderDetailID":505,"OrderID":10439,"ProductID":12,"Quantity":15},"506":{"OrderDetailID":506,"OrderID":10439,"ProductID":16,"Quantity":16},"507":{"OrderDetailID":507,"OrderID":10439,"ProductID":64,"Quantity":6},"508":{"OrderDetailID":508,"OrderID":10439,"ProductID":74,"Quantity":30},"509":{"OrderDetailID":509,"OrderID":10440,"ProductID":2,"Quantity":45},"510":{"OrderDetailID":510,"OrderID":10440,"ProductID":16,"Quantity":49},"511":{"OrderDetailID":511,"OrderID":10440,"ProductID":29,"Quantity":24},"512":{"OrderDetailID":512,"OrderID":10440,"ProductID":61,"Quantity":90},"513":{"OrderDetailID":513,"OrderID":10441,"ProductID":27,"Quantity":50},"514":{"OrderDetailID":514,"OrderID":10442,"ProductID":11,"Quantity":30},"515":{"OrderDetailID":515,"OrderID":10442,"ProductID":54,"Quantity":80},"516":{"OrderDetailID":516,"OrderID":10442,"ProductID":66,"Quantity":60},"517":{"OrderDetailID":517,"OrderID":10443,"ProductID":11,"Quantity":6},"518":{"OrderDetailID":518,"OrderID":10443,"ProductID":28,"Quantity":12}}});

    globalThis.highlight = highlight;
    class App extends Ractive {
        constructor(opts) {
            super(opts);
        }
    }
    Ractive.perComponentStyleElements = true;
    Ractive.extendWith(App, {
        template: '#template',
        data() {
            return {
                sources: [{ name: 'sample', values() { return Promise.resolve(data()); } }],
                sample: data,
            };
        },
        components: {
            report: Designer,
        },
        on: {
            'report.running'() {
                console.time('run');
            },
            'report.run'() {
                console.timeEnd('run');
            },
            init() {
                setTimeout(() => {
                    const json = window.sessionStorage.getItem('load') || '{}';
                    try {
                        const load = JSON.parse(json);
                        if (load.project) {
                            const pjs = this.report.get('projects') || [];
                            const pj = pjs.findIndex(p => p.name === load.project);
                            if (~pj)
                                this.report.linkProject(`projects.${pj}`);
                        }
                        if (load.report)
                            this.report.set('report', load.report);
                        if (load.expr)
                            this.report.set('temp.expr.str', load.expr);
                        this.report.set('show.bottom', load.bottom);
                        this.report.set('max.bottom', load.max);
                        this.set('loaded', true);
                    }
                    catch (_a) { }
                }, 500);
                window.addEventListener('beforeunload', () => {
                    if (this.get('loaded') && this.report) {
                        const load = { report: this.report.get('report'), bottom: this.report.get('show.bottom'), max: this.report.get('max.bottom'), project: this.report.get('project.name') };
                        if (!this.report.get('temp.expr.path'))
                            load.expr = this.report.get('temp.expr.str');
                        window.sessionStorage.setItem('load', JSON.stringify(load));
                    }
                    else {
                        window.sessionStorage.clear();
                    }
                });
            },
        }
    });
    const app = globalThis.app = new App({
        target: 'body',
    });
    app.parse = parse$4;
    app.parseTemplate = parse$3;
    app.stringify = stringify;
    // simple debug helper
    let el;
    document.addEventListener('click', ev => el = ev.target, { capture: true });
    document.addEventListener('focus', ev => el = ev.target, { capture: true });
    Object.defineProperty(globalThis, 'R', {
        value: new Proxy(() => ({}), {
            apply(_obj, _e, args) {
                if (args.length) {
                    let ctx;
                    if (typeof args[0] === 'object' && args[0] instanceof Node)
                        ctx = Ractive.getContext(args.shift());
                    else
                        ctx = Ractive.getContext(el);
                    if (!ctx)
                        return;
                    if (typeof args[0] === 'string') {
                        if (args.length === 1)
                            return ctx.get(args[0]);
                        else if (args.length === 2)
                            return ctx.set(args[0], args[1]);
                    }
                    else if (typeof args[0] === 'object') {
                        return ctx.set(args[0]);
                    }
                    return ctx;
                }
                else {
                    return Ractive.getContext(el).get();
                }
            },
            get(_obj, prop) {
                const ctx = Ractive.getContext(el);
                if (!ctx)
                    return;
                if (!(prop in ctx) && prop in ctx.ractive) {
                    const val = ctx.ractive[prop];
                    if (typeof val === 'function')
                        return val.bind(ctx.ractive);
                    return val;
                }
                else {
                    return ctx[prop];
                }
            },
        }),
    });

}());
//# sourceMappingURL=index.js.map
